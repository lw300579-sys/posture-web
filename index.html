<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Posture Analysis & Personalized Biomechanics Protocol</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">


    
<!-- React & Dependencies (2025 Immortal CDN) -->
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<!-- TensorFlow.js Core Stack (Fixed CDN Paths) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
<script type="module">
    // 1. Import the specific classes we need from the CDN
    import {
        PoseLandmarker,
        FilesetResolver,
        DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

    // 2. Attach them to the global window object so the React app can see them
    window.mpVision = {
        PoseLandmarker,
        FilesetResolver,
        DrawingUtils
    };

    // 3. Signal that the bridge is complete
    window.mpReady = true;
    console.log("✅ MediaPipe Bridge Established: Neural Core Ready for Linkage");
</script>
<!-- TensorFlow (Lazy Loaded) -->
<script type="importmap">
  {
    "imports": {
      "@google/generative-ai": "https://esm.run/@google/generative-ai"
    }
  }
</script>
<script type="module">
  import { GoogleGenerativeAI } from "@google/generative-ai";
  // We attach it to 'window' so your React code can see it
  window.GoogleGenerativeAI = GoogleGenerativeAI;
</script>

<style>
    body { background-color: #020617; color: #e2e8f0; font-family: 'Inter', system-ui, sans-serif; overflow: hidden; font-size: 16px; }
    .workspace { 
    display: grid; 
    grid-template-columns: 1fr 350px; 
    height: 100vh; 
    transition: grid-template-columns 0.6s ease-out cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.workspace.post-analysis {
    grid-template-columns: 480px 1fr;
}
    .viewport { 
    position: relative; 
    display: flex; 
    flex-direction: column; 
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(4px);
    isolation: isolate;  /* Safe layer promotion—no clip */
    transition: opacity 0.4s ease, transform 0.4s ease;
    border-right: 1px solid rgba(148, 163, 184, 0.1); 
    overflow-y: auto; 
    padding: 3rem; 
    transition: all 0.8s ease;
    /* Remove contain during scroll-heavy states if needed: contain: none; */
}
.glass-panel { 
    background: linear-gradient(135deg, rgba(15, 23, 42, 0.8), rgba(2, 6, 23, 0.9));  
    backdrop-filter: blur(4px);
    isolation: isolate;
    transition: transform 0.5s ease-out, opacity 0.5s ease-out;
    border-left: 1px solid rgba(148, 163, 184, 0.2);
    height: 100vh; 
    z-index: 40; 
    display: flex;
    flex-direction: column;
    overflow-y: hidden;
    box-shadow: -20px 0 40px rgba(0,0,0,0.5);
    transition: all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.glass-panel.expanded {
    background: linear-gradient(to left, rgba(15,23,42,0.95), rgba(2,6,23,1));
}
    
    .upload-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2rem;
    height: 100%;
    padding: 1rem 0;
    
}

@media (max-width: 1400px) {
    .upload-grid {
        gap: 1.5rem;
    }
}
@media (max-width: 1280px) {
    .upload-grid {
        grid-template-columns: 1fr 1fr;
    }
}
@media (max-width: 768px) {
    .upload-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
}
    .upload-slot { 
    border: 3px dashed rgba(103, 116, 139, 0.6); 
    border-radius: 32px; 
    background: rgba(30, 41, 59, 0.5); 
    backdrop-filter: blur(4px);
    isolation: isolate;
    min-height: 540px;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    position: relative;
    overflow: hidden;
}
    .upload-slot:hover { border-color: #22d3ee; background: #1e293b/50; }
    .upload-slot.active { border-style: solid; border-color: #22d3ee; }
    .upload-slot img { width: 100%; height: 100%; object-fit: contain; opacity: 0.6; }

/* FIXED: Scanning Animation - Now shows during analysis! */
    .upload-slot.scanning .scanner-line {
        display: block !important;
        opacity: 1 !important;
        animation: scanDown 5s ease-in-out infinite; /* Faster loop for premium feel */
    }
.analyzing .upload-slot.active .scanner-line {
    display: block !important;
    opacity: 1 !important;
    animation: scanDown 5s ease-in-out infinite !important; /* A bit faster for premium feel */
    box-shadow: 0 0 60px #22d3ee, 0 0 120px rgba(34, 211, 238, 0.9) !important; /* Extra glow! */
}
    
    .btn-primary { 
        background: linear-gradient(135deg, #06b6d4 0%, #0ea5e9 100%); 
        box-shadow: 0 10px 30px rgba(6, 182, 212, 0.4);
        font-size: 1.2rem;
        padding: 1.5rem 3rem;
        border-radius: 1.5rem;
    }
    .btn-primary:hover { 
        transform: translateY(-4px) scale(1.02); 
        box-shadow: 0 20px 40px rgba(6, 182, 212, 0.5); 
    }
    .btn-primary:active { 
        transform: translateY(1px); box-shadow: 0 2px 8px rgba(6, 182, 212, 0.2); filter: brightness(0.95); }
    .btn-primary:disabled { opacity: 0.7; cursor: wait; transform: none; }

    .btn-secondary { background: #1e293b; border: 1px solid #334155; color: #94a3b8; font-weight: bold; padding: 16px 24px; border-radius: 8px; transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; font-size: 12px; cursor: pointer; }
    .btn-secondary:hover { border-color: #64748b; color: white; }

    .protocol-badge { font-size: 9px; padding: 2px 6px; border-radius: 4px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.5px; background: #0f172a; border: 1px solid #334155; color: #94a3b8; cursor: pointer; transition: all 0.2s; }
    .protocol-badge:hover { border-color: #22d3ee; color: #22d3ee; }

    .fascia-tag { font-size: 10px; font-weight: bold; padding: 4px 8px; background: #0f172a; border: 1px solid #334155; border-radius: 4px; color: #94a3b8; display: flex; justify-content: space-between; }
    .symptom-tag { background: #450a0a; border-color: #ef4444; color: #fca5a5; }
    
    .symptom-chip {
        padding: 6px 12px; border-radius: 20px; border: 1px solid #334155; background: #1e293b; color: #94a3b8; 
        font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px;
    }
    .symptom-chip:hover { border-color: #64748b; }
    .symptom-chip.selected { background: #f43f5e; border-color: #e11d48; color: white; box-shadow: 0 2px 8px rgba(244, 63, 94, 0.4); }
    
    .tab-btn { padding: 8px 16px; font-size: 11px; font-weight: 700; text-transform: uppercase; color: #64748b; cursor: pointer; transition: all 0.2s; border-bottom: 2px solid transparent; }
    .tab-btn.active { color: #22d3ee; border-bottom-color: #22d3ee; }

    .task-card { background: #1e293b/40; border: 1px solid #334155; border-radius: 8px; padding: 12px; transition: all 0.2s; display: flex; align-items: center; gap: 12px; cursor: pointer; }
    .task-card:hover { border-color: #22d3ee; background: #1e293b/60; }
    .task-card.completed { border-color: #10b981; background: #064e3b/20; }
    .task-check { width: 18px; height: 18px; border-radius: 50%; border: 2px solid #475569; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
    .task-card.completed .task-check { background: #10b981; border-color: #10b981; }

    /* Chat Styles */
    .chat-bubble { padding: 10px 14px; border-radius: 12px; font-size: 12px; line-height: 1.5; max-width: 90%; margin-bottom: 8px; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .chat-user { background: #0891b2; color: white; align-self: flex-end; border-bottom-right-radius: 2px; margin-left: auto; }
    .chat-ai { background: #1e293b; color: #e2e8f0; align-self: flex-start; border-bottom-left-radius: 2px; border: 1px solid #334155; }
    @keyframes popIn { from { opacity: 0; transform: scale(0.9) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
    
    .animate-popIn { animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

    /* Enhanced Premium Scanner */
.scanner-line { 
    position: absolute; 
    left: 0; right: 0; 
    height: 12px; 
    background: linear-gradient(90deg, transparent, #22d3ee, #fff, #22d3ee, transparent);
    box-shadow: 
        0 0 40px #22d3ee,
        0 0 100px rgba(34, 211, 238, 0.8);
    animation: scanDown 10s ease-in-out infinite;
    z-index: 25; 
    display: none;
    opacity: 0;
    pointer-events: none;
}

@keyframes scanDown { 
    0% { top: 0%; opacity: 0; transform: scaleX(0.5); }
    10% { opacity: 1; transform: scaleX(1); }
    90% { opacity: 1; transform: scaleX(1); }
    100% { top: 100%; opacity: 0; transform: scaleX(0.5); }
}

    /* Avatar Breathing Animation */
    .body-part { 
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    cursor: pointer; 
}
.body-part:hover { 
    filter: brightness(1.8) drop-shadow(0 0 30px #22d3ee); 
    transform: scale(1.12); 
}
.body-part:active {
    transform: scale(1.05);
    filter: brightness(2) drop-shadow(0 0 40px #22d3ee);
}
/* Enhanced tap feedback for avatar parts */
.body-part.tapped {
    animation: tapPulse 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    filter: brightness(2.5) drop-shadow(0 0 50px #22d3ee) drop-shadow(0 0 100px #06b6d4);
    transform: scale(1.25) !important;
    z-index: 50;
}

.body-part.tapped::after {
    content: '';
    position: absolute;
    inset: -20px;
    border: 4px solid #22d3ee;
    border-radius: 50%;
    opacity: 0;
    animation: ripple 1.2s ease-out forwards;
    pointer-events: none;
}

@keyframes tapPulse {
    0% { transform: scale(1); filter: brightness(1) drop-shadow(0 0 30px #22d3ee); }
    50% { transform: scale(1.4); filter: brightness(3) drop-shadow(0 0 80px #22d3ee); }
    100% { transform: scale(1.15); filter: brightness(2) drop-shadow(0 0 60px #22d3ee); }
}

@keyframes ripple {
    0% { transform: scale(0.8); opacity: 1; border-width: 8px; }
    100% { transform: scale(2.5); opacity: 0; border-width: 2px; }
}

/* Tooltip on tap */
.part-tooltip {
    position: fixed;  /* CHANGE: absolute → fixed */
    background: rgba(2, 6, 23, 0.95);
    backdrop-filter: blur(12px);
    border: 1px solid #22d3ee;
    border-radius: 16px;
    padding: 12px 16px;
    font-size: 12px;
    font-weight: bold;
    color: white;
    box-shadow: 0 10px 40px rgba(34, 211, 238, 0.4);
    z-index: 1000;
    pointer-events: none;
    animation: fadeInUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    max-width: 220px;
    text-align: center;
    left: 50% !important;     /* ADD THIS LINE */
    transform: translate(-50%, -100%);  /* CHANGE: -120% → -100% */
    top: auto !important;
    bottom: 100px;  /* Optional: pushes it up a bit from bottom on small screens */
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
    
    /* Confetti CSS */
    .confetti { position: absolute; width: 8px; height: 8px; background: #22d3ee; animation: confetti-fall 3s linear infinite; opacity: 0; }
    @keyframes confetti-fall {
        0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
        100% { transform: translateY(500px) rotate(720deg); opacity: 0; }
    }

    /* NEW: Progress Streak Styles */
    .streak-flame { animation: flicker 2s infinite alternate; }
    @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

    /* NEW: Goal Tracker Styles */
    .goal-progress { background: linear-gradient(to right, #10b981, #059669); height: 4px; border-radius: 2px; transition: width 0.3s ease; }

    @media print {
        body { background: white; color: black; overflow: visible; }
        .workspace { display: flex; height: auto; }
        .viewport, .glass-panel { width: 100%; height: auto; border: none; overflow: visible; }
        .upload-grid { display: grid; grid-template-columns: repeat(3, 1fr); height: 200px; margin-bottom: 2rem; }
        .upload-slot { border: 1px solid #ccc; background: white; }
        .upload-slot img { opacity: 1; }
        .no-print { display: none !important; }
        .text-white { color: black !important; }
        .text-slate-500 { color: #666 !important; }
        .bg-slate-900\/50 { background: none !important; border: 1px solid #eee; }
        .protocol-badge { border: 1px solid #000; color: #000; }
/* Add this inside your <style> tag */
.animate-popIn { 
    animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; 
}
@keyframes popIn { 
    from { opacity: 0; transform: scale(0.95) translateY(20px); } 
    to { opacity: 1; transform: scale(1) translateY(0); } 
}
    } @media (max-width: 1400px) {
    .workspace { grid-template-columns: 1fr 400px; }
}
@media (max-width: 1200px) {
    .upload-grid { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width: 768px) {
    .workspace { grid-template-columns: 1fr; }
    /* DEFAULT HIDDEN, BUT VISIBLE WHEN EXPANDED (Analyzing/Results) */
    .glass-panel { display: none; } 
    .glass-panel.expanded { 
        display: flex !important; 
        position: fixed; 
        inset: 0; 
        width: 100%; 
        height: 100%; 
        z-index: 100;
        background: #020617; /* Solid background for mobile legibility */
    }
    .upload-grid { grid-template-columns: 1fr; }
}
@keyframes pulse-slow {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.03); opacity: 0.95; }
}
.animate-pulse-slow { 
    animation: pulse-slow 8s infinite ease-in-out; 
}
.living-avatar { 
    filter: drop-shadow(0 0 30px rgba(34,211,238,0.3)); 
}
.bg-size-200 { background-size: 200% 200%; }
.bg-pos-0 { background-position: 0% 50%; }
.bg-pos-100 { background-position: 100% 50%; }
.hover\\:bg-pos-100:hover { background-position: 100% 50%; }
.body-part, .upload-slot, .btn-primary, .glass-panel, .workspace {
    will-change: transform, opacity, filter;
    transform: translateZ(0); /* or translate3d(0,0,0) - forces GPU layer */
    backface-visibility: hidden; /* optional, reduces repaint */
    contain: layout style paint;

}

.chat-bubble, .animate-popIn, .task-card {
    will-change: transform, opacity;
}
/* Optimized GPU Acceleration */
.viewport, .glass-panel, .upload-slot, .body-part, canvas {
    backface-visibility: hidden;
    transform: translate3d(0,0,0);
}

/* Limit will-change to only what moves frequently */
.workspace {
    will-change: grid-template-columns;
}

.scanner-line {
    will-change: top;
}

/* Smooth Scrolling */
.viewport, .glass-panel {
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
    scroll-behavior: smooth;
    overscroll-behavior: contain;
    contain: layout style; /* Keeps it fast */
    backdrop-filter: none !important; /* Turns off blurry background - big speed win! */
    background-attachment: scroll; /* Helps with lag */
}


/* FIXED: Pause animations during analysis to kill lag */
.analyzing .animate-pulse-slow,
.analyzing .living-avatar {
    animation-play-state: paused !important;
}
/* EASY MODE: Shrink everything on small screens */
@media (max-width: 1024px) {
    .viewport { padding: 0.5rem 1rem !important; } /* Less padding everywhere */
    .upload-slot { min-height: 250px !important; } /* Smaller slots but still roomy */
}
@media (max-width: 768px) {
    .viewport { padding: 0.25rem 0.5rem !important; } /* Tiny padding on phone */
    .upload-grid { gap: 0.5rem !important; padding: 0 !important; } /* No gaps waste */
    h1 { font-size: 2rem !important; line-height: 1 !important; } /* Tiny title */
    .btn-primary { py: 2 !important; text-2xl !important; } /* Small button */
}
</style></head>
<body>
    <div id="root"></div>
    <script type="text/babel">

const { useState, useEffect, useRef, useMemo, useCallback } = React;

const calculateAngle = (p1, p2, p3) => {
  if (!p1 || !p2 || !p3) return 0;
  const v1 = [p1.x - p2.x, p1.y - p2.y];
  const v2 = [p3.x - p2.x, p3.y - p2.y];
  const dot = v1[0] * v2[0] + v1[1] * v2[1];
  const mag1 = Math.sqrt(v1[0]**2 + v1[1]**2);
  const mag2 = Math.sqrt(v2[0]**2 + v2[1]**2);
  return Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
};

const calculateLivePostureScore = (keypoints) => {
  if (!keypoints || keypoints.length < 33) return 50;  // Early guard

  let total = 0;
  let count = 0;

  const valid = (kp) => kp && (kp.score || kp.visibility || 0) > 0.3;  // Lower threshold for live

  // Get proportions for normalization
  const leftShoulder = keypoints[11];
  const rightShoulder = keypoints[12];
  const shoulderWidth = valid(leftShoulder) && valid(rightShoulder) ? Math.abs(leftShoulder.x - rightShoulder.x) : 0.2;  // Default 20% if missing
  const estHeight = Math.max(...keypoints.map(kp => kp.y || 0)) - Math.min(...keypoints.map(kp => kp.y || 0)) || 1;  // Full body y-span

  // Forward Head: Normalize dev by shoulder width
  const nose = keypoints[0];
  if (valid(nose) && valid(leftShoulder) && valid(rightShoulder)) {
    const midShoulderX = (leftShoulder.x + rightShoulder.x) / 2;
    const headDeviation = Math.abs(nose.x - midShoulderX) / shoulderWidth;  // Relative to width
    total += Math.max(0, 100 - (headDeviation * 400));  // Softer multiplier
    count++;
  }

  // Shoulder levelness: Normalize by height (vertical diffs scale with tall bodies)
  if (valid(leftShoulder) && valid(rightShoulder)) {
    const shoulderDiff = Math.abs(leftShoulder.y - rightShoulder.y) / estHeight;
    total += Math.max(0, 100 - (shoulderDiff * 800));  // Adjusted
    count++;
  }

  // Hip levelness: Similar normalization
  const leftHip = keypoints[23];
  const rightHip = keypoints[24];
  if (valid(leftHip) && valid(rightHip)) {
    const hipDiff = Math.abs(leftHip.y - rightHip.y) / estHeight;
    total += Math.max(0, 100 - (hipDiff * 800));
    count++;
  }

  // Knee alignment: PER-LEG valgus/varus (FIX: Was mid-only)
  const leftKnee = keypoints[25];
  const rightKnee = keypoints[26];
  const leftAnkle = keypoints[27];
  const rightAnkle = keypoints[28];
  let kneeTotal = 0;
  let kneeCount = 0;

  // Left leg: Ideal ~175-185° (slight bend ok)
  if (valid(leftHip) && valid(leftKnee) && valid(leftAnkle)) {
    const leftAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
    const leftDev = Math.abs(180 - leftAngle) / 90;  // Normalize 0-1
    kneeTotal += 100 - (leftDev * 100);
    kneeCount++;
  }

  // Right leg
  if (valid(rightHip) && valid(rightKnee) && valid(rightAnkle)) {
    const rightAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
    const rightDev = Math.abs(180 - rightAngle) / 90;
    kneeTotal += 100 - (rightDev * 100);
    kneeCount++;
  }

  if (kneeCount > 0) {
    total += kneeTotal / kneeCount;
    count++;
  }

  const final = count > 0 ? Math.round(total / count) : 50;
  return Math.max(40, Math.min(100, final));  // Clamp 40-100
};

const SFX = {
    play: (freq, type, dur) => {
        try {
            // Only create context if allowed. 
            // We'll manage the context globally or just catch the error and do nothing.
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;

            const ctx = new AudioContext();
            if (ctx.state === 'suspended') {
                // Try to resume, but catch if it fails (user interaction needed)
                ctx.resume().catch(() => { });
            }
            if (ctx.state !== 'running') return; // Silent fail if still suspended

            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, ctx.currentTime);
            g.gain.setValueAtTime(0.1, ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
            osc.connect(g);
            g.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + dur);
        } catch (e) { console.log("Audio blocked"); }
    },
    scan: () => SFX.play(150, 'sawtooth', 0.8),
    success: () => {
        SFX.play(440, 'sine', 0.2);
        setTimeout(() => SFX.play(880, 'sine', 0.4), 100);
    }
};

// --- ICONS ---
const Icons = {
    Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12h14" /><path d="M12 5v14" /></svg>,
    Check: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 6 9 17l-5-5" /></svg>,
    Scan: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2" /><path d="M17 3h2a2 2 0 0 1 2 2v2" /><path d="M21 17v2a2 2 0 0 1-2 2h-2" /><path d="M7 21H5a2 2 0 0 1-2-2v-2" /><circle cx="12" cy="12" r="1" /><path d="M5 12h2" /><path d="M17 12h2" /><path d="M12 5v2" /><path d="M12 17v2" /></svg>,
    Video: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 7l-7 5 7 5V7z" /><rect x="1" y="5" width="15" height="14" rx="2" ry="2" /></svg>,
    Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3" /></svg>,
    Pause: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
    List: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="8" y1="6" x2="21" y2="6" /><line x1="8" y1="12" x2="21" y2="12" /><line x1="8" y1="18" x2="21" y2="18" /><line x1="3" y1="6" x2="3.01" y2="6" /><line x1="3" y1="12" x2="3.01" y2="12" /><line x1="3" y1="18" x2="3.01" y2="18" /></svg>,
    Close: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18" /><path d="M6 6 18 18" /></svg>,
    Print: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 6 2 18 2 18 9" /><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" /><rect x="6" y="14" width="12" height="8" /></svg>,
    History: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></svg>,
    Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /></svg>,
    Speaker: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" /></svg>,
    Info: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><line x1="12" y1="16" x2="12" y2="12" /><line x1="12" y1="8" x2="12.01" y2="8" /></svg>,
    Book: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20" /><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z" /></svg>,
    Sun: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="4" /><path d="M12 2v2" /><path d="M12 20v2" /><path d="m4.93 4.93 1.41 1.41" /><path d="m17.66 17.66 1.41 1.41" /><path d="M2 12h2" /><path d="M20 12h2" /><path d="m6.34 17.66-1.41 1.41" /><path d="m19.07 4.93-1.41 1.41" /></svg>,
    Moon: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" /></svg>,
    Award: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="8" r="7" /><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88" /></svg>,
    Send: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13" /><polygon points="22 2 15 22 11 13 2 9 22 2" /></svg>,
    Layers: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2" /><polyline points="2 17 12 22 22 17" /><polyline points="2 12 12 17 22 12" /></svg>,
    ArrowUp: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="19" x2="12" y2="5" /><polyline points="5 12 12 5 19 12" /></svg>,
    ArrowDown: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19" /><polyline points="19 12 12 19 5 12" /></svg>,
    Share: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3" /><circle cx="6" cy="12" r="3" /><circle cx="18" cy="19" r="3" /><line x1="8.59" y1="13.51" x2="15.42" y2="17.49" /><line x1="15.41" y1="6.51" x2="8.59" y2="10.49" /></svg>,
    Music: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18V5l12-2v13" /><circle cx="6" cy="18" r="3" /><circle cx="18" cy="16" r="3" /></svg>,
    Target: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></svg>,
    Flame: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" /></svg>,
    Camera: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" /><circle cx="12" cy="13" r="4" /></svg>,
};

/**
 * THE BIOMECHANICS ACADEMY DATA STORE
 * VERSION: 3.0 (Mass Appeal / Viral Optimized)
 * AUTHOR: [Your Name/Brand]
 * NOTE: Text is optimized for 6th-grade reading level comprehension but PhD-level value.
 */

const ACADEMY = [
    {
        id: "biotensegrity-mastery",
        title: "Biotensegrity",
        subtitle: "You Are A Tent, Not A House",
        author: "Tensegrity Collective",
        readTime: "8 min", // Optimized time
        difficulty: "Mind-Bending",
        desc: "Stop thinking of your skeleton like a stack of bricks. You're not a building held up by walls. You're a high-tech camping tent held up by tension. Your bones are the poles; your fascia is the fabric. Understanding this changes why you have pain: it's rarely the pole's fault; it's usually the rope's fault.",
        cover_image: "tensegrity_structure_01.jpg",
        sections: [
            { 
                head: "The Skyscraper Lie", 
                body: "Doctors treat you like a skyscraper: bones stacked on bones, fighting gravity. By this logic, gravity always wins, and your joints are destined to crush. The good news is this is completely wrong. You're a 'Bio-Tensegrity' structure: your bones actually float inside your soft tissue. You don't stand up because your bones are strong; you stand up because your tension network is balanced." 
            },
            { 
                head: "Floating Compression", 
                body: "Imagine a bicycle wheel. The hub floats in the middle, suspended by the spokes. Your bones are the hub. Your muscles and fascia are the spokes. If the spokes get loose, the wheel warps. You don't fix the rim; you tighten the spokes. Arthritis isn't 'wear and tear' from bones rubbing; it's a failure of your suspension system allowing the bones to touch." 
            },
            { 
                head: "The Spider Web Effect", 
                body: "It's important to understand that you're one single piece of material. If you pull on a spider web, the whole thing moves. Your body is the same. Tightness in your foot can cause a headache because the web transmits the force all the way up. We stop chasing the pain and start treating the whole web. Local treatment for global problems never works." 
            },
            { 
                head: "Free Energy (The Bounce)", 
                body: "A tent that's pulled tight is bouncy. A tent that's loose is floppy. When your fascia is tight and hydrated (pre-stressed), you bounce when you walk. You get energy for free. When you're sedentary, you lose this tension. You become a floppy tent. Now you have to use sheer muscle force just to stand up. That's why you're always tired." 
            },
            { 
                head: "Unbreakable Resilience", 
                body: "Drop a glass vase; it shatters. Drop a basketball; it bounces. Rigid things break. Elastic things survive. Tensegrity spreads the force of a fall across the whole body instantly. To become unbreakable, stop training to be a stiff rock and start training to be a bouncy ball." 
            },
            {
                head: "Cellular Magic",
                body: "This goes deep. Even your cells are mini-tensegrity structures. When you move your body often enough, you're literally signaling it to repair and grow. Your posture and movement are actively shaping how your body expresses itself."
            }
        ],
        myth_busting: [
            "MYTH: Your bones hold you up. TRUTH: Your fascia holds you up; bones just push back.",
            "MYTH: Joint pain is inevitable with age. TRUTH: Joint pain is a failure of tension, not age.",
            "MYTH: Stiffness is stability. TRUTH: Stiffness is fragility. Elasticity is stability."
        ],
        protocols: [
            "Fascial bouncing (Jump rope/hopping)",
            "Hanging (Re-tension the torso)",
            "Slow eccentric loading (Lengthen the web)"
        ],
        key_terms: ["Biotensegrity", "Continuous Tension", "Floating Compression", "Global Dampening", "Pre-Stress State", "Mechanotransduction"],
        color: "from-indigo-600 to-purple-600"
    },
    {
        id: "fascial-ocean",
        title: "The Fascial Ocean",
        subtitle: "The Fuzz That Fixes You",
        author: "Soft-Matter Physics Division",
        readTime: "10 min",
        difficulty: "Essentials",
        desc: "For decades, anatomy books cut the white 'fuzz' off the muscles and threw it away. We now know that was a big mistake. That fuzz is Fascia, and it's the most important system in your body. It's a liquid web that connects everything to everything. If it dries out, you get stiff. If it flows, you look and feel young.",
        cover_image: "fascia_microscope_02.jpg",
        sections: [
            { 
                head: "You Are Like Oobleck", 
                body: "Remember the cornstarch and water experiment? Punch it, and it's a solid brick. Move slow, and it flows like liquid. Your tissue is the same. Science calls it 'Viscoelastic.' If you move violently, your body hardens to protect you. If you move rhythmically, it melts. You can't force your body to relax; you have to coax it." 
            },
            { 
                head: "The Sixth Sense", 
                body: "You have more sensory nerves in your fascia than your eyes or ears. It tells your brain where you are in space. Chronic pain is often just 'Sensory Amnesia'—your brain lost the WiFi signal to that part of your back because the fascia got glued down. We don't just stretch; we reconnect the WiFi." 
            },
            { 
                head: "The Body Armor", 
                body: "Stress makes you stiff. Why? Because fascia can contract on its own. If you're stressed, your fascia tightens up to build 'armor' around your organs. That's why you can't just stretch away stress-knots, you have to convince your nervous system that you're safe, so the armor can melt." 
            },
            { 
                head: "The Slide and Glide", 
                body: "Inside you, muscles need to slide past each other like wet soap. The lubricant is Hyaluronic Acid. When you sit all day, this lubricant turns into glue. You get 'stiff.' The only way to turn the glue back into oil is heat and movement. Passive stretching doesn't work; you need to move to melt the glue." 
            },
            { 
                head: "Everything is Connected", 
                body: "There's no such thing as an 'isolated' muscle. Your lats pull on your glutes. Your quads pull on your hamstrings. 40% of the force you generate is passed sideways to other muscles. Bodybuilding lied to you. You can't train parts; you can only train the whole system." 
            }
        ],
        myth_busting: [
            "MYTH: You can isolate a muscle. TRUTH: Impossible. Everything pulls on everything.",
            "MYTH: Fascia is just packing material. TRUTH: It is your second nervous system.",
            "MYTH: Drinking water hydrates you. TRUTH: Movement drives water into tissue. No move = No hydrate."
        ],
        protocols: [
            "Skin rolling (Manual therapy)",
            "Shaking and bouncing (Remodeling)",
            "Hydration + Movement timing"
        ],
        key_terms: ["Viscoelasticity", "Thixotropy", "Piezoelectricity", "Hyaluronic Acid", "Lateral Force Transmission", "Myofibroblasts"],
        color: "from-teal-600 to-cyan-600"
    },
    {
        id: "rotation-master-key",
        title: "The Forgotten Plane",
        subtitle: "Life Is A Spiral, Not A Line",
        author: "Biomechanics 101",
        readTime: "9 min",
        difficulty: "Beginner",
        desc: "Gyms train you like a robot: up, down, forward, back. But look at a pitcher throwing a ball or a boxer throwing a punch. They twist. Human power comes from Rotation (The Transverse Plane). If you can't twist, you can't move. You are a walking spiral.",
        cover_image: "spiral_spine_03.jpg",
        sections: [
            { 
                head: "Robots vs. Humans", 
                body: "Squats and lunges are great, but they're also linear. They're robot movements. Humans are built to spiral. Every step you take is a twist: left leg forward, right arm forward. This wrings out your torso like a wet towel, storing energy. If you lose this twist, walking becomes heavy and hard." 
            },
            { 
                head: "The Core Lie", 
                body: "Stop doing crunches. Your core isn't designed to flex you forward, it's designed to control rotation. The muscles around your waist are a corset, meant to transfer power from your hips to your shoulders. A six-pack usually means a stiff, useless back. A strong core is a rotational core." 
            },
            { 
                head: "Save Your Lower Back", 
                body: "Here's the secret to back pain: Your lower back (Lumbar) isn't supposed to twist much. Your mid-back (Thoracic) is. But because we sit at desks, our mid-backs turn into cement. So, when you turn, your lower back has to do the work, and it snaps. Mobilize the mid-back, and the low back pain vanishes." 
            },
            { 
                head: "The Spiral Engine", 
                body: "When you walk, you counter-rotate. Shoulders go one way, hips go the other. This stretches the elastic bands across your body. When those bands snap back, they fling you forward. This is the 'Spiral Engine.' If you're stiff, the engine's off, and you have to drag your body using pure muscle." 
            },
            { 
                head: "Training the X", 
                body: "Draw an X across your body. Left shoulder to Right hip. Right shoulder to Left hip. This is how you're wired. You need to train diagonal movements—chops, throws, swings. Training with two feet glued to the floor is not athletic. Train the X to unlock your athleticism." 
            }
        ],
        myth_busting: [
            "MYTH: Sit-ups give you abs. TRUTH: Rotational work gives you a functional core.",
            "MYTH: Don't twist your spine. TRUTH: If you don't twist your mid-back, your low back breaks.",
            "MYTH: Walking is just legs. TRUTH: Walking is a spinal twist powered by the arms."
        ],
        protocols: [
            "Seated Thoracic Rotations",
            "Landmine Rotations",
            "Pallof Press (Anti-Rotation)",
            "Clubbell/Mace Flow"
        ],
        key_terms: ["Transverse Plane", "Thoracic Mobility", "Lumbar Stability", "Spiral Engine", "Counter-Rotation", "X-Pattern"],
        color: "from-purple-600 to-pink-600"
    },
    {
        id: "elastic-recoil",
        title: "Elastic Recoil",
        subtitle: "How To Move For Free",
        author: "Plyometric Underground",
        readTime: "9 min",
        difficulty: "Elite",
        desc: "Muscles are expensive gas-guzzlers. Tendons are free electric batteries. The difference between an average mover and an elite athlete isn't muscle size, it's how well they use their springs. You need to stop muscling through life and start bouncing.",
        cover_image: "achilles_tendon_04.jpg",
        sections: [
            { 
                head: "The Kangaroo Effect", 
                body: "A kangaroo hops at 40mph but burns less energy than you do walking. How? It has massive tendons. It lands, stretches the spring, and shoots forward on recoil. Humans have this too (Achilles tendon), but we ruined it with cushiony shoes and sitting. We turned our springs into mush." 
            },
            { 
                head: "The Rubber Band Rule", 
                body: "Pull a rubber band back and let go. Snap. That is 'Elastic Recoil.' But if you hold the rubber band stretched for too long, it loses power. This is the rule: you have to be quick off the ground. If you spend too much time on the floor, you lose the free energy. We train to be quick, not just strong." 
            },
            { 
                head: "Stiffness = Speed", 
                body: "In the gym, being stiff is bad. In sprinting, being stiff is good. You want your tendons to be like steel springs, not loose noodles. A stiff tendon returns energy instantly. We want soft muscles (to relax) and stiff tendons (to fly). That's the 'Pop' you see in pro athletes." 
            },
            { 
                head: "Don't Muscle It", 
                body: "Your nerves can't fire your muscles fast enough to sprint at top speed. It's biologically impossible. You have to rely on the bounce. Trying 'harder' actually makes you slower because you tense up and kill the bounce. The secret to speed is relaxation." 
            },
            { 
                head: "Rhythm is King", 
                body: "To use elasticity, you need rhythm. Skipping, hopping, dancing—these train the timing of the bounce. Gym culture treats the body like a forklift (lift heavy thing). Athletic culture treats the body like a pogo stick. You need more pogo." 
            }
        ],
        myth_busting: [
            "MYTH: Soft shoes save your knees. TRUTH: Soft shoes kill your natural springs and make you weak.",
            "MYTH: Lifting heavy makes you fast. TRUTH: Only if you convert that strength into bounce.",
            "MYTH: Plyometrics hurt joints. TRUTH: Weak tissues hurt joints. Plyometrics build tissue."
        ],
        protocols: [
            "Pogo Hops (Bounce like a bunny)",
            "Depth Drops (Learn to land)",
            "Sprinting (The ultimate plyometric)",
            "Skipping rope"
        ],
        key_terms: ["Stretch-Shortening Cycle", "Tendon Stiffness", "Metabolic Efficiency", "Amortization Phase", "Reactive Power", "Rate Coding"],
        color: "from-orange-600 to-red-600"
    },
    {
        id: "coiling-core",
        title: "Coiling the Spring",
        subtitle: "The Secret of Punching Hard",
        author: "WeckMethod + Rethinking Rotation",
        readTime: "11 min",
        difficulty: "Advanced",
        desc: "Look at a Greek statue. It's twisted. Look at a bodybuilder. He's square. The 'Coil' is the secret to generating massive force without looking like you are trying. It's about winding up your body like a clock spring before you strike.",
        cover_image: "discus_thrower_05.jpg",
        sections: [
            { 
                head: "Bracing vs. Coiling", 
                body: "They told you to 'brace your core' like you're about to get punched in the gut. That's fine for lifting a heavy rock. It's terrible for moving. 'Coiling' is different. It's side-bending and twisting to shorten one side of your body. This winds you up. A braced core is a wall; a coiled core is a loaded weapon." 
            },
            { 
                head: "Head Over Foot", 
                body: "If you want to be unpushable, put your head directly over your foot. This aligns your entire skeleton. When your head, hip, and foot align, your glutes turn on automatically. If your head is in the middle, you're weak. Watch an NFL running back cut, his head is always over the driving foot." 
            },
            { 
                head: "The Royal Coil", 
                body: "Try this: rotate your elbow down and in towards your opposite hip. Feel that connection in your abs? That's the Royal Coil. It connects your shoulder to your hip, locking your core tight without holding your breath. This is how you punch with your whole body weight." 
            },
            { 
                head: "Wring the Towel", 
                body: "Your bones are spiraled. Your muscles are spiraled. To generate power, you have to 'wring the towel.' Coiling compresses the body's spiral, storing torque. When you uncoil, that torque releases explosively. Don't push weight; release energy." 
            },
            { 
                head: "Curving is Strength", 
                body: "We're told to keep a flat back. But the spine is a curve. Coiling leans into the natural curves of the body. Don't be afraid to side-bend. Side-bending is how we load the hips. A straight spine is a slow spine." 
            }
        ],
        myth_busting: [
            "MYTH: Keep a neutral spine. TRUTH: Athletes constantly side-bend and twist.",
            "MYTH: Keep shoulders level. TRUTH: Shoulders must tilt to drive the hips.",
            "MYTH: Balance is staying in the middle. TRUTH: Balance is shifting completely over one leg."
        ],
        protocols: [
            "Coiling Core Lunges",
            "The Double Down Pulse",
            "Rotational Kettlebell Swings",
            "Rope Flow"
        ],
        key_terms: ["Coiling Core", "Head Over Foot", "Serape Effect", "Torsion Loading", "Spiral Dynamics", "WeckMethod"],
        color: "from-red-600 to-orange-600"
    },
    {
        id: "kinetic-slings",
        title: "The Slings Are Everything",
        subtitle: "Muscles Don't Work Alone",
        author: "Decentralized Movement Collective",
        readTime: "12 min",
        difficulty: "Intermediate",
        desc: "Your brain doesn't know what a 'bicep' is. It only knows movement. To move, your body uses long chains of muscles called 'Slings.' If you train individual muscles, you break the chain. If you train the slings, you become a machine.",
        cover_image: "anatomy_slings_06.jpg",
        sections: [
            { 
                head: "The Powerhouse Sling (POS)", 
                body: "This connects your Lat (back muscle) to your opposite Glute (butt muscle). This is the engine of human movement. It forms a giant 'X' on your back. When you walk, run, or throw, this X tightens to shoot you forward. If your glute is weak, your shoulder hurts. It's all connected." 
            },
            { 
                head: "The Brake System (AOS)", 
                body: "This connects your Obliques (abs) to your opposite inner thigh. This sling stops you from twisting too far. It's your braking system. If you play sports and change direction, this is what keeps your pelvis from exploding. Groin pain is usually a weak brake system." 
            },
            { 
                head: "The Shock Absorber (DLS)", 
                body: "There is a line that runs from your head all the way to your foot. It catches you when you land. Tight hamstrings? It's usually not the muscle; it's this whole line being tight because your back is stiff. Stretching the hamstring is like pulling on a slack rope—useless. You have to treat the whole chain." 
            },
            { 
                head: "The Stabilizer (Lateral Sling)", 
                body: "This keeps you from falling over when you stand on one leg. If your hip drops when you walk (the sexy model walk), this sling is broken. That hip drop destroys knees and lower backs. This is the cure for 'Runner's Knee'—strengthen the side of your hip." 
            },
            { 
                head: "Hug the Joint", 
                body: "Muscles have a job: squeeze the joints tight so they don't wiggle. This is called 'Force Closure.' If your slings are weak, the joint gets loose, and your ligaments have to do the heavy lifting. That causes pain. Squeeze the joint with the sling, and the pain is gone." 
            }
        ],
        myth_busting: [
            "MYTH: Hamstrings are just leg muscles. TRUTH: Hamstrings are part of a back-to-foot chain.",
            "MYTH: Inner thighs are useless. TRUTH: Inner thighs stabilize your abs.",
            "MYTH: Treat the site of pain. TRUTH: The pain is rarely where the problem is."
        ],
        protocols: [
            "Bird-Dogs (Train the X)",
            "Side Planks (Train the Lateral Sling)",
            "Single-Leg Deadlifts (Train the Chain)",
            "Suitcase Carries"
        ],
        key_terms: ["Posterior Oblique Sling", "Anterior Oblique Sling", "Deep Longitudinal Sling", "Lateral Sling", "Force Closure", "Trendelenburg Gait"],
        color: "from-blue-600 to-cyan-500"
    },
    {
        id: "foot-battery",
        title: "The Foot Is the Battery",
        subtitle: "Fix Your Feet, Fix Your Life",
        author: "Chong Xie + Barefoot Supremacy",
        readTime: "10 min",
        difficulty: "Intermediate",
        desc: "Your foot is an engineering masterpiece designed to adapt to any terrain. Modern shoes are coffins that bind your feet and make them stupid. Reclaiming your feet is the single best thing you can do for your body. Switching to barefoot shoes is a great place to start",
        cover_image: "barefoot_mechanics_07.jpg",
        sections: [
            { 
                head: "The Arch Lever", 
                body: "Lift your big toe. Notice how your arch rises? That's the 'Windlass Mechanism.' It turns your floppy foot into a stiff lever so you can push off. Stiff shoes prevent your toe from bending, killing this mechanism. If your big toe is stuck, your glutes can't fire." 
            },
            { 
                head: "The Hyperarch", 
                body: "Elite athletes have feet that look like hands—they can grab the ground. They actively squeeze their arch to create a super-stable base. A flat foot is a signal to the brain that says 'UNSTABLE.' The brain responds by shutting down power. A strong arch is a green light for speed." 
            },
            { 
                head: "Feet Are Sensors", 
                body: "Your feet are supposed to feel everything. The ground texture, the temperature, the slope. Thick foam soles blind your feet. If your brain can't feel the ground, it panics and stiffens your whole body. Walking on grass or sand wakes up the brain instantly." 
            },
            { 
                head: "Heels Are Not For Landing", 
                body: "Your heel is a kickstand, not a landing pad. If you slam your heel into the ground, the shockwave goes right into your knee and shin. You are designed to land mid-foot, using your arch and calf to absorb the shock. Learn to walk silently." 
            },
            { 
                head: "Spread 'Em", 
                body: "Your toes should be wider than the ball of your foot. Modern shoes crush toes into a point. This ruins your balance (think of a tripod). Spread your toes to create a wide base. If you can't spread your toes, you can't balance." 
            }
        ],
        myth_busting: [
            "MYTH: You need arch support. TRUTH: Arch support weakens feet like a neck brace weakens necks.",
            "MYTH: Flat feet are genetic. TRUTH: Most flat feet are just weak feet.",
            "MYTH: Running ruins knees. TRUTH: Heel striking ruins knees."
        ],
        protocols: [
            "Toe Spacers (Undo the damage)",
            "Short-foot exercises (Build the arch)",
            "Barefoot walking",
            "Single-leg balance (Eyes closed)"
        ],
        key_terms: ["Windlass Mechanism", "Hyperarch", "Sensory Density", "Heel Suspension", "Toe Splay", "Grounding"],
        color: "from-emerald-600 to-green-500"
    },
    {
        id: "breath-master-switch",
        title: "Breath Is the Master Switch",
        subtitle: "The Remote Control For Your Brain",
        author: "Breath Work Division",
        readTime: "12 min",
        difficulty: "Beginner",
        desc: "You take 25,000 breaths a day. If you breathe wrong, you're stressing your body 25,000 times a day. Breath isn't just about air; it's the master switch for your nervous system and the stability of your spine.",
        cover_image: "diaphragm_anatomy_08.jpg",
        sections: [
            { 
                head: "The Soda Can Core", 
                body: "Think of your torso as a soda can. If the can is pressurized, you can stand on it. If it's empty, it crushes. When you breathe into your belly (diaphragm), you pressurize the can. This protects your spine from the inside. Chest breathing leaves the can empty and the spine vulnerable." 
            },
            { 
                head: "Breathe 360 Degrees", 
                body: "Don't just breathe into your belly; breathe into your back and sides too. Most people breathe up into their shoulders (stress breathing). This tightens your neck. Good breathing expands the ribs horizontally. Watch a baby breathe; they're the masters." 
            },
            { 
                head: "The Oxygen Paradox", 
                body: "Here's the crazy part: breathing MORE air gives you LESS oxygen. You need CO2 in your blood to release the oxygen to your muscles (Bohr Effect). Mouth breathing dumps all your CO2. Paradoxically, breathing less (through your nose) oxygenates you better. Shut your mouth to save your life." 
            },
            { 
                head: "The Stress Toggle", 
                body: "Chest breathing tells your brain 'DANGER.' Belly breathing tells your brain 'SAFE.' You can literally trick your body into relaxing by changing how you breathe. Long exhales slow your heart rate instantly. You are in control of your anxiety." 
            },
            { 
                head: "The Pelvic Piston", 
                body: "Your diaphragm and your pelvic floor move together like a piston. When you inhale, they go down. When you exhale, they come up. If you constantly suck in your gut for vanity, you break this piston. Let your belly go. A relaxed belly means a healthy back." 
            }
        ],
        myth_busting: [
            "MYTH: Take a deep breath means chest up. TRUTH: A deep breath is low and slow.",
            "MYTH: CO2 is bad. TRUTH: You need CO2 to get oxygen.",
            "MYTH: Suck in your gut. TRUTH: Sucking in destroys your core function."
        ],
        protocols: [
            "Mouth Taping at night (The game changer)",
            "Box Breathing (Calm down)",
            "Balloon Breathing (Reset the ribs)",
            "CO2 tolerance tables"
        ],
        key_terms: ["Intra-Abdominal Pressure", "Horizontal Breathing", "Bohr Effect", "Parasympathetic Tone", "Diaphragm-Pelvic Piston", "Cellular Hypoxia"],
        color: "from-cyan-600 to-blue-500"
    },
    {
        id: "knees-over-toes",
        title: "Knees Over Toes Revolution",
        subtitle: "How To Bulletproof Your Knees",
        author: "Ben Patrick + Decentralized Synthesis",
        readTime: "10 min",
        difficulty: "Intermediate",
        desc: "They lied to you. They said 'never let your knees pass your toes.' That advice created a generation of weak, fragile knees. Your knees are designed to bend. You need to train them in that position to make them unbreakable.",
        cover_image: "deep_squat_09.jpg",
        sections: [
            { 
                head: "The Teardrop Muscle", 
                body: "Look at your inner knee. There should be a teardrop-shaped muscle there (VMO). This is your knee protector. It ONLY works when your knee is fully bent (over your toes). If you only do shallow squats, this muscle dies. Wake it up to fix knee pain." 
            },
            { 
                head: "Motion is Lotion", 
                body: "Your joints don't have blood pumps. They rely on movement to suck nutrients in. Squeezing the knee deep (compression) pumps fresh fluid into the cartilage. Avoiding deep movement starves the joint. You have to use it or lose it." 
            },
            { 
                head: "The Shin Shock Absorber", 
                body: "The muscle on the front of your shin (Tibialis) is your first line of defense. It absorbs the shock of every step. No one trains this muscle. If it's weak, the shock goes right to your knee. Start raising your toes against weight and watch your knee pain vanish." 
            },
            { 
                head: "Pain is a Signal", 
                body: "Don't push through pain, but don't fear it. Pain just means 'not yet.' Scale the movement back until it doesn't hurt, then build up. Regress to progress. You can heal almost anything if you start small enough." 
            },
            { 
                head: "Walking Backwards", 
                body: "This is the magic bullet. Walking backwards reverses the pressure on your knees. It pumps healing blood into the joint while strengthening the muscles safely. 10 minutes of backward walking a day is better than surgery." 
            }
        ],
        myth_busting: [
            "MYTH: Knees over toes is dangerous. TRUTH: Avoiding it makes you fragile. You do it every time you use stairs.",
            "MYTH: Deep squats are bad. TRUTH: Weak knees hate deep squats. Strong knees love them.",
            "MYTH: Rest heals tendonitis. TRUTH: Load heals tendonitis. Rest makes it weaker."
        ],
        protocols: [
            "Backward Sled Pulls (The cure)",
            "Tibialis Raises",
            "ATG Split Squats",
            "Nordic Curls"
        ],
        key_terms: ["Knees Over Toes", "VMO Activation", "Tibialis Strength", "Imbibition", "Reverse Walking", "Structural Tolerance"],
        color: "from-amber-500 to-orange-500"
    },
    {
        id: "spinal-wave",
        title: "Marv's Wave",
        subtitle: "Be Water, My Friend",
        author: "Marv Marinovich Legacy",
        readTime: "11 min",
        difficulty: "Advanced",
        desc: "A rigid spine is an old spine. Athletes like Marv Marinovich knew that the secret to speed was having a spine that moved like a snake, not a stick. The 'Spinal Wave' unlocks your nervous system and makes you move like a predator.",
        cover_image: "spinal_wave_10.jpg",
        sections: [
            { 
                head: "The Reptile Brain", 
                body: "Deep down, your movement is reptilian. Fish swim by waving their spine. Lizards walk by waving their spine. Humans suppress this. We try to be stiff. But your spinal cord loves rhythm. Waving the spine unlocks natural, effortless movement patterns." 
            },
            { 
                head: "Move in High Definition", 
                body: "Most people move like Lego blocks—stiff and clunky. Elite movers have 'high definition' control. They can move one vertebrae at a time. This is called Disassociation. If you can move your hips without moving your shoulders, you have mastery. Complexity is speed." 
            },
            { 
                head: "Melt the Glue", 
                body: "Heavy lifting compresses the spine. It mashes the discs down. The Spinal Wave reverses this. It opens the spaces, rehydrates the discs, and breaks up the micro-scar tissue. It makes you feel young again. You are only as old as your spine is stiff." 
            },
            { 
                head: "Flush the Brain", 
                body: "Your brain floats in fluid. Waving your spine acts like a pump, circulating this fluid to wash your brain. It literally clears out the metabolic trash. If you have brain fog, don't drink coffee—wave your spine." 
            },
            { 
                head: "Be The Whip", 
                body: "A punch isn't a push; it's a whip. The energy starts in the foot, ripples through a loose spine, and snaps at the hand. If your spine is stiff, the energy gets stuck. If you are loose, you amplify the power. Be the whip, not the stick." 
            }
        ],
        myth_busting: [
            "MYTH: The spine should be straight. TRUTH: The spine is a snake. It needs to move.",
            "MYTH: Stability is stiffness. TRUTH: Real stability is controlled mobility.",
            "MYTH: Heavy weights are the only way. TRUTH: Rhythm and flow are just as important."
        ],
        protocols: [
            "Cat-Cow (But make it wavy)",
            "Spinal Waves (Body rolls)",
            "Hula Hoop motions",
            "Crawling (The ultimate reset)"
        ],
        key_terms: ["Spinal Wave", "Segmental Motion", "Central Pattern Generators", "Disassociation", "Cerebrospinal Pump", "Kinetic Linking"],
        color: "from-purple-600 to-indigo-600"
    },
    {
        id: "visual-driver",
        title: "The Visual Driver",
        subtitle: "Your Eyes Control Your Muscles",
        author: "Applied Neurology",
        readTime: "9 min",
        difficulty: "Advanced",
        desc: "Here is a secret: Your muscles listen to your eyes. If your eyes are staring and strained, your body will be stiff. If your eyes are relaxed and wide, your body will be fluid. You can't fix your posture if you don't fix your gaze.",
        cover_image: "eye_neurology_11.jpg",
        sections: [
            { 
                head: "Survival Mode", 
                body: "Your brain's #1 job is not to let you die. If your eyes can't focus, the brain panics. It thinks you are in danger, so it locks up your neck and back to protect the spinal cord. Bad vision often equals a stiff neck. Relax the eyes to release the neck." 
            },
            { 
                head: "Phone Face", 
                body: "Staring at a phone locks you into 'Focal Vision.' This triggers the stress response. 'Peripheral Vision' (seeing the whole room at once) triggers the relaxation response. Want to lower anxiety instantly? Go outside and look at the horizon. Expand your view." 
            },
            { 
                head: "The VOR Reflex", 
                body: "This is the reflex that keeps your eyes steady while your head moves. If this reflex is slow, your balance sucks. If your balance sucks, your hamstrings tighten up to keep you from falling. We fix hamstrings by doing eye drills. It sounds like magic, but it's neurology." 
            },
            { 
                head: "The Jaw Connection", 
                body: "Your eyes and your jaw are best friends. Strain your eyes, and you will clench your jaw. Clench your jaw, and your neck tightens. It's a chain reaction. Soften your gaze, un-clench your teeth, and feel your hips loosen up. It's all one system." 
            }
        ],
        myth_busting: [
            "MYTH: Tight hamstrings need stretching. TRUTH: They often need better balance/vision.",
            "MYTH: Vision is just seeing. TRUTH: Vision is the governor of muscle tone.",
            "MYTH: Stare at the ball. TRUTH: Watch the ball but see the field."
        ],
        protocols: [
            "Pencil Pushups (Eye heavy lifting)",
            "Head Nods while staring at a dot",
            "Peripheral walks (See the sides)",
            "Eye circles"
        ],
        key_terms: ["Vestibulo-Ocular Reflex", "Peripheral Vision", "Visual Neural Drive", "Sympathetic Gaze", "Jaw-Eye Connection", "Proprioception"],
        color: "from-pink-500 to-rose-500"
    },
    {
        id: "lymphatic-pump",
        title: "The Lymphatic Pump",
        subtitle: "Take Out The Trash",
        author: "Fluid Dynamics",
        readTime: "8 min",
        difficulty: "Beginner",
        desc: "Your body has a sewage system called the Lymphatic System. It clears out toxins and waste. But unlike blood, it doesn't have a heart to pump it. It only moves when YOU move. If you sit still, you are literally swimming in your own waste.",
        cover_image: "lymph_system_12.jpg",
        sections: [
            { 
                head: "You Are The Pump", 
                body: "Blood has the heart. Lymph has... muscle. The only way to clear inflammation and toxins is to contract your muscles and breathe deep. This squeezes the lymph tubes and pushes the trash out. Being sedentary is like letting the toilet back up. Gross, but true." 
            },
            { 
                head: "Open The Drains", 
                body: "You have drains in your neck, armpits, gut, and groin. If these are blocked (by tight clothes or bad posture), the fluid gets stuck. You get puffy, bloated, and brain-fogged. You have to physically open these drains. Massage your collarbones. Rub your gut." 
            },
            { 
                head: "Bounce to Clean", 
                body: "Bouncing is the ultimate detox. The G-force opens and closes the valves in your lymph system like a vacuum. 5 minutes on a trampoline or just bouncing on your heels cleans your cells better than any juice cleanse. This is why kids have so much energy—they never stop bouncing." 
            },
            { 
                head: "Morning Flush", 
                body: "You wake up puffy because you laid still for 8 hours. The trash piled up. The first thing you should do is drink water and move. Flush the system. Don't let that stagnant fluid sit there all day." 
            }
        ],
        myth_busting: [
            "MYTH: Recovery is sitting on the couch. TRUTH: Active recovery flushes waste.",
            "MYTH: Detox implies buying products. TRUTH: Detox implies moving your body.",
            "MYTH: Cellulite is just fat. TRUTH: It's often trapped fluid and toxins."
        ],
        protocols: [
            "Rebounding (The lymph flusher)",
            "Dry Brushing",
            "Lymphatic Massage (Neck/Armpits/Groin)",
            "Legs Up The Wall"
        ],
        key_terms: ["Lymphatic Drainage", "Muscle Pump", "Vertical Oscillation", "Cisterna Chyli", "Cellular Waste", "Detoxification"],
        color: "from-green-500 to-teal-500"
    }
];

const PRESET_PROTOCOLS = {
    "Tech Neck": ["head_loading", "chest_opener", "trap_release", "standing_pull"],
    "Rounded Shoulders": ["chest_opener", "arm_raise", "standing_pull", "body_wave"],
    "Sedentary Reset": ["body_bounce", "split_squat", "trunk_twist", "plantar_release"],
    "Hyperarch Fascia": ["plantar_release", "towel_curl", "hyperarch"],
    "Head-Loading": ["head_loading_level1", "head_loading_level2", "head_loading_level3"]


};

// --- HYPER-PERSONALIZED DATABASE (V85.0 APEX ARCHITECT) ---
const EXERCISE_DB = [
    // PHASE 1: STRUCTURAL REPAIR
    {
        id: "head_loading", title: "Cervical Alignment", target_grade: "head", pattern: "posture_reset", tissues: "Deep Spine / Multifidus", phase: 1, synergies: ["Neck Pain", "Back Pain"], equipment: "none", levels: [
            { level: 1, name: "Weighted Head Loading (Standing)", demoType: "head_loading_basic", duration: 90, desc: "Axial decompression standing tall with light weight on head.", steps: ["Balance light weight on head", "Reach arms up", "Breathe deep", "Lengthen spine"], videoSearch: "medicine ball balanced on head posture" },
            { level: 2, name: "Head-Loaded Standing Hip Hinge", demoType: "head_hinge", duration: 90, desc: "Basic axial loading with hip hinge to teach posterior chain under head load.", steps: ["Balance 5-10lb on head", "Hinge at hips, push butt back", "Keep spine neutral", "Return to stand"], videoSearch: "good morning exercise with medicine ball overhead" },
            { level: 3, name: "Head Loaded March", demoType: "head_march", duration: 60, desc: "Dynamic stability marching under axial load.", steps: ["Balance weight on head", "March slowly in place", "No wobble", "Maintain tall posture"], videoSearch: "posture head weighting marching" }
        ]
    },
    {
        id: "head_loading_level1",
        title: "Head-Loading Step 1",
        target_grade: "head",
        pattern: "posture_reset",
        tissues: "Deep Cervical Stabilizers",
        phase: 2,
        synergies: ["Neck Pain", "Forward Head"],
        equipment: "required",
        levels: [{ level: 1, name: "Standing Head Loading", demoType: "head_loading_basic", duration: 90, desc: "Basic axial loading to establish perfect spinal alignment.", steps: ["Place light weight on head", "Stand tall, arms reaching up", "Lengthen from tailbone to crown", "Deep breathing"], videoSearch: "medicine ball balanced on head posture" }]
    },
    {
        id: "head_loading_level2",
        title: "Head-Loading Step 2",
        target_grade: "head",
        pattern: "posture_reset",
        tissues: "Deep Cervical / Posterior Chain",
        phase: 2,
        synergies: ["Neck Pain", "Posture"],
        equipment: "required",
        levels: [{ level: 1, name: "Head-Loaded Hip Hinge", demoType: "head_hinge", duration: 90, desc: "Add posterior chain movement while maintaining cervical load.", steps: ["Keep weight balanced", "Hinge at hips", "Neutral spine", "Drive through heels"], videoSearch: "good morning with weight on head" }]
    },
    {
        id: "head_loading_level3",
        title: "Head-Loading Step 3",
        target_grade: "head",
        pattern: "posture_reset",
        tissues: "Full Axial Chain / VMO",
        phase: 2,
        synergies: ["Neck Pain", "Knee Pain", "Posture"],
        equipment: "required",
        levels: [{ level: 1, name: "Head-Loaded ATG Split Squat", demoType: "head_split", duration: 120, desc: "Deep unilateral range with axial loading — the ultimate posture challenge.", steps: ["Weight balanced on head", "Long stride, deep drop", "Front knee over toe", "Torso upright"], videoSearch: "head loaded atg split squat" }]
    },
    { id: "plantar_release", title: "Plantar Release", target_grade: "gait", pattern: "foot_release", tissues: "Plantar Fascia", phase: 1, synergies: ["Foot Pain", "Knee Pain", "Back Pain"], equipment: "required", levels: [{ level: 1, name: "Standing Foot Roll", demoType: "foot_roll", duration: 90, desc: "Break up fascial adhesions while loaded.", steps: ["Stand on ball", "Apply bodyweight", "Find hot spots"], videoSearch: "standing plantar fascia release golf ball" }, { level: 2, name: "Plantar Fascia Release", demoType: "foot_roll", duration: 90, desc: "Shift weight dynamically across the arch.", steps: ["Ball under arch", "Shift weight front/back", "Breathe"], videoSearch: "standing plantar fascia release technique" }, { level: 3, name: "Active Toe Splay", demoType: "foot_roll", duration: 60, desc: "Neurological reactivation.", steps: ["Stand tall", "Splay toes", "Drive big toe down", "Lift others"], videoSearch: "toe splay foot exercise" }] },
    {
        id: "meta_release", title: "Metatarsal Splay", target_grade: "gait", pattern: "foot_release", tissues: "Interosseous / Metatarsals", phase: 1, synergies: ["Foot Pain", "Narrow Toe Box"], equipment: "none", levels: [
            { level: 1, name: "Seated Metatarsal Smash", demoType: "meta_release", duration: 90, desc: "Manual release between the 1st and 2nd metatarsal bones.", steps: ["Sit down, cross leg", "Press thumb between big toe and second toe bones", "Flex and extend toes while pressing"], videoSearch: "foot mobilization metatarsal massage" },
            { level: 2, name: "Active Splay Release", demoType: "meta_release", duration: 60, desc: "Adding active splay neurological drive.", steps: ["Pin the tissue", "Actively spread toes wide", "Relax and repeat"], videoSearch: "active foot splay exercise" }
        ]
    },
    { id: "split_squat", title: "Knee Restoration", target_grade: "hip", pattern: "knee_flexion", tissues: "VMO / Hip Flexor", phase: 1, synergies: ["Knee Pain", "Back Pain", "Foot Pain"], equipment: "none", levels: [{ level: 1, name: "Assisted Split Squat", demoType: "split_squat", duration: 60, desc: "Use support to unload bodyweight.", steps: ["Hold support", "Front foot flat", "Knee over toe"], videoSearch: "atg split squat assisted form" }, { level: 2, name: "ATG Split Squat", demoType: "split_squat", duration: 60, desc: "Full range bodyweight split squat.", steps: ["Long stride", "Back leg straight", "Cover hamstring with calf"], videoSearch: "atg split squat knees over toes" }, { level: 3, name: "Headloaded Split Squat", demoType: "split_squat", duration: 60, desc: "Advanced: Axial load forces perfect spinal alignment.", steps: ["Balance up to 10lb on head", "Perform split squat and exaggerate your knees over toes", "Absolute control"], videoSearch: "ATG loaded split squat" }, { level: 4, name: "Head-Loaded ATG Split Squat", demoType: "head_split", duration: 90, desc: "Head load forces perfect alignment in deep split squat.", steps: ["Balance 5-10lb on head", "Long stride", "Deep drop, knee over toe", "Slow reps"], videoSearch: "overhead medicine ball lunge deep" }] },
    { id: "trap_release", title: "Shoulder Release", target_grade: "shoulders", pattern: "tissue_release", tissues: "Upper Traps", phase: 1, synergies: ["Neck Pain", "Headache"], equipment: "required", levels: [{ level: 1, name: "Upper Trap Smash", demoType: "shoulder_release", duration: 90, desc: "Basic release.", steps: ["Ball on wall", "Lean in", "Breathe"], videoSearch: "upper trap release lacrosse ball wall" }, { level: 2, name: "Active Trap Pin", demoType: "shoulder_release", duration: 90, desc: "Release with arm movement.", steps: ["Pin tissue", "Raise arm", "Lower arm"], videoSearch: "upper trap active release technique" }] },
    { id: "standing_pull", title: "Scapular Stability", target_grade: "shoulders", pattern: "upper_pull", priority: "secondary", tissues: "Lower Traps / Rhomboids", phase: 1, synergies: ["Neck Pain", "Posture"], equipment: "required", levels: [{ level: 1, name: "Band Pull Aparts", demoType: "standing_pull", duration: 60, desc: "Scapular retraction.", steps: ["Hold band", "Pull apart", "Squeeze blades"], videoSearch: "resistance band pull aparts form" }, { level: 2, name: "Cable Face Pulls", demoType: "standing_pull", duration: 60, desc: "External rotation and retraction.", steps: ["Pull to face", "Rotate hands up", "Squeeze"], videoSearch: "cable face pull proper form" }] },
    { id: "diaphragm_breath", title: "Diaphragmatic Integration", target_grade: "spine", pattern: "breath_flow", tissues: "Deep Front Line / Diaphragm", phase: 1, synergies: ["Back Pain", "Neck Pain", "Stiffness"], equipment: "none", levels: [{ level: 1, name: "Supine Breath Hold", demoType: "diaphragm_breath", duration: 60, desc: "Basic diaphragm activation.", steps: ["Lie flat", "Hand on belly", "Inhale deep, hold 5s"], videoSearch: "supine diaphragmatic breathing" }, { level: 2, name: "Crocodile Breath", demoType: "diaphragm_breath", duration: 90, desc: "Prone for back line integration.", steps: ["Face down", "Forehead on hands", "Belly breathe against floor"], videoSearch: "crocodile breathing exercise" }, { level: 3, name: "Integrated Breath Flow", demoType: "diaphragm_breath", duration: 120, desc: "Pair with movement.", steps: ["Inhale during elongation", "Exhale on coil", "Sync with wave"], videoSearch: "integrated diaphragmatic breathing in movement" }] },

    // PHASE 2: FASCIAL ELASTICITY
    { id: "body_bounce", title: "Fascial Bounce", target_grade: "hip", pattern: "rhythmic_loading", tissues: "Lateral Line / Glute Med", phase: 2, synergies: ["Hip Impingement", "Stiffness"], equipment: "none", levels: [{ level: 1, name: "Body Bounce w/ Hip Shift", demoType: "body_bounce", duration: 60, desc: "Rhythmic bouncing with lateral hip shifts to engage fascia.", steps: ["Bounce on balls of feet", "Shift hips left and right", "Keep rhythm"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },
    { id: "hyperarch", title: "Fascial Elasticity", target_grade: "gait", pattern: "elasticity", tissues: "Achilles / Fascia", phase: 2, synergies: ["Foot Pain", "Knee Pain"], equipment: "none", levels: [{ level: 1, name: "Pogo Hops", demoType: "hyperarch_hop", duration: 30, desc: "Build stiffness.", steps: ["Small bounces", "Legs straight", "Balls of feet"], videoSearch: "pogo hops plyometrics" }, { level: 2, name: "Hyperarch Hops", demoType: "hyperarch_hop", duration: 45, desc: "Maximal fascial loading.", steps: ["Suspend heel", "Rapid recoil", "Glute driven"], videoSearch: "hyperarch fascia training glute hops" }] },
    { id: "towel_curl", title: "HFT Towel Curls", target_grade: "gait", pattern: "foot_release", tissues: "Plantar Fascia / Intrinsic Foot", phase: 2, synergies: ["Foot Pain", "Knee Pain", "Back Pain"], equipment: "required", levels: [{ level: 1, name: "Seated Towel Curl", demoType: "towel_curl", duration: 60, desc: "Basic toe scrunch seated.", steps: ["Sit", "Towel under foot", "Scrunch toes"], videoSearch: "seated towel curl exercise" }, { level: 2, name: "Standing Towel Curl", demoType: "towel_curl", duration: 90, desc: "Add weight bearing.", steps: ["Stand", "Scrunch with full weight"], videoSearch: "standing towel curl" }, { level: 3, name: "Dynamic Towel Pull", demoType: "towel_curl", duration: 60, desc: "Pull towel towards you.", steps: ["Pull towel with toes", "Repeat"], videoSearch: "dynamic towel scrunch" }] },
    { id: "chest_opener", title: "Chest Opener", target_grade: "shoulders", pattern: "anterior_stretch", tissues: "Pectorals / Biceps", phase: 2, synergies: ["Posture", "Neck Pain"], equipment: "none", levels: [{ level: 1, name: "Dynamic Chest Opener", demoType: "chest_opener", duration: 60, desc: "Opening the front line of the body.", steps: ["Cross arms in front", "Open wide & squeeze", "Use momentum"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },
    { id: "alt_arm_raise", title: "Reciprocal Arms", target_grade: "shoulders", pattern: "coordination", tissues: "Latissimus Dorsi", phase: 2, synergies: ["Gait Efficiency", "Shoulder Pain"], equipment: "none", levels: [{ level: 1, name: "Alternate Arm Raise", demoType: "alt_arm_raise", duration: 60, desc: "Disassociating shoulder movements.", steps: ["One arm up", "One arm down", "Switch rhythmically"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },

    // PHASE 3: ROTATIONAL POWER
    { id: "pallof", title: "Core Stability", target_grade: "spine", pattern: "anti_rotation", tissues: "Oblique Sling", phase: 3, synergies: ["Back Pain", "Knee Pain"], equipment: "required", levels: [{ level: 1, name: "Pallof Hold", demoType: "pallof_press", duration: 45, desc: "Static anti-rotation hold.", steps: ["Hold band", "Arms extended", "Resist twist"], videoSearch: "pallof press hold form" }, { level: 2, name: "Pallof Press", demoType: "pallof_press", duration: 60, desc: "Dynamic press resisting rotation.", steps: ["Press out", "Return slow", "Hips square"], videoSearch: "standing pallof press tutorial" }, { level: 3, name: "Chopping Pallof", demoType: "pallof_press", duration: 60, desc: "Dynamic chopping motion.", steps: ["Rotational chop", "Explosive return", "Core brace"], videoSearch: "cable woodchopper exercise" }] },
    { id: "landmine_rotation", title: "Rotational Strength", target_grade: "spine", pattern: "anti_rotation", tissues: "Anterior Oblique Sling", phase: 3, synergies: ["Back Pain", "Gait Efficiency"], equipment: "required", levels: [{ level: 1, name: "Landmine Anti-Rotation", demoType: "landmine_rotation", duration: 45, desc: "Resisting torque.", steps: ["Bar in front", "Move arc side to side", "Hips still"], videoSearch: "landmine anti rotation rainbow" }, { level: 2, name: "Landmine Twist", demoType: "landmine_twist", duration: 60, desc: "Integrated hip and spine rotation.", steps: ["Pivot feet", "Rotate hips", "Press bar across body"], videoSearch: "full contact twist landmine" }] },
    {
        id: "ql_straddle", title: "QL Straddle Hinge", target_grade: "spine", pattern: "anti_lateral_flexion", tissues: "Quadratus Lumborum / SI Joint", phase: 3, synergies: ["Back Pain", "SI Joint Pain", "Hip Hike"], equipment: "required", levels: [
            { level: 1, name: "Suitcase Deadlift Iso", demoType: "ql_straddle", duration: 45, desc: "Isometric hold to wake up the QL.", steps: ["Wide stance", "Hold heavy weight in one hand", "Do not let torso twist or dip", "Hold tall"], videoSearch: "suitcase deadlift isometric hold" },
            { level: 2, name: "QL Straddle Hinge", demoType: "ql_straddle", duration: 60, desc: "The SI Joint fixer. Hinging while resisting rotation.", steps: ["Wide straddle stance", "Kettlebell in one hand", "Hinge hips back", "Tap weight inside leg", "Power up without twisting"], videoSearch: "single arm straddle deadlift ql" }
        ]
    },
    { id: "band_twist", title: "Band Twist", target_grade: "spine", pattern: "power_rotation", tissues: "Obliques / Transverse Plane", phase: 3, synergies: ["Back Pain", "Hip Hike"], equipment: "required", levels: [{ level: 1, name: "Standing Band Twist", demoType: "band_twist", duration: 60, desc: "Controlled rotational torque.", steps: ["Hold band", "Pivot feet", "Rotate 180 degrees"], videoSearch: "standing resistance band trunk twist" }, { level: 2, name: "Explosive Band Twist", demoType: "band_twist", duration: 60, desc: "Power development.", steps: ["Load back", "Snap hips", "Rotate hard"], videoSearch: "explosive band rotation exercise" }] },
    { id: "coiling", title: "Rotational Power", target_grade: "spine", pattern: "core_flow", tissues: "Spiral Line", phase: 3, synergies: ["Back Pain", "Gait Efficiency"], equipment: "none", levels: [{ level: 1, name: "Static Coiling Hold", demoType: "coiling_lunge", duration: 45, desc: "Learn the position.", steps: ["Lunge", "Side bend", "Align Head Over Foot"], videoSearch: "weckmethod coiling core isometric" }, { level: 2, name: "Pulsing Coiling Lunge", demoType: "weck_pulse", duration: 60, desc: "WeckMethod Rhythmic Pulse.", steps: ["Double down pulse", "Fascial elasticity", "Head over foot"], videoSearch: "weckmethod pulsing lunge tutorial" }, { level: 3, name: "Loaded Coiling", demoType: "coiling_lunge", duration: 60, desc: "Add hand weights.", steps: ["Hold DBs", "Enhance torsion", "Power return"], videoSearch: "weckmethod loaded coiling lunge" }, { level: 4, name: "Head-Loaded Coiling Lunge", demoType: "head_coiling", duration: 90, desc: "Head load amplifies coil and Head-Over-Foot.", steps: ["Balance 5-10lb on head", "Lunge + side bend/rotate", "Pulse the coil"], videoSearch: "weckmethod coiling lunge overhead" }] },
    { id: "trunk_twist", title: "Trunk Twist", target_grade: "spine", pattern: "rotation", tissues: "Spiral Line", phase: 3, synergies: ["Back Pain", "Core Stability"], equipment: "none", levels: [{ level: 1, name: "Dynamic Trunk Twist", demoType: "trunk_twist", duration: 60, desc: "Loosening the thoracic spine with rhythmic rotation.", steps: ["Feet wide", "Rotate torso", "Let arms swing loosely"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },

    // PHASE 4: INTEGRATED FLOW
    { id: "spinal_wave", title: "Integrated Spine", target_grade: "spine", pattern: "core_flow", tissues: "Full Body Fascia", phase: 4, requires_mastery: ["body_wave", "coiling"], synergies: ["Back Pain", "Neck Pain"], equipment: "none", levels: [{ level: 1, name: "Standing Spinal Roll", demoType: "spinal_wave", duration: 60, desc: "Segmental flexion/extension.", steps: ["Chin to chest", "Roll down spine", "Roll up"], videoSearch: "standing spinal roll down pilates" }, { level: 2, name: "Marinovich Spinal Wave", demoType: "spinal_wave", duration: 60, desc: "Segmental activation of the spine.", steps: ["Sit or lie over the ball so your back is supported.", "Initiate a wave from the tailbone through the spine up to the head.", "Arms can move overhead, side-to-side, or reach forward to integrate upper body."], videoSearch: "https://www.youtube.com/watch?v=H9Ai26Au5Kc&list=PLkJzahJiwLT4Qu2fl_877pWJtCJo39HI-" }] },
    { id: "body_wave", title: "Body Wave", target_grade: "spine", pattern: "spinal_flow", tissues: "Superficial Back Line", phase: 4, synergies: ["Back Pain", "Stiffness"], equipment: "none", levels: [{ level: 1, name: "Standing Body Wave", demoType: "body_wave", duration: 60, desc: "Rhythmic arm swings driving body extension.", steps: ["Swing arms back & bend knees", "Swing arms overhead & extend", "Keep rhythm"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },
    { id: "med_ball_power", title: "Explosive Power", target_grade: "spine", pattern: "power_rotation", tissues: "Full Body Fascia", phase: 4, synergies: ["Athletic Performance", "Stiffness"], equipment: "required", levels: [{ level: 1, name: "Standing Overhead Slam", demoType: "med_ball_slam", duration: 30, desc: "Full body flexion power.", steps: ["Stand tall", "Lift ball", "Slam hard"], videoSearch: "medicine ball overhead slam form" }] },
    { id: "contra_pull", title: "Contralateral Pull", target_grade: "shoulders", pattern: "reciprocal_pull", tissues: "Posterior Oblique Sling", phase: 4, synergies: ["Back Pain", "Gait Efficiency", "Shoulder Impingement"], equipment: "required", levels: [{ level: 1, name: "Static Contra Hold", demoType: "contra_pull", duration: 45, desc: "Isometric sling fire.", steps: ["Band in right hand", "Left foot steps back", "Pull & resist"], videoSearch: "contralateral band pull hold" }, { level: 2, name: "Dynamic Contra Pull", demoType: "contra_pull", duration: 60, desc: "Add movement.", steps: ["Pull band while stepping", "Alternate sides", "Keep tension"], videoSearch: "contralateral resistance band pull" }, { level: 3, name: "Explosive Contra Snap", demoType: "contra_pull", duration: 45, desc: "Power version.", steps: ["Quick pull & release", "Hip drive", "Full recoil"], videoSearch: "explosive contralateral band snap" }] },
    { id: "inversion_hang", title: "Inversion Decompression", target_grade: "hip", pattern: "inversion_flow", tissues: "Superficial Back Line", phase: 4, synergies: ["Back Pain", "Hip Impingement", "Stiffness"], equipment: "none", levels: [{ level: 1, name: "Supported Inversion Hold", demoType: "inversion_hang", duration: 30, desc: "Gentle hang.", steps: ["Hang from bar/wall", "Relax shoulders", "Breathe deep"], videoSearch: "supported inversion hang" }, { level: 2, name: "Active Inversion Twist", demoType: "inversion_hang", duration: 45, desc: "Add rotation.", steps: ["Hang & twist hips", "Alternate sides", "Control descent"], videoSearch: "inversion hang with twist" }, { level: 3, name: "Dynamic Inversion Flow", demoType: "inversion_hang", duration: 60, desc: "Full integration.", steps: ["Hang to pull-up", "Add leg swings", "Fascia release"], videoSearch: "dynamic inversion flow exercise" }] },
    { id: "arm_raise", title: "Arm Raises", target_grade: "shoulders", pattern: "shoulder_mobility", tissues: "Deep Front Arm Line", phase: 4, synergies: ["Neck Pain", "Shoulder Impingement"], equipment: "none", levels: [{ level: 1, name: "Thumbs Up Arm Raise", demoType: "arm_raise", duration: 60, desc: "Overhead range of motion with external rotation cue.", steps: ["Thumbs up", "Raise arms straight front", "Keep ribs down"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] }
    ,
// ELITE PHASE 5: UNBREAKABLE FLOWS (Premium/Score Unlock)
    {
        id: "med_ball_rotational_throw",
        title: "Rotational Power Throw",
        target_grade: "spine",
        pattern: "power_rotation",
        tissues: "Posterior Oblique Sling",
        phase: 5,
        synergies: ["Athletic Performance", "Back Pain"],
        equipment: "required",
        levels: [{
            level: 1,
            name: "Medicine Ball Rotational Wall Throw",
            demoType: "wall_throw",
            duration: 45,
            desc: "Explosive spiral line activation with full hip drive.",
            steps: ["Load coil", "Snap hips", "Release through opposite shoulder", "Catch and reset"],
            videoSearch: "medicine ball rotational wall throw"
        }]
    },
    {
        id: "inversion_twist_flow",
        title: "Inversion Spiral Flow",
        target_grade: "spine",
        pattern: "inversion_flow",
        tissues: "Deep Front Line",
        phase: 5,
        synergies: ["Back Pain", "Stiffness"],
        equipment: "required",
        levels: [{
            level: 1,
            name: "Inversion Hang + Active Twist",
            demoType: "inversion_hang",
            duration: 60,
            desc: "Advanced decompression with controlled rotation.",
            steps: ["Hang relaxed", "Initiate twist from hips", "Counter-rotate head", "Breathe deep"],
            videoSearch: "inversion hang with twist"
        }]
    },
    {
        id: "coiling_med_ball",
        title: "Coiled Medicine Ball Slam",
        target_grade: "spine",
        pattern: "power_rotation",
        tissues: "Full Body Spiral",
        phase: 5,
        synergies: ["Athletic Performance"],
        equipment: "required",
        levels: [{
            level: 1,
            name: "Coiled Overhead Slam",
            demoType: "med_ball_slam",
            duration: 40,
            desc: "Maximize torsion before explosive release.",
            steps: ["Coil torso", "Reach high", "Uncoil violently", "Drive through floor"],
            videoSearch: "medicine ball rotational slam"
        }]
    }


];

// --- NEW: GOAL PRESETS (For Retention) ---
const GOAL_PRESETS = [
    { id: "beginner", title: "Starter Build", target: 70, desc: "Build foundational posture in 30 days.", exercises: 4 },
    { id: "athlete", title: "Elite Power", target: 90, desc: "Unlock rotational power in 60 days.", exercises: 6 },
    { id: "recovery", title: "Pain Free", target: 85, desc: "Eliminate chronic pain in 45 days.", exercises: 5 }
];

// --- MISSING PART_ANALYSIS DATABASE ---
const PART_ANALYSIS = {
    head: {
        title: "Cervical Alignment",
        intro: (g, v) => `Your head score is **${g}** (${v}%). This measures Forward Head Posture (Tech Neck).`,
        rootCause: "Weak deep cervical flexors and tight sub-occipitals from screen usage.",
        fix: "Axial Decompression (Head Loading) to reflexively fire the deep neck stabilizers.",
        insight: "For every inch your head moves forward, it adds 10lbs of leverage load to your spine."
    },
    shoulders: {
        title: "Scapular Stability",
        intro: (g, v) => `Your shoulder integrity is **${g}** (${v}%). This checks for rounding and asymmetry.`,
        rootCause: "Tight pectorals pulling shoulders forward + weak lower traps/rhomboids.",
        fix: "Chest Openers + Band Pull Aparts to re-set the scapula back and down.",
        insight: "Your shoulders are not ear-muffs. Depression (dropping them) is as important as Retraction."
    },
    spine: {
        title: "Spinal Column",
        intro: (g, v) => `Your spinal metric is **${g}** (${v}%). This analyzes curvature and compression.`,
        rootCause: "Thoracic rigidity. You have lost the ability to extend and rotate the mid-back.",
        fix: "Spinal Waves + Hanging Decompression to re-hydrate vertebral discs.",
        insight: "A stiff spine blocks neural signals. A fluid spine amplifies power."
    },
    hip: {
        title: "Pelvic Girdle",
        intro: (g, v) => `Your pelvic score is **${g}** (${v}%). This looks for Anterior Tilt or Hip Hike.`,
        rootCause: "Sedentary lifestyle shortening the hip flexors and putting glutes to sleep (Glute Amnesia).",
        fix: "Deep Split Squats (ATG) to lengthen hip flexors under load.",
        insight: "The pelvis is the transmission of the body. If it's tilted, you leak power."
    },
    gait: {
        title: "Gait & Feet",
        intro: (g, v) => `Your recoil capacity is **${g}** (${v}%). This measures ankle stiffness and foot function.`,
        rootCause: "Weak foot arches and reliance on cushioned shoes (sensory deprivation).",
        fix: "Barefoot Pogo Hops + Towel Curls to wake up the plantar fascia.",
        insight: "You should bounce, not thud. Elasticity is free energy; muscle contraction is expensive."
    }
};
// --- COMPONENTS ---

/// --- OMEGA BIOMETRIC ENGINE (V92.0 - HOLOGRAPHIC HUD LAYER) ---
const BioArchitect3D = ({ landmarks, width = 600, height = 600 }) => {
    const canvasRef = useRef(null);
    const [rotation, setRotation] = useState(0);
    const [autoRotate, setAutoRotate] = useState(true);
    const [cameraMode, setCameraMode] = useState('cinematic');
    const [activeJoint, setActiveJoint] = useState(null);

    // Standard skeletal connections
    const CONNECTIONS = [
        [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], // Upper Body
        [11, 23], [12, 24], [23, 24],                     // Torso Box
        [23, 25], [25, 27], [27, 29], [29, 31], [27, 31], // Left Leg + Foot
        [24, 26], [26, 28], [28, 30], [30, 32], [28, 32]  // Right Leg + Foot
    ];

    const FACE_CONNECTIONS = [
        [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10]
    ];

    const calculate3DAngle = (p1, p2, p3) => {
        if (!p1 || !p2 || !p3) return 0;
        const v1 = { x: p1.x - p2.x, y: p1.y - p2.y, z: p1.z - p2.z };
        const v2 = { x: p3.x - p2.x, y: p3.y - p2.y, z: p3.z - p2.z };
        const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        const mag1 = Math.sqrt(v1.x ** 2 + v1.y ** 2 + v1.z ** 2);
        const mag2 = Math.sqrt(v2.x ** 2 + v2.y ** 2 + v2.z ** 2);
        const angleRad = Math.acos(dot / (mag1 * mag2));
        return (angleRad * (180 / Math.PI)).toFixed(0);
    };

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !landmarks || landmarks.length === 0) return;

        const ctx = canvas.getContext('2d');
        let animationFrameId;

        const config = {
            focalLength: 1200,
            boneColor: { r: 34, g: 211, b: 238 },
            floorAlpha: 0.08
        };

        const render = () => {
            ctx.clearRect(0, 0, width, height);

            // Medical Vignette Background
            const bgGrad = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width * 0.9);
            bgGrad.addColorStop(0, '#0f172a');
            bgGrad.addColorStop(0.6, '#020617');
            bgGrad.addColorStop(1, '#000000');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Auto-Framing
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            landmarks.forEach(lm => {
                minX = Math.min(minX, lm.x); maxX = Math.max(maxX, lm.x);
                minY = Math.min(minY, lm.y); maxY = Math.max(maxY, lm.y);
            });

            const bodyH = maxY - minY;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const targetScale = (height * 0.65) / Math.max(bodyH, 0.1);

            // Camera Physics
            let rot = rotation;
            const time = Date.now();

            if (autoRotate) {
                if (cameraMode === 'orbit') rot += time * 0.0001;
                if (cameraMode === 'cinematic') {
                    rot = Math.sin(time * 0.0002) * 0.5;
                }
            }

            const cx = width / 2;
            const cy = height / 2;

            const project = (x, y, z) => {
                const dx = x - centerX;
                const dy = y - centerY;
                const dz = (z || 0);
                const cos = Math.cos(rot), sin = Math.sin(rot);
                const rx = dx * cos - dz * sin;
                const rz = dx * sin + dz * cos;
                const depthOffset = 600;
                const scaleFactor = config.focalLength / (config.focalLength + rz * 300 + depthOffset);

                return {
                    x: cx + rx * targetScale * scaleFactor,
                    y: cy + dy * targetScale * scaleFactor,
                    z: rz,
                    s: scaleFactor * targetScale,
                    raw: { x: rx, y: dy, z: rz }
                };
            };

            const points = landmarks.map(lm => project(lm.x, lm.y, lm.z));

            // Floor & Grid
            const feetY = Math.max(points[27]?.y || 0, points[28]?.y || 0, points[31]?.y || 0, points[32]?.y || 0);
            const floorY = feetY + 30;

            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = `rgba(6, 182, 212, ${config.floorAlpha})`;
            ctx.lineWidth = 1;
            for (let i = -12; i <= 12; i++) {
                const xOffset = i * 60 * Math.cos(rot);
                const zOffset = i * 20 * Math.sin(rot);
                ctx.moveTo(cx + xOffset, cy);
                ctx.lineTo(cx + i * 200, height * 1.5);
            }
            for (let j = 0; j < 8; j++) {
                const y = floorY + Math.pow(j, 1.8) * 8;
                if (y > height) break;
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            ctx.stroke();
            ctx.restore();

            // Render Bones
            const allBones = [...CONNECTIONS, ...FACE_CONNECTIONS].map(pair => {
                const p1 = points[pair[0]];
                const p2 = points[pair[1]];
                if (!p1 || !p2) return null;
                return { p1, p2, z: (p1.z + p2.z) / 2 };
            }).filter(b => b !== null).sort((a, b) => a.z - b.z);

            allBones.forEach(bone => {
                const { p1, p2, z } = bone;
                const alpha = Math.min(1, Math.max(0.1, 1 / (1 + z * 3)));
                const thickness = Math.max(1, p1.s * 0.02);

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineCap = "round";
                ctx.strokeStyle = `rgba(${config.boneColor.r}, ${config.boneColor.g}, ${config.boneColor.b}, ${alpha * 0.3})`;
                ctx.lineWidth = thickness + 6;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = `rgba(220, 250, 255, ${alpha})`;
                ctx.lineWidth = thickness;
                ctx.stroke();
            });

            // Vitality Core (Heartbeat)
            const midChestX = (points[11].x + points[12].x) / 2;
            const midChestY = (points[11].y + points[12].y) / 2 + 20;
            const beat = Math.sin(time * 0.008) * 0.5 + 0.5;
            const heartSize = 40 * points[11].s * 0.01;

            ctx.beginPath();
            const gradH = ctx.createRadialGradient(midChestX, midChestY, 0, midChestX, midChestY, heartSize * (1 + beat * 0.5));
            gradH.addColorStop(0, `rgba(244, 63, 94, ${0.4 + beat * 0.2})`);
            gradH.addColorStop(1, "rgba(244, 63, 94, 0)");
            ctx.fillStyle = gradH;
            ctx.arc(midChestX, midChestY, heartSize * 2, 0, Math.PI * 2);
            ctx.fill();

            // Plumb Line
            const nose = points[0];
            if (nose) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(nose.x, nose.y);
                ctx.lineTo(nose.x, floorY);
                ctx.strokeStyle = "rgba(244, 63, 94, 0.5)";
                ctx.setLineDash([4, 6]);
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(nose.x, floorY, 15, 5, 0, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(244, 63, 94, 0.3)";
                ctx.fill();
                ctx.restore();
            }

            // --- V92 HOLOGRAPHIC LABEL RENDERER ---
            const drawEnhancedLabel = (p, title, subtitle, type = 'alert', align = 'right') => {
                if (!p) return;
                const isAlert = type === 'alert';
                const primaryColor = isAlert ? "#ef4444" : "#22d3ee"; // Red or Cyan
                const borderColor = isAlert ? "rgba(239, 68, 68, 0.6)" : "rgba(34, 211, 238, 0.6)";
                const bgColor = isAlert ? "rgba(20, 10, 10, 0.95)" : "rgba(10, 20, 25, 0.95)"; // Deep opaque background

                // Positioning calculations - push labels further away for clarity
                const xBaseOffset = align === 'right' ? 80 : -80;
                const yBaseOffset = -50;
                const labelX = p.x + xBaseOffset;
                const labelY = p.y + yBaseOffset;
                const elbowX = p.x + xBaseOffset * 0.4;

                ctx.save();
                // 1. Draw Connector Line (Elbow style with dots)
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(elbowX, labelY); // Angle point
                ctx.lineTo(labelX, labelY); // End point
                ctx.strokeStyle = primaryColor;
                ctx.lineWidth = 1;
                ctx.setLineDash([]); // Ensure solid line
                ctx.stroke();

                // Anchor Dots
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = primaryColor;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(labelX, labelY, 3, 0, Math.PI * 2);
                ctx.fill();


                // 2. Draw Label Container Box
                ctx.font = "bold 12px monospace"; // Bolder font for metrics
                const titleMetrics = ctx.measureText(title);
                const boxWidth = Math.max(titleMetrics.width + 30, 120);
                const boxHeight = 36;
                const boxX = align === 'right' ? labelX : labelX - boxWidth;
                const boxY = labelY - boxHeight / 2;

                // Box Shadow for depth
                ctx.shadowColor = primaryColor;
                ctx.shadowBlur = 15;
                
                // Box Background & Border
                ctx.fillStyle = bgColor;
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                // Check if roundRect is supported, fallback to rect if not
                if (ctx.roundRect) {
                    ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 4);
                } else {
                    ctx.rect(boxX, boxY, boxWidth, boxHeight);
                }
                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0; // Reset shadow for text

                // 3. Draw Text Content
                ctx.textAlign = align === 'right' ? 'left' : 'right';
                const textX = align === 'right' ? boxX + 15 : boxX + boxWidth - 15;
                
                // Title
                ctx.fillStyle = primaryColor;
                ctx.fillText(title, textX, boxY + 14);

                // Subtitle
                if (subtitle) {
                    ctx.font = "10px monospace";
                    ctx.fillStyle = "#94a3b8"; // Distinct Slate color for subtitle
                    ctx.fillText(subtitle, textX, boxY + 28);
                }
                ctx.restore();
            };

            // 8. RENDER JOINTS & DIAGNOSTICS
            points.forEach((p, i) => {
                // Filter out some intermediate joints for cleaner look
                if (i > 0 && i < 11 && i % 2 !== 0 && i !== 0) return;

                const size = Math.max(3, p.s * 0.015);
                const isHovered = activeJoint === i;

                // Joint Orb
                const jGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);
                jGrad.addColorStop(0, "white");
                jGrad.addColorStop(0.3, isHovered ? "#f43f5e" : (i < 11 ? "#22d3ee" : "#3b82f6"));
                jGrad.addColorStop(1, "rgba(0,0,0,0)");
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * (isHovered ? 2 : 1), 0, Math.PI * 2);
                ctx.fillStyle = jGrad;
                ctx.fill();

                // --- STRESS ZONES & LABELS ---
                const depthStress = Math.abs(p.raw.z);

                // Only draw red rings if significant deviation
                if (depthStress > 0.15 && i > 10) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size + (depthStress * 50), 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(239, 68, 68, ${depthStress * 2})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // --- V92 LABEL APPLICATION LOGIC (Prevents Stacking) ---
            // We only trigger labels on specific representative joints, not clusters.
            
            // Head
            if (Math.abs(points[0].raw.z) > 0.15) {
                 drawEnhancedLabel(points[0], "AXIAL DRIFT", "Forward Head Posture", "alert", "right");
            }
            
            // Shoulders (Check one side based on max stress)
            const leftShoulderStress = Math.abs(points[11].raw.z);
            const rightShoulderStress = Math.abs(points[12].raw.z);
            if (leftShoulderStress > 0.15 || rightShoulderStress > 0.15) {
                const target = leftShoulderStress > rightShoulderStress ? points[11] : points[12];
                const align = leftShoulderStress > rightShoulderStress ? "left" : "right";
                drawEnhancedLabel(target, "TORSION SHEAR", "Upper Body Rotation", "alert", align);
            }

             // Hips
            if (Math.abs(points[23].raw.z) > 0.15 || Math.abs(points[24].raw.z) > 0.15) {
                 drawEnhancedLabel(points[24], "PELVIC TILT", "Load Imbalance Detected", "alert", "right");
            }

            // Feet/Ankles - FIX FOR STACKING IN SCREENSHOT
            // Instead of checking all foot points, we check representative anchors (27=left ankle, 28=right ankle)
            if (Math.abs(points[27].raw.z) > 0.2) {
                 drawEnhancedLabel(points[27], "ASYMMETRY L", "Depth Mismatch (Left)", "alert", "left");
            }
             if (Math.abs(points[28].raw.z) > 0.2) {
                 drawEnhancedLabel(points[28], "ASYMMETRY R", "Depth Mismatch (Right)", "alert", "right");
            }


            // 9. LIVE ANGLE TAGS (Improved visibility)
            if (points[23] && points[25] && points[27]) {
                const ang = calculate3DAngle(points[23].raw, points[25].raw, points[27].raw);
                const pos = points[25];
                // Darker, cleaner box for angles
                ctx.fillStyle = "rgba(15, 23, 42, 0.95)";
                ctx.strokeStyle = "#22d3ee";
                ctx.lineWidth = 1;
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(pos.x + 20, pos.y - 12, 50, 24, 4);
                } else {
                    ctx.rect(pos.x + 20, pos.y - 12, 50, 24);
                }
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = "#22d3ee";
                ctx.textAlign = "center";
                ctx.font = "bold 13px monospace";
                ctx.fillText(`${ang}°`, pos.x + 45, pos.y + 5);
            }

            if (autoRotate) {
                animationFrameId = requestAnimationFrame(render);
            }
        };

        render();
        return () => cancelAnimationFrame(animationFrameId);

    }, [landmarks, rotation, autoRotate, width, height, cameraMode, activeJoint]);

    return (
        <div className="relative w-full h-full bg-slate-950 rounded-xl overflow-hidden border border-slate-700 shadow-2xl group">

            {/* OMEGA HUD LAYER - UNCHANGED */}
            <div className="absolute top-0 left-0 w-full h-full pointer-events-none p-6 flex flex-col justify-between z-20">
                <div className="flex justify-between items-start">
                    <div>
                        <div className="text-[10px] font-black text-cyan-400 uppercase tracking-[0.2em] flex items-center gap-2 mb-1">
                            <div className="w-2 h-2 bg-cyan-400 rounded-full animate-pulse shadow-[0_0_10px_#22d3ee]"></div>
                            OMEGA DIAGNOSTICS v92
                        </div>
                        <div className="text-[9px] text-slate-400 font-mono">
                            VOLUMETRIC PROJECTION: <span className="text-white">ACTIVE</span>
                        </div>
                    </div>
                    <div className="text-right">
                        <div className="text-[9px] font-bold text-slate-500 uppercase tracking-wider mb-1">AXIAL ROTATION</div>
                        <div className="text-lg font-mono text-cyan-400">{(rotation * (180 / Math.PI) % 360).toFixed(0)}°</div>
                    </div>
                </div>

                <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[300px] h-[300px] border border-white/5 rounded-full flex items-center justify-center pointer-events-none">
                    <div className="w-[280px] h-[280px] border border-cyan-500/10 rounded-full animate-pulse-slow"></div>
                    <div className="absolute top-0 bottom-0 w-px bg-cyan-500/10"></div>
                    <div className="absolute left-0 right-0 h-px bg-cyan-500/10"></div>
                </div>

                <div className="flex justify-center pointer-events-auto">
                    <div className="bg-slate-900/90 backdrop-blur-md border border-cyan-900/50 p-1 rounded-full flex gap-1 shadow-2xl transform translate-y-4 group-hover:translate-y-0 transition-transform duration-300">
                        {['orbit', 'follow', 'cinematic'].map(mode => (
                            <button
                                key={mode}
                                onClick={() => { setCameraMode(mode); setAutoRotate(true); }}
                                className={`px-4 py-2 rounded-full text-[10px] font-bold uppercase transition-all ${cameraMode === mode
                                        ? 'bg-cyan-600 text-white shadow-lg shadow-cyan-500/30'
                                        : 'text-slate-400 hover:text-white hover:bg-slate-800'
                                    }`}
                            >
                                {mode}
                            </button>
                        ))}
                    </div>
                </div>
            </div>

            {/* Clinical Sidebar (Right) - UNCHANGED */}
            <div className="absolute top-20 right-4 w-36 space-y-2 pointer-events-none z-10">
                <div className="bg-slate-900/80 backdrop-blur border border-red-900/50 p-3 rounded-lg text-right shadow-xl">
                    <div className="text-[9px] text-slate-400 uppercase tracking-wider mb-1">Stress Zones</div>
                    <div className="text-sm font-black text-red-400">DETECTED</div>
                    <div className="h-1 w-full bg-slate-800 mt-2 rounded-full overflow-hidden">
                        <div className="h-full bg-red-500 w-[75%] animate-pulse"></div>
                    </div>
                </div>
            </div>

            <canvas
                ref={canvasRef}
                width={width}
                height={height}
                className="w-full h-full cursor-move relative z-10"
                onMouseDown={() => setAutoRotate(false)}
                onMouseMove={(e) => {
                    if (e.buttons === 1) setRotation(prev => prev + e.movementX * 0.01);
                }}
                onTouchStart={() => setAutoRotate(false)}
                onTouchMove={(e) => {
                    const touch = e.touches[0];
                    setRotation(prev => prev + (touch.clientX % 2) * 0.02);
                }}
            />

            <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.25)_50%),linear-gradient(90deg,rgba(255,0,0,0.06),rgba(0,255,0,0.02),rgba(0,0,255,0.06))] z-20 bg-[length:100%_2px,3px_100%] opacity-20"></div>
        </div>
    );
};

const BioAvatar = ({ audit, symptoms = [], onPartClick }) => {
    const [tappedPart, setTappedPart] = useState(null);
    const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
    const avatarRef = useRef(null);

    const handlePartClick = (e, part) => {
        if (navigator.vibrate) navigator.vibrate(50);
        SFX.play(800, 'sine', 0.1);
        setTappedPart(part);
        const rect = avatarRef.current.getBoundingClientRect();
        const clickX = e.clientX || e.touches?.[0]?.clientX || rect.left + rect.width / 2;
        const clickY = e.clientY || e.touches?.[0]?.clientY || rect.top + rect.height / 2;
        setTooltipPos({ x: clickX, y: clickY });
        if (onPartClick) onPartClick(part);
        setTimeout(() => setTappedPart(null), 800);
    };

    const getColor = (grade) => {
        switch (grade) {
            case 'A': return "fill-emerald-500/20 stroke-emerald-500 hover:fill-emerald-500/40";
            case 'B': return "fill-blue-500/20 stroke-blue-500 hover:fill-blue-500/40";
            case 'C': return "fill-yellow-500/20 stroke-yellow-500 hover:fill-yellow-500/40";
            case 'D': return "fill-orange-500/20 stroke-orange-500 hover:fill-orange-500/40";
            case 'F': return "fill-red-600/40 stroke-red-600 hover:fill-red-600/60 animate-pulse shadow-2xl shadow-red-900/70";
            default: return "fill-slate-700 stroke-slate-600";
        }
    };

    const getFill = (part, gradeObj) => {
        const grade = gradeObj?.grade || 'F';
        const isBad = grade === 'F' || grade === 'D';
        const isPain =
            (part === 'head' && symptoms.includes('Neck Pain')) ||
            (part === 'spine' && symptoms.includes('Back Pain')) ||
            (part === 'hip' && (symptoms.includes('Back Pain') || symptoms.includes('Knee Pain'))) ||
            (part === 'gait' && (symptoms.includes('Knee Pain') || symptoms.includes('Foot Pain')));

        if (isPain || isBad) {
            return "fill-red-600/50 stroke-red-500 animate-pulse shadow-2xl shadow-red-900/70 hover:fill-red-600/80 hover:scale-110 cursor-pointer transition-all duration-300";
        }
        const baseColor = getColor(grade);
        return `${baseColor} hover:brightness-150 hover:scale-108 cursor-pointer transition-all duration-300`;
    };

    const headC = getFill('head', audit ? audit.head : { grade: 'F' });
    const shC = getFill('shoulders', audit ? audit.shoulders : { grade: 'F' });
    const spineC = getFill('spine', audit ? audit.spine : { grade: 'F' });
    const hipC = getFill('hip', audit ? audit.hip : { grade: 'F' });
    const legC = getFill('gait', audit ? audit.gait : { grade: 'F' });

    return (
        <div ref={avatarRef} className="relative w-full h-auto mx-auto">
            <svg viewBox="0 0 200 480" className="w-full h-auto mx-auto drop-shadow-2xl animate-pulse-slow living-avatar">
                <g onClick={(e) => handlePartClick(e, 'gait')} onTouchStart={(e) => handlePartClick(e, 'gait')} className={`body-part ${legC} ${tappedPart === 'gait' ? 'tapped' : ''}`}>
                    <path strokeWidth="2" d="M70,220 Q60,300 65,380 L85,380 Q90,300 95,220 Z" />
                    <path strokeWidth="2" d="M130,220 Q140,300 135,380 L115,380 Q110,300 105,220 Z" />
                </g>
                <g onClick={(e) => handlePartClick(e, 'hip')} onTouchStart={(e) => handlePartClick(e, 'hip')} className={`body-part ${hipC} ${tappedPart === 'hip' ? 'tapped' : ''}`}>
                    <path strokeWidth="2" d="M60,180 Q50,200 60,220 L140,220 Q150,200 140,180 Z" />
                </g>
                <g onClick={(e) => handlePartClick(e, 'spine')} onTouchStart={(e) => handlePartClick(e, 'spine')} className={`body-part ${spineC} ${tappedPart === 'spine' ? 'tapped' : ''}`}>
                    <path strokeWidth="2" d="M65,100 L135,100 L140,180 L60,180 Z" />
                </g>
                <g onClick={(e) => handlePartClick(e, 'shoulders')} onTouchStart={(e) => handlePartClick(e, 'shoulders')} className={`body-part ${shC} ${tappedPart === 'shoulders' ? 'tapped' : ''}`}>
                    <path strokeWidth="2" d="M40,100 Q30,150 25,200 L45,200 Q50,150 65,110 Z" />
                    <path strokeWidth="2" d="M160,100 Q170,150 175,200 L155,200 Q150,150 135,110 Z" />
                    <ellipse cx="100" cy="100" rx="40" ry="10" />
                </g>
                <g onClick={(e) => handlePartClick(e, 'head')} onTouchStart={(e) => handlePartClick(e, 'head')} className={`body-part ${headC} ${tappedPart === 'head' ? 'tapped' : ''}`}>
                    <circle cx="100" cy="60" r="25" strokeWidth="2" />
                </g>
                <line x1="0" y1="380" x2="200" y2="380" stroke="#22d3ee" strokeWidth="1" strokeOpacity="0.3" strokeDasharray="4 4" />
                <line x1="100" y1="0" x2="100" y2="400" stroke="#22d3ee" strokeWidth="1" strokeOpacity="0.2" strokeDasharray="4 4" />
            </svg>

            {tappedPart && (
                <div className="part-tooltip fixed" style={{ left: `${tooltipPos.x}px`, top: `${tooltipPos.y}px`, transform: 'translate(-50%, -120%)' }}>
                    <div className="text-cyan-400 text-xs uppercase tracking-wider mb-1">{tappedPart.toUpperCase()}</div>
                    <div className="text-2xl font-black text-white">{audit?.[tappedPart]?.grade || '?'}</div>
                    <div className="text-xs text-cyan-300">{audit?.[tappedPart]?.val || '--'}% Integrity</div>
                </div>
            )}
        </div>
    );
};

const ExerciseGifOverlay = ({ demoType }) => {
    const gifs = {
        split_squat: 'https://i.pinimg.com/originals/4e/1b/3b/4e1b3b8e6d0f3b0e8d8f0b0e8d8f0b0e.gif', // Real ATG knees-over-toes demo
        pallof_press: 'https://gymvisual.com/wp-content/uploads/2451-band-horizontal-pallof-press.gif', // Perfect anti-rotation pallof
        foot_roll: 'https://example.com/plantar-golf-ball-roll.gif', // Placeholder - we'll fix later if needed
        plantar_release: 'https://example.com/plantar-golf-ball-roll.gif',
    };

    const src = gifs[demoType];
    if (!src || src.includes('example.com')) return null;

    return (
        <img 
            src={src} 
            alt="Exercise demonstration" 
            className="absolute inset-0 w-full h-full object-contain pointer-events-none rounded-lg"
            style={{ mixBlendMode: 'screen', opacity: 0.9 }}
        />
    );
};

const AICoach = ({ audit, symptoms, chatHistory, onSend, onAction }) => {
    const [input, setInput] = useState("");
    const [isThinking, setIsThinking] = useState(false); // NEW: Visual Thought Process
    const messagesEndRef = useRef(null);

    // Auto-scroll to bottom
    useEffect(() => { 
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }, [chatHistory, isThinking]);

    const handleSend = async (txt) => {
        const msg = txt || input;
        if (!msg.trim()) return;
        
        // Trigger UI updates
        setInput("");
        setIsThinking(true); // Start "Thinking" animation
        
        // Process
        await onSend(msg);
        
        setIsThinking(false); // Stop animation
    };

    const suggestions = [
        "Analysis Report",
        "Fix my Neck Pain",
        "Why Head Loading?",
        "Generate Power Routine",
        "Show Anatomy Class"
    ];

    return (
        <div className="flex flex-col h-full bg-slate-900/80 backdrop-blur-xl rounded-2xl border border-slate-700 overflow-hidden shadow-2xl relative">
            
            {/* Header with "Live" Status */}
            <div className="p-4 bg-slate-950 border-b border-slate-800 flex justify-between items-center shadow-md z-10">
                <div className="flex items-center gap-3">
                    <div className="relative">
                        <div className="w-3 h-3 rounded-full bg-emerald-500 animate-ping absolute inset-0 opacity-75"></div>
                        <div className="w-3 h-3 rounded-full bg-emerald-500 relative z-10 border-2 border-slate-900"></div>
                    </div>
                    <div>
                        <div className="text-xs font-black text-white uppercase tracking-widest leading-none">Pocket Coach</div>
                        <div className="text-[9px] text-cyan-400 font-mono mt-0.5">NEURAL LINK: ACTIVE</div>
                    </div>
                </div>
            </div>

            {/* Chat Area */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4 scroll-smooth">
                {chatHistory.length === 0 ? (
                    <div className="h-full flex flex-col items-center justify-center opacity-60">
                        <Icons.Scan className="w-12 h-12 text-slate-600 mb-4" />
                        <p className="text-sm text-slate-400 font-medium text-center">
                            Neural Core Ready.<br/>Awaiting Input.
                        </p>
                    </div>
                ) : (
                    chatHistory.map((msg, i) => (
                        <div key={i} className={`flex flex-col ${msg.sender === 'user' ? 'items-end' : 'items-start'} animate-popIn`}>
                            
                            {/* Message Bubble */}
                            <div className={`
                                relative max-w-[85%] px-4 py-3 rounded-2xl text-xs sm:text-sm leading-relaxed shadow-sm
                                ${msg.sender === 'user' 
                                    ? 'bg-gradient-to-br from-cyan-600 to-blue-700 text-white rounded-tr-sm' 
                                    : 'bg-slate-800 border border-slate-700 text-slate-200 rounded-tl-sm shadow-inner'
                                }
                            `}>
                                {/* Markdown-like bolding support */}
                                <div dangerouslySetInnerHTML={{ __html: msg.text.replace(/\*\*(.*?)\*\*/g, '<strong class="text-cyan-300 font-black">$1</strong>').replace(/\n/g, '<br/>') }} />
                                
                                {/* 🚀 NEW: ACTION BUTTONS IN CHAT */}
                                {msg.action && (
                                    <button 
                                        onClick={() => onAction(msg.action)}
                                        className="mt-3 w-full py-2 bg-slate-950 hover:bg-black border border-cyan-500/30 hover:border-cyan-400 rounded-lg flex items-center justify-center gap-2 text-xs font-bold text-cyan-400 transition-all group"
                                    >
                                        <span>{msg.action.label}</span>
                                        <span className="group-hover:translate-x-1 transition-transform">→</span>
                                    </button>
                                )}
                            </div>

                            {/* Timestamp / Label */}
                            <span className="text-[9px] text-slate-600 mt-1 px-1 font-mono uppercase">
                                {msg.sender === 'user' ? 'You' : 'Biometric AI'}
                            </span>
                        </div>
                    ))
                )}
                
                {/* Thinking Indicator */}
                {isThinking && (
                    <div className="flex items-center gap-2 px-4 py-3 bg-slate-800/50 rounded-2xl rounded-tl-sm w-fit animate-pulse">
                        <div className="w-1.5 h-1.5 bg-cyan-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                        <div className="w-1.5 h-1.5 bg-cyan-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                        <div className="w-1.5 h-1.5 bg-cyan-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>

            {/* Quick Chips */}
            <div className="px-4 pb-2 flex gap-2 overflow-x-auto no-scrollbar mask-linear-fade">
                {suggestions.map(s => (
                    <button key={s} onClick={() => handleSend(s)} className="whitespace-nowrap px-3 py-1.5 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-cyan-500/50 rounded-full text-[10px] font-bold text-slate-400 hover:text-cyan-300 transition-all shadow-lg flex-shrink-0">
                        {s}
                    </button>
                ))}
            </div>

            {/* Input Area */}
            <div className="p-3 bg-slate-950 border-t border-slate-800 flex gap-2">
                <input
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => { 
    if (e.key === 'Enter') { 
        e.preventDefault(); 
        handleSend(); 
    } 
}}
                    placeholder="Ask about pain, mechanics, or nutrition..."
                    className="flex-1 bg-slate-900 border border-slate-700 rounded-xl px-4 py-3 text-xs text-white focus:outline-none focus:border-cyan-500 focus:ring-1 focus:ring-cyan-500/50 transition-all placeholder:text-slate-600"
                />
                <button 
                    onClick={() => handleSend()} 
                    disabled={!input.trim() || isThinking}
                    className="p-3 bg-gradient-to-br from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 text-white rounded-xl shadow-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                >
                    <Icons.Send />
                </button>
            </div>
        </div>
    );
};

// --- KINETIC CANVAS ENGINE ---
const KineticCanvas = ({ type, playing }) => {
    const ref = useRef(null);
    const animationRef = useRef(null);

    useEffect(() => {
        const canvas = ref.current;
        if (animationRef.current) cancelAnimationFrame(animationRef.current);
        if (!canvas) return;

        const ctx = canvas.getContext('2d', { alpha: false });
        const dpr = window.devicePixelRatio || 1;

        // Mutable variables that update when screen resizes
        let w, h, cx, cy, s;
        let offscreen, offCtx;

        const handleResize = () => {
            const rect = canvas.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) return;

            // 1. Resize Canvas Buffer
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            // 2. Update Physics Variables (The Fix)
            w = rect.width;
            h = rect.height;
            cx = w / 2;
            cy = h / 2;
            s = h / 350; // <--- This now updates instantly when layout opens!

            // 3. Re-draw Grid
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            offscreen = document.createElement('canvas');
            offscreen.width = w * dpr;
            offscreen.height = h * dpr;
            offCtx = offscreen.getContext('2d');
            offCtx.scale(dpr, dpr);
            offCtx.strokeStyle = '#1e293b'; 
            offCtx.lineWidth = 1; 
            offCtx.beginPath();
            for (let i = 0; i < w; i += 40) { offCtx.moveTo(i, 0); offCtx.lineTo(i, h); }
            for (let i = 0; i < h; i += 40) { offCtx.moveTo(0, i); offCtx.lineTo(w, i); }
            offCtx.stroke();
        };

        // Attach the listener
        const observer = new ResizeObserver(handleResize);
        observer.observe(canvas);
        let startTime = Date.now();
        let lastFrameTime = 0;  // NEW: Tracks last draw time
        const targetFPS = 30;  // NEW: Cap at 30 (smooth, low CPU)
        const frameInterval = 1000 / targetFPS;  // NEW: ~33ms between frames

        const loop = (currentTime) => {  // CHANGED: Now accepts timestamp param
            if (!ref.current) return;

            const delta = currentTime - lastFrameTime;  // NEW: Time since last frame
            if (delta < frameInterval) {  // NEW: Skip if too soon (throttle)
                animationRef.current = requestAnimationFrame(loop);
                return;
            }
            lastFrameTime = currentTime;  // NEW: Update timestamp

            try {
                ctx.clearRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'source-over'; // Faster blending
                ctx.imageSmoothingEnabled = false; // Crisp, low-cost pixels
                ctx.drawImage(offscreen, 0, 0, w * dpr, h * dpr, 0, 0, w, h);  // Scaled blit: physical src → logical dest
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, cy + 100 * s, w, h - (cy + 100 * s));
                ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, cy + 100 * s); ctx.lineTo(w, cy + 100 * s); ctx.stroke();

                const t = (Date.now() - startTime) / 1000;
                const cycle = Math.sin(t * 2.5); const pos = (cycle + 1) / 2;
                const safe = (v) => Number.isFinite(v) ? v : 0;

                const drawSegment = (x1, y1, x2, y2, w, c = '#94a3b8') => { ctx.save(); ctx.strokeStyle = c; ctx.lineWidth = w; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(safe(x1), safe(y1)); ctx.lineTo(safe(x2), safe(y2)); ctx.stroke(); ctx.restore(); };
                const drawMuscle = (x1, y1, x2, y2, w, act, lbl, sd = 'right') => {
                    const dx = x2 - x1, dy = y2 - y1, len = Math.sqrt(dx * dx + dy * dy); if (len < 1) return;
                    const mx = (x1 + x2) / 2, my = (y1 + y2) / 2, nx = -dy / len, ny = dx / len;
                    const bx = mx + nx * w * (act ? 0.6 : 0.3) * (sd === 'right' ? 1 : -1), by = my + ny * w * (act ? 0.6 : 0.3) * (sd === 'right' ? 1 : -1);
                    ctx.save(); ctx.strokeStyle = act ? '#22d3ee' : '#475569'; ctx.lineWidth = 2; ctx.fillStyle = act ? 'rgba(34,211,238,0.3)' : 'rgba(71,85,105,0.2)';
                    ctx.beginPath(); ctx.moveTo(safe(x1), safe(y1)); ctx.quadraticCurveTo(safe(bx), safe(by), safe(x2), safe(y2)); ctx.fill(); ctx.stroke(); ctx.restore();
                };
                const drawEquipment = (tp, x, y, rt) => {
                    ctx.save(); ctx.translate(safe(x), safe(y)); ctx.rotate(rt);
                    if (tp === 'ball') { ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(0, 0, 8 * s, 0, 2 * Math.PI); ctx.fill(); }
                    else if (tp === 'smash_ball') { ctx.fillStyle = '#f43f5e'; ctx.beginPath(); ctx.arc(0, 0, 5 * s, 0, 2 * Math.PI); ctx.fill(); }
                    else if (tp === 'bar') { ctx.strokeStyle = '#64748b'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(60 * s, 0); ctx.stroke(); }
                    else if (tp === 'swiss') { ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(0, 0, 25 * s, 0, 2 * Math.PI); ctx.fill(); }
                    else if (tp === 'sled') { ctx.fillStyle = '#475569'; ctx.fillRect(-20 * s, -10 * s, 40 * s, 20 * s); }
                    else if (tp === 'dumbbell') { ctx.fillStyle = '#334155'; ctx.fillRect(-10 * s, -5 * s, 20 * s, 10 * s); ctx.fillRect(-15 * s, -8 * s, 5 * s, 16 * s); ctx.fillRect(10 * s, -8 * s, 5 * s, 16 * s); }
                    else if (tp === 'plate') { ctx.fillStyle = '#1e293b'; ctx.beginPath(); ctx.ellipse(0, 0, 15 * s, 15 * s, 0, 0, 2 * Math.PI); ctx.fill(); ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2; ctx.stroke(); }
                    else if (tp === 'handle') { ctx.fillStyle = '#334155'; ctx.fillRect(-5 * s, -15 * s, 10 * s, 30 * s); }
                    else if (tp === 'towel') { ctx.fillStyle = '#e2e8f0'; ctx.fillRect(-30 * s, 0, 60 * s, 3 * s); ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1; ctx.strokeRect(-30 * s, 0, 60 * s, 3 * s); }
                    else if (tp === 'pullup_bar') { ctx.strokeStyle = '#64748b'; ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(-50 * s, 0); ctx.lineTo(50 * s, 0); ctx.stroke(); ctx.fillStyle = '#475569'; ctx.fillRect(-5 * s, -5 * s, 10 * s, 10 * s); } // Grip
                    ctx.restore();
                };

                const drawForce = (x, y, dirX, dirY, lbl) => {
                    const scale = 40 * s;
                    ctx.save(); ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3; ctx.setLineDash([2, 2]);
                    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + dirX * scale, y + dirY * scale); ctx.stroke();
                    ctx.translate(x + dirX * scale, y + dirY * scale); ctx.rotate(Math.atan2(dirY, dirX));
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-5 * s, -5 * s); ctx.lineTo(-5 * s, 5 * s); ctx.fill();
                    ctx.restore();
                    ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 9px monospace'; ctx.fillText(lbl, x + dirX * scale + 5, y + dirY * scale);
                };

                // Easing function for smoother animations
                const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                // --- SCENES ---
                if (type === 'split_squat') {
                    const phase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                    const lunge = phase * 20 * s;
                    const footY = cy + 80 * s;
                    const kneeY = cy + 20 * s + lunge;
                    const hipY = cy - 20 * s + lunge;
                    const backFootX = cx - 60 * s;

                    // Back leg
                    drawSegment(cx, hipY, backFootX + 20 * s, cy + 40 * s + lunge / 2, 16 * s, '#475569');
                    drawSegment(backFootX + 20 * s, cy + 40 * s + lunge / 2, backFootX, footY, 10 * s, '#475569');

                    // Front leg - knee over toe
                    const frontFootX = cx + 40 * s;
                    const frontKneeX = frontFootX + 20 * s;
                    drawSegment(cx, hipY, frontKneeX, kneeY, 16 * s, '#22d3ee');
                    drawSegment(frontKneeX, kneeY, frontFootX, footY, 16 * s, '#22d3ee');

                    // Torso upright
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // VMO glow when deep
                    if (phase > 0.6) {
                        drawMuscle(frontKneeX + 5 * s, kneeY, frontKneeX + 10 * s, kneeY + 20 * s, 14 * s, true, "VMO", 'right');
                    }

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("ATG SPLIT SQUAT", 20, 20);

                    ctx.fillStyle = '#22d3ee';
                    ctx.font = `bold ${12 * s}px sans-serif`;
                    ctx.fillText("KNEE OVER TOE = VMO ACTIVATION", 20, 45);

                    if (phase > 0.7) {
                        ctx.fillStyle = '#f59e0b';
                        ctx.font = `bold ${11 * s}px sans-serif`;
                        ctx.fillText("DEEP FLEXION BUILDS BULLETPROOF KNEE", 20, h - 30);
                    }
                }
                else if (type === 'body_bounce') {
                    // REFINED: Based on video - bouncing w/ significant hip rotation
                    const bouncePhase = easeInOutCubic(Math.abs(Math.sin(t * 6)) / 2 + 0.5); // Smoother fast bounce
                    const bounce = bouncePhase * 8 * s;
                    const shiftPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const shift = shiftPhase * 15 * s;
                    const twistPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const twist = twistPhase * 0.4;

                    const hipX = cx + shift;
                    const hipY = cy + 20 * s - bounce;
                    const footY = cy + 100 * s;
                    const headY = hipY - 70 * s;

                    // Legs slanted due to shift with knee bend for realism
                    const leftKneeY = hipY + (footY - hipY) * 0.5 + Math.sin(t * 6) * 2 * s; // Slight knee flex
                    const leftKneeX = cx - 15 * s + (hipX - (cx - 5 * s)) * 0.5;
                    ctx.beginPath(); ctx.moveTo(cx - 15 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, hipX - 5 * s, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                    const rightKneeY = hipY + (footY - hipY) * 0.5 - Math.sin(t * 6) * 2 * s; // Opposite flex
                    const rightKneeX = cx + 15 * s + (hipX - (cx + 5 * s)) * 0.5;
                    ctx.beginPath(); ctx.moveTo(cx + 15 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, hipX + 5 * s, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();

                    // Torso with slight rotation cue and curve for spine
                    ctx.save();
                    ctx.translate(hipX, hipY);
                    ctx.rotate(twist); // Twist the hips
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * Math.sin(t * 2), -35 * s, 0, -70 * s); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke(); // Curved torso
                    ctx.restore();

                    // Head with slight tilt
                    ctx.beginPath(); ctx.arc(hipX + twist * 5 * s, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Arms relaxed, loose with elbow bend
                    const armBounce = easeInOutCubic((Math.sin(t * 6 + Math.PI) + 1) / 2) * 5 * s;
                    const leftElbowX = hipX - 20 * s - 10 * s * Math.sin(t * 2); const leftElbowY = headY + 10 * s + armBounce / 2;
                    ctx.beginPath(); ctx.moveTo(hipX - 20 * s, headY + 10 * s); ctx.quadraticCurveTo(leftElbowX, leftElbowY, hipX - 35 * s, headY + 40 * s + armBounce); ctx.strokeStyle = '#475569'; ctx.lineWidth = 6 * s; ctx.stroke();
                    const rightElbowX = hipX + 20 * s + 10 * s * Math.sin(t * 2); const rightElbowY = headY + 10 * s - armBounce / 2;
                    ctx.beginPath(); ctx.moveTo(hipX + 20 * s, headY + 10 * s); ctx.quadraticCurveTo(rightElbowX, rightElbowY, hipX + 35 * s, headY + 40 * s + armBounce); ctx.strokeStyle = '#475569'; ctx.lineWidth = 6 * s; ctx.stroke();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("FASCIAL BOUNCE W/ HIP TWIST", 20, 30);
                    drawForce(hipX, hipY, shift > 0 ? 1 : -1, 0, "SHIFT & TWIST");
                    // Actionable cue: Pulsing shift arrow
                    if (shiftPhase > 0.7) {
                        ctx.save(); ctx.globalAlpha = 0.6 + Math.sin(t * 10) * 0.4;
                        drawForce(hipX, hipY, shift > 0 ? 1 : -1, 0, "SHIFT");
                        ctx.restore();
                    }
                }
                else if (type === 'body_wave') {
                    // REFINED: Skier Swing Style - Standing arm swing w/ knee bend
                    // Video shows standing in place, swinging arms down/back (knees bend) then up/overhead (knees straight)
                    const wavePhase = t * 4;
                    const cycle = easeInOutCubic((Math.sin(wavePhase) + 1) / 2); // Smoother cycle

                    // Body posture linked to arm swing
                    // Cycle 0: Arms Back, Knees Bent (Skier Tuck)
                    // Cycle 1: Arms Up, Body Extended

                    const kneeBend = cycle * 15 * s; // Inverted for bend when arms back
                    const trunkLean = cycle * 10 * s; // Lean forward when arms back

                    const hipY = cy + 20 * s + kneeBend;
                    const footY = cy + 100 * s;
                    const headX = cx + trunkLean;
                    const headY = hipY - 70 * s + trunkLean / 2; // Head drops slightly

                    // Legs with knee joints
                    const leftKneeY = hipY + (footY - hipY) * 0.5 - kneeBend / 2; // Bend at knee
                    const leftKneeX = cx - 15 * s + trunkLean / 4;
                    ctx.beginPath(); ctx.moveTo(cx - 15 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, cx, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                    const rightKneeY = hipY + (footY - hipY) * 0.5 + kneeBend / 2; // Slight offset
                    const rightKneeX = cx + 15 * s + trunkLean / 4;
                    ctx.beginPath(); ctx.moveTo(cx + 15 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, cx, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();

                    // Torso with curve
                    const midTorsoX = cx + trunkLean / 2; const midTorsoY = hipY - 35 * s;
                    ctx.beginPath(); ctx.moveTo(cx, hipY); ctx.quadraticCurveTo(midTorsoX, midTorsoY, headX, headY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();

                    // Head
                    ctx.beginPath(); ctx.arc(headX, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Arms: Swing from Overhead to Behind Hips with elbow bend
                    // Angle -PI (up) to 0.5*PI (back)
                    const armAngle = -Math.PI / 2 - (cycle * Math.PI * 0.7); // Dynamic range

                    const shX = headX;
                    const shY = headY + 10 * s;
                    const armLen = 50 * s;
                    const elbowBend = 10 * s * Math.abs(Math.sin(armAngle)); // Bend elbows naturally

                    const leftElbowX = shX + 0.2 * Math.sin(armAngle) * (armLen / 2) - elbowBend;
                    const leftElbowY = shY + Math.cos(armAngle) * (armLen / 2);
                    const leftHandX = leftElbowX + 0.2 * Math.sin(armAngle + 0.2) * (armLen / 2); // Slight offset for realism
                    const leftHandY = leftElbowY + Math.cos(armAngle + 0.2) * (armLen / 2);
                    drawSegment(shX - 5 * s, shY, leftElbowX, leftElbowY, 10 * s, '#22d3ee');
                    drawSegment(leftElbowX, leftElbowY, leftHandX, leftHandY, 10 * s, '#22d3ee');

                    const rightElbowX = shX + 0.2 * Math.sin(armAngle) * (armLen / 2) + elbowBend;
                    const rightElbowY = shY + Math.cos(armAngle) * (armLen / 2);
                    const rightHandX = rightElbowX + 0.2 * Math.sin(armAngle - 0.2) * (armLen / 2);
                    const rightHandY = rightElbowY + Math.cos(armAngle - 0.2) * (armLen / 2);
                    drawSegment(shX + 5 * s, shY, rightElbowX, rightElbowY, 10 * s, '#22d3ee');
                    drawSegment(rightElbowX, rightElbowY, rightHandX, rightHandY, 10 * s, '#22d3ee');

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("STANDING BODY WAVE (SKIER)", 20, 30);
                    // Actionable cue: Arm swing direction
                    if (cycle > 0.5) {
                        drawForce(shX, shY, 0, -1, "EXTEND ARMS");
                    } else {
                        drawForce(shX, shY, 0, 1, "BEND KNEES");
                    }
                }
                else if (type === 'trunk_twist') {
                    // REFINED: Arms are bent at elbows ("washing machine")
                    const rotPhase = easeInOutCubic((Math.sin(t * 4) + 1) / 2); // Smoother rotation
                    const rot = rotPhase * 60; // vigorous twist
                    const hipY = cy + 20 * s;
                    const footY = cy + 100 * s;

                    // Feet wide with slight knee bend
                    const kneeBend = 5 * s + Math.sin(t * 4) * 2 * s;
                    const leftKneeY = hipY + kneeBend; const leftKneeX = cx - 30 * s + (rot * 0.1);
                    ctx.beginPath(); ctx.moveTo(cx - 30 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, cx, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();
                    const rightKneeY = hipY - kneeBend; const rightKneeX = cx + 30 * s - rot * 0.1;
                    ctx.beginPath(); ctx.moveTo(cx + 30 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, cx, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();

                    // Hips with slight rotation
                    ctx.beginPath(); ctx.arc(cx, hipY, 14 * s, 0, 2 * Math.PI); ctx.fillStyle = '#475569'; ctx.fill();

                    ctx.save();
                    ctx.translate(cx, hipY);
                    ctx.rotate(rot * 0.01); // slight hip rot
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * Math.sin(t * 2), -35 * s, 0, -70 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke(); // Curved torso

                    ctx.translate(0, -60 * s);
                    ctx.rotate(rot * Math.PI / 180); // Shoulder rot

                    // Shoulders
                    drawSegment(-20 * s, 0, 20 * s, 0, 16 * s, '#22d3ee');

                    // ARMS: Bent at elbows, hands near chest, swinging with forearm movement
                    // Left Arm
                    const leftUpperAngle = Math.PI / 4 + Math.sin(t * 4) * 0.1;
                    const leftForearmAngle = Math.PI / 2 + Math.cos(t * 4) * 0.1;
                    const leftUpperX = -20 * s + Math.cos(leftUpperAngle) * 20 * s;
                    const leftUpperY = 0 + Math.sin(leftUpperAngle) * 20 * s;
                    drawSegment(-20 * s, 0, leftUpperX, leftUpperY, 8 * s, '#cbd5e1'); // Upper
                    const leftForearmX = leftUpperX + Math.cos(leftForearmAngle) * 15 * s;
                    const leftForearmY = leftUpperY + Math.sin(leftForearmAngle) * 15 * s;
                    drawSegment(leftUpperX, leftUpperY, leftForearmX, leftForearmY, 8 * s, '#cbd5e1'); // Forearm

                    // Right Arm
                    const rightUpperAngle = -Math.PI / 4 - Math.sin(t * 4) * 0.1;
                    const rightForearmAngle = -Math.PI / 2 - Math.cos(t * 4) * 0.1;
                    const rightUpperX = 20 * s + Math.cos(rightUpperAngle) * 20 * s;
                    const rightUpperY = 0 + Math.sin(rightUpperAngle) * 20 * s;
                    drawSegment(20 * s, 0, rightUpperX, rightUpperY, 8 * s, '#cbd5e1'); // Upper
                    const rightForearmX = rightUpperX + Math.cos(rightForearmAngle) * 15 * s;
                    const rightForearmY = rightUpperY + Math.sin(rightForearmAngle) * 15 * s;
                    drawSegment(rightUpperX, rightUpperY, rightForearmX, rightForearmY, 8 * s, '#cbd5e1'); // Forearm

                    // Head with slight counter-rotation
                    ctx.beginPath(); ctx.arc(0 + Math.sin(t * 4) * 2 * s, -15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.restore();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("TRUNK TWIST (BENT ARMS)", 20, 30);
                    // Actionable cue: Rotation direction
                    drawForce(cx, hipY - 70 * s, rot > 0 ? 1 : -1, 0, "TWIST TORSO");
                }
                else if (type === 'arm_raise') {
                    // REFINED: Arms go straight up and down in front (sagittal), not out to side
                    const hipY = cy + 20 * s;
                    const footY = cy + 100 * s;
                    drawSegment(cx - 10 * s, footY, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx + 10 * s, footY, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    const cycle = easeInOutCubic((Math.sin(t * 3) + 1) / 2); // 0 to 1 smoother
                    // Angle: PI (down) to 0 (up)
                    const angle = Math.PI - (cycle * Math.PI); // PI (down) to 0 (up)

                    const shY = hipY - 60 * s;
                    // Arms originate closer to midline to imply sagittal plane
                    const shL = cx - 5 * s;
                    const shR = cx + 5 * s;
                    const armLen = 50 * s;

                    // Better: Draw the arc. If sagittal, x changes little, y changes a lot.
                    // Add elbow for realism
                    const elbowBend = 5 * s * (1 - cycle); // More bend when down
                    const lElbowX = shL - 0.2 * Math.sin(angle) * (armLen / 2) - elbowBend;
                    const lElbowY = shY + Math.cos(angle) * (armLen / 2);
                    const lx = lElbowX - 0.2 * Math.sin(angle - 0.1) * (armLen / 2); // Slight curve
                    const ly = lElbowY + Math.cos(angle - 0.1) * (armLen / 2);

                    drawSegment(shL, shY, lElbowX, lElbowY, 8 * s, '#22d3ee');
                    drawSegment(lElbowX, lElbowY, lx, ly, 8 * s, '#22d3ee');

                    const rElbowX = shR + 0.2 * Math.sin(angle) * (armLen / 2) + elbowBend;
                    const rElbowY = shY + Math.cos(angle) * (armLen / 2);
                    const rx = rElbowX + 0.2 * Math.sin(angle + 0.1) * (armLen / 2);
                    const ry = rElbowY + Math.cos(angle + 0.1) * (armLen / 2);

                    drawSegment(shR, shY, rElbowX, rElbowY, 8 * s, '#22d3ee');
                    drawSegment(rElbowX, rElbowY, rx, ry, 8 * s, '#22d3ee');

                    // Thumbs indicator (yellow dot)
                    if (cycle > 0.8) {
                        ctx.beginPath(); ctx.arc(lx, ly - 5 * s, 4 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f59e0b'; ctx.fill();
                        ctx.beginPath(); ctx.arc(rx, ry - 5 * s, 4 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f59e0b'; ctx.fill();
                    }

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SAGITTAL ARM RAISES", 20, 30);
                    // Actionable cue: Thumb up highlight
                    if (cycle > 0.8) {
                        ctx.save(); ctx.globalAlpha = 0.7; ctx.fillStyle = '#f59e0b'; ctx.fillText("THUMBS UP", 20, 50);
                        ctx.restore();
                    }
                }
                else if (type === 'chest_opener') {
                    // REFINED: Arms meet in middle (clap/touch) then fling wide
                    const hipY = cy + 20 * s;
                    drawSegment(cx, cy + 100 * s, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    const phase = easeInOutCubic((Math.sin(t * 3) + 1) / 2); // Smoother phase
                    const shY = hipY - 60 * s;
                    const maxSpan = 60 * s;

                    // When phase is 0: Hands meet (span is 0 or small)
                    // When phase is 1: Hands wide (span is max)

                    const currentSpan = phase * maxSpan; // 0 to 60

                    // Add a minimal gap so they "meet"
                    const gap = 5 * s;

                    const lx = cx - gap - currentSpan;
                    const rx = cx + gap + currentSpan;

                    // Arms with slight curve for realism
                    const lCurveX = (cx - 15 * s + lx) / 2; const lCurveY = shY - 5 * s * (1 - phase); // Dip when opening
                    ctx.beginPath(); ctx.moveTo(cx - 15 * s, shY); ctx.quadraticCurveTo(lCurveX, lCurveY, lx, shY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 8 * s; ctx.stroke();
                    const rCurveX = (cx + 15 * s + rx) / 2; const rCurveY = shY + 5 * s * (1 - phase);
                    ctx.beginPath(); ctx.moveTo(cx + 15 * s, shY); ctx.quadraticCurveTo(rCurveX, rCurveY, rx, shY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 8 * s; ctx.stroke();

                    // Visual cue for "meeting"
                    if (currentSpan < 5 * s) {
                        ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(cx, shY, 5 * s, 0, 2 * Math.PI); ctx.fill(); // Spark/Touch
                    }

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("CHEST OPENER (MEET & OPEN)", 20, 30);
                    if (phase > 0.8) drawForce(rx, shY, 1, 0, "EXPAND");
                }
                else if (type === 'alt_arm_raise') {
                    // REFINED: Vertical sagittal alternating (Soldier/Swim style)
                    const hipY = cy + 20 * s;
                    const footY = cy + 100 * s;
                    drawSegment(cx - 10 * s, footY, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx + 10 * s, footY, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    const shY = hipY - 60 * s;
                    const shL = cx - 15 * s;
                    const shR = cx + 15 * s;
                    const armLen = 50 * s;

                    // Phase for alternation with easing
                    const phase = easeInOutCubic((Math.sin(t * 4) + 1) / 2);

                    // Left Arm: 0 = Down (PI), 1 = Up (0)
                    const lAngle = Math.PI - (phase * Math.PI); // PI to 0

                    // Right Arm: Opposite
                    const rAngle = Math.PI - ((1 - phase) * Math.PI); // 0 to PI (inverted)

                    // Draw with slight sagittal tilt and elbow for depth
                    const lElbowAngle = lAngle + 0.2 * Math.sin(t * 2); // Dynamic bend
                    const lElbowX = shL - Math.sin(lElbowAngle) * (armLen / 2) * s / s;
                    const lElbowY = shY + Math.cos(lElbowAngle) * (armLen / 2);
                    const lx = lElbowX - Math.sin(lAngle) * (armLen / 2) * 5 * s / 100;
                    const ly = lElbowY + Math.cos(lAngle) * (armLen / 2);

                    drawSegment(shL, shY, lElbowX, lElbowY, 8 * s, '#22d3ee');
                    drawSegment(lElbowX, lElbowY, lx, ly, 8 * s, '#22d3ee');

                    const rElbowAngle = rAngle - 0.2 * Math.sin(t * 2);
                    const rElbowX = shR - Math.sin(rElbowAngle) * (armLen / 2) * s / s;
                    const rElbowY = shY + Math.cos(rElbowAngle) * (armLen / 2);
                    const rx = rElbowX - Math.sin(rAngle) * (armLen / 2) * 5 * s / 100;
                    const ry = rElbowY + Math.cos(rAngle) * (armLen / 2);

                    drawSegment(shR, shY, rElbowX, rElbowY, 8 * s, '#22d3ee');
                    drawSegment(rElbowX, rElbowY, rx, ry, 8 * s, '#22d3ee');

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ALTERNATE ARM RAISES", 20, 30);
                    // Actionable cue: Reciprocal motion label
                    drawForce(cx, shY, 0, phase > 0.5 ? -1 : 1, "ALTERNATE");
                }
                else if (type === 'landmine_rotation' || type === 'landmine_twist') {
                    // FIXED: Starts from ground, rigid bar
                    const rotPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const rot = rotPhase * 40 * s;
                    const hipY = cy + 20 * s; const footY = cy + 100 * s;
                    // Legs pivoting with knee bend
                    const pivotLeft = rot > 0;
                    const kneeBend = 5 * s * rotPhase;
                    const leftShinX = cx - 15 * s + (pivotLeft ? kneeBend : 0);
                    drawSegment(cx - 15 * s, hipY, leftShinX, cy + 50 * s, 16 * s, pivotLeft ? '#22d3ee' : '#475569');
                    drawSegment(leftShinX, cy + 50 * s, cx - 25 * s, footY, 16 * s, pivotLeft ? '#22d3ee' : '#475569');
                    const rightShinX = cx + 15 * s - (pivotLeft ? 0 : kneeBend);
                    drawSegment(cx + 15 * s, hipY, rightShinX, cy + 50 * s, 16 * s, !pivotLeft ? '#22d3ee' : '#475569');
                    drawSegment(rightShinX, cy + 50 * s, cx + 25 * s, footY, 16 * s, !pivotLeft ? '#22d3ee' : '#475569');

                    // Torso Twist with curve
                    ctx.save(); ctx.translate(cx, hipY); ctx.rotate(rot * 0.025);
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * rotPhase, -30 * s, 0, -60 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                    ctx.restore();

                    ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    const handsX = cx + rot * 1.5; const handsY = hipY - 50 * s + Math.abs(rot) * 0.5;

                    // Barbell anchored on ground with slight flex
                    const anchorX = cx - 80 * s; const anchorY = footY;
                    const barMidX = (anchorX + handsX) / 2 + Math.sin(t * 2) * 2 * s; // Slight vibration for realism
                    const barMidY = (anchorY + handsY) / 2;
                    ctx.beginPath(); ctx.moveTo(anchorX, anchorY); ctx.quadraticCurveTo(barMidX, barMidY, handsX, handsY); ctx.strokeStyle = '#64748b'; ctx.lineWidth = 6; ctx.stroke();
                    ctx.fillStyle = '#1e293b'; ctx.beginPath(); ctx.arc(anchorX, anchorY, 10 * s, 0, Math.PI); ctx.fill();

                    drawSegment(cx, hipY - 50 * s, handsX, handsY, 8 * s, '#cbd5e1');

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("LANDMINE TWIST", 20, 30);
                    // Actionable cue: Pivot feet
                    if (rotPhase > 0.7) {
                        drawForce(cx, footY, pivotLeft ? -1 : 1, 0, "PIVOT");
                    }
                }
                else if (type === 'band_twist') {
                    // REFINED: Looks like Pallof but rotates
                    const twistPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                    const twist = twistPhase * 35 * s;
                    const hipY = cy + 20 * s;
                    const cableX = cx - 100 * s; const cableY = cy - 20 * s;

                    // Static Stance (Pallof Base) with slight knee flex
                    const kneeFlex = 3 * s * twistPhase;
                    drawSegment(cx - 15 * s, hipY, cx - 20 * s, cy + 50 * s + kneeFlex, 16 * s, '#475569');
                    drawSegment(cx - 20 * s, cy + 50 * s + kneeFlex, cx - 20 * s, cy + 100 * s, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, hipY, cx + 20 * s, cy + 50 * s - kneeFlex, 16 * s, '#475569');
                    drawSegment(cx + 20 * s, cy + 50 * s - kneeFlex, cx + 20 * s, cy + 100 * s, 16 * s, '#475569');

                    ctx.save(); ctx.translate(cx, hipY); ctx.rotate(twist * 0.02);
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(3 * s * twistPhase, -30 * s, 0, -60 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                    ctx.restore();

                    // Hands follow rotation with grip
                    const handsX = cx + twist * 1.5;
                    drawSegment(cx, hipY - 50 * s, handsX, hipY - 50 * s, 8 * s, '#cbd5e1');
                    ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Band line from anchor to hands with stretch effect
                    const bandMidX = (cableX + handsX) / 2 + Math.sin(t * 5) * 2 * s; // Vibration for tension
                    const bandMidY = (cableY + hipY - 50 * s) / 2;
                    ctx.beginPath(); ctx.moveTo(cableX, cableY); ctx.quadraticCurveTo(bandMidX, bandMidY, handsX, hipY - 50 * s); ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 3 + twistPhase; ctx.stroke();
                    ctx.fillStyle = '#334155'; ctx.fillRect(cableX - 10 * s, hipY - 70 * s, 10 * s, 40 * s); // Anchor

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("BAND TWIST", 20, 30);
                    // Actionable cue: Resist twist
                    drawForce(handsX, hipY - 50 * s, -1, 0, "RESIST");
                }
                else if (type === 'wall_throw') {
                    // NEW: Rotational Wall Throw
                    const wallX = cx + 80 * s;
                    ctx.fillStyle = '#334155'; ctx.fillRect(wallX, 0, 10 * s, h); // Wall

                    const phase = easeInOutCubic(((t * 1.5) % 2) / 2); // Smoother phase
                    const isThrowing = phase > 0.5 && phase < 0.65;
                    const rotPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const rot = rotPhase * 25 * s;
                    const hipY = cy + 20 * s;

                    drawSegment(cx - 15 * s, hipY, cx - 20 * s, cy + 100 * s, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, hipY, cx + 20 * s, cy + 100 * s, 16 * s, isThrowing ? '#22d3ee' : '#475569');

                    ctx.save(); ctx.translate(cx, hipY); ctx.rotate(rot * 0.03);
                    drawSegment(0, 0, 0, -60 * s, 16 * s, '#22d3ee');
                    ctx.restore();

                    const handsX = cx + rot * 1.5;
                    drawSegment(cx, hipY - 50 * s, handsX, hipY - 50 * s, 8 * s, '#cbd5e1');
                    ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Ball Physics with bounce on wall
                    let ballX = handsX + 15 * s;
                    let ballY = hipY - 50 * s + Math.sin(t * 10) * 2 * s; // Slight vertical bob
                    if (isThrowing) {
                        ballX += (phase - 0.5) * 300 * s; // Faster fly to wall
                        if (ballX >= wallX - 8 * s) { // Bounce back
                            ballX = wallX - 8 * s - (phase - 0.6) * 50 * s;
                            ballY += Math.sin((phase - 0.6) * Math.PI * 5) * 10 * s; // Bounce arc
                        }
                        drawForce(ballX, ballY, 1, 0, "RELEASE");
                    }
                    drawEquipment('ball', ballX, ballY, t * 2); // Rotate ball for realism

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ROTATIONAL WALL THROW", 20, 30);
                    // Actionable cue: Rotate hips
                    if (isThrowing) {
                        drawForce(cx, hipY, rot > 0 ? 1 : -1, 0, "ROTATE HIPS");
                    }
                }
                else if (type === 'med_ball_slam') {
                    const phase = easeInOutCubic(((t * 2.3) % 2) / 2);
                    const isLifting = phase < 0.4;
                    const isTop = phase >= 0.4 && phase < 0.5;
                    const isSlamming = phase >= 0.5;

                    const hipY = cy + 20 * s;
                    const shY = cy - 40 * s;

                    // Triple extension on lift
                    const extension = isLifting ? (0.4 - phase) * 30 * s : isSlamming ? (phase - 0.5) * 40 * s : 0;
                    const kneeExtend = isLifting ? 20 * s : isSlamming ? -30 * s : 0;

                    // Legs
                    drawSegment(cx - 20 * s, hipY + kneeExtend, cx - 25 * s, cy + 100 * s, 16 * s, isLifting ? '#22d3ee' : '#475569');
                    drawSegment(cx + 20 * s, hipY + kneeExtend, cx + 25 * s, cy + 100 * s, 16 * s, isLifting ? '#22d3ee' : '#475569');

                    // Torso
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 18 * s, '#475569');

                    // Ball arc
                    let ballX = cx;
                    let ballY = shY - 140 * s;
                    if (isLifting) {
                        ballY = shY - 140 * s + (0.4 - phase) * 100 * s;
                    } else if (isSlamming) {
                        const p = (phase - 0.5) / 0.5;
                        ballX = cx + p * 70 * s;
                        ballY = shY - 140 * s + p * p * 400 * s;
                    }

                    // Arms
                    drawSegment(cx - 15 * s, shY, ballX - 10 * s, ballY, 10 * s, '#38bdf8');
                    drawSegment(cx + 15 * s, shY, ballX + 10 * s, ballY, 10 * s, '#38bdf8');

                    // Ball with impact glow
                    ctx.save();
                    if (!isLifting && phase > 0.8) {
                        ctx.shadowBlur = 40;
                        ctx.shadowColor = "#f59e0b";
                    }
                    drawEquipment('ball', ballX, ballY, t * (isSlamming ? 10 : 2));
                    ctx.restore();

                    // Head
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("MED BALL POWER SLAM", 20, 20);

                    if (isLifting) {
                        ctx.fillStyle = '#22d3ee';
                        ctx.font = `bold ${12 * s}px sans-serif`;
                        ctx.fillText("TRIPLE EXTENSION", 20, 50);
                    } else if (isSlamming) {
                        ctx.fillStyle = '#f59e0b';
                        ctx.font = `bold ${12 * s}px sans-serif`;
                        ctx.fillText("EXPLOSIVE HIP DRIVE", 20, 50);
                    }

                    if (phase > 0.9) {
                        ctx.fillStyle = '#f97316';
                        ctx.font = `bold ${13 * s}px sans-serif`;
                        ctx.fillText("IMPACT!", cx - 40, cy + 60);
                    }
                }
                else if (type === 'weck_pulse') {
                    const pulsePhase = easeInOutCubic(Math.abs(Math.sin(t * 4)));
                    const pulse = pulsePhase * 5 * s;
                    const hipY = cy + pulse;
                    drawSegment(cx, hipY, cx - 20 * s, cy + 80 * s, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx + 20 * s, cy + 80 * s, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 60 * s, 16 * s, '#22d3ee');
                    ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    const headX = cx; const footX = cx + 20 * s;
                    ctx.strokeStyle = '#22d3ee'; ctx.setLineDash([2, 2]); ctx.beginPath(); ctx.moveTo(headX, hipY - 75 * s); ctx.lineTo(footX, cy + 80 * s); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("DOUBLE DOWN PULSE", 20, 30);
                    // Actionable cue: Pulse highlight
                    ctx.save(); ctx.globalAlpha = pulsePhase; ctx.fillStyle = '#22d3ee'; ctx.fillRect(cx - 10 * s, hipY, 20 * s, -60 * s);
                    ctx.restore();
                }
                else if (type === 'towel_curl') {
    // PHYSICS: The "Windlass Mechanism" + Cloth Simulation
    // As toes curl (flex), the arch MUST rise, and the towel MUST bunch up.
    
    const cycle = easeInOutCubic((Math.sin(t * 2.5) + 1) / 2); // 0 (flat) to 1 (curled)
    const heelX = cx - 35 * s;
    const ballX = cx + 25 * s;
    const footY = cy + 80 * s; // Ground level
    
    // 1. Arch Mechanics (Windlass)
    // The arch rises as the toes curl. This is the bio-mechanical goal.
    const archHeight = 10 * s + (cycle * 15 * s); 
    const ankleX = cx - 10 * s;
    const ankleY = footY - 40 * s - (cycle * 5 * s); // Ankle rises slightly

    // Draw Leg
    drawSegment(ankleX, ankleY, ankleX + 5 * s, cy - 40 * s, 14 * s, '#475569'); // Shin
    
    // Draw Foot (Heel -> Arch -> Ball)
    ctx.beginPath();
    ctx.moveTo(heelX, footY);
    ctx.quadraticCurveTo(cx, footY - archHeight, ballX, footY);
    ctx.lineWidth = 14 * s;
    ctx.strokeStyle = '#22d3ee';
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // 2. Toe Dexterity (The "Grip")
    // Toes don't just bend; they hook downwards and pull back.
    const toeLen = 20 * s;
    const toeCurlAngle = cycle * Math.PI * 0.6; // Bend 100 degrees
    const toeX = ballX + Math.cos(toeCurlAngle) * toeLen;
    const toeY = footY + Math.sin(toeCurlAngle) * toeLen * 0.6; // Flatten on floor
    
    ctx.beginPath();
    ctx.moveTo(ballX, footY);
    ctx.quadraticCurveTo(ballX + 10 * s, footY - (cycle * 10 * s), toeX, toeY);
    ctx.lineWidth = 14 * s;
    ctx.strokeStyle = '#22d3ee';
    ctx.stroke();

    // 3. CLOTH SIMULATION (The Towel)
    // We draw the towel as a sine wave that increases in amplitude (bunching)
    // and decreases in length (gathering) as toes curl.
    ctx.beginPath();
    const towelStart = ballX;
    const towelLen = 80 * s * (1 - cycle * 0.4); // Towel gets shorter as it bunches
    const bunches = 6;
    
    ctx.moveTo(towelStart, footY + 8 * s);
    
    for (let i = 0; i <= bunches; i++) {
        const x = towelStart + (i / bunches) * towelLen;
        // Amplitude grows with cycle. Sine wave creates "wrinkles"
        const y = footY + 8 * s - Math.sin(i * Math.PI) * (cycle * 12 * s); 
        ctx.lineTo(x, y);
    }
    
    ctx.lineJoin = 'round';
    ctx.lineWidth = 4 * s;
    ctx.strokeStyle = '#e2e8f0'; // White towel
    ctx.stroke();
    
    // 4. Visual Feedback
    ctx.fillStyle = '#fff'; ctx.font = `bold ${12 * s}px sans-serif`; ctx.fillText("INTRINSIC FOOT STRENGTH", 20, 30);
    
    // Highlight the Arch rising (The "Why")
    if (cycle > 0.6) {
        drawForce(cx, footY - archHeight + 10 * s, 0, -1, "ARCH LIFT");
        ctx.fillStyle = '#22d3ee'; ctx.font = `bold ${10 * s}px sans-serif`; 
        ctx.fillText("WINDLASS ON", cx - 20 * s, cy);
    }
}
                else if (type === 'pallof_press') {
                    const pressPhase = easeInOutCubic(Math.abs(Math.sin(t * 2.2)));
                    const press = pressPhase * 35 * s;
                    const braceIntensity = pressPhase > 0.5 ? 0.6 + Math.sin(t * 8) * 0.3 : 0.3;

                    const cableX = cx - 90 * s;
                    const cableY = cy - 10 * s;
                    const bodyX = cx + 15 * s;
                    const handY = cy - 10 * s;

                    // Stable stance - slight knee soften
                    const kneeFlex = 5 * s;
                    drawSegment(bodyX - 20 * s, cy + 100 * s, bodyX - 15 * s, cy + 40 * s + kneeFlex, 16 * s, '#475569');
                    drawSegment(bodyX + 20 * s, cy + 100 * s, bodyX + 15 * s, cy + 40 * s + kneeFlex, 16 * s, '#475569');

                    // Torso - upright and braced
                    drawSegment(bodyX, cy + 40 * s, bodyX, cy - 60 * s, 18 * s, '#22d3ee');

                    // Oblique sling activation - clean X pattern glow
                    ctx.save();
                    ctx.globalAlpha = braceIntensity;
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 12 * s;
                    ctx.setLineDash([4, 8]);
                    ctx.beginPath();
                    // Left oblique to right hip
                    ctx.moveTo(bodyX - 10 * s, cy - 40 * s);
                    ctx.quadraticCurveTo(bodyX, cy, bodyX + 20 * s, cy + 50 * s);
                    // Right oblique to left hip
                    ctx.moveTo(bodyX + 10 * s, cy - 40 * s);
                    ctx.quadraticCurveTo(bodyX, cy, bodyX - 20 * s, cy + 50 * s);
                    ctx.stroke();
                    ctx.restore();

                    // Arms - clean, connected, no extras
                    const shoulderY = cy - 50 * s;
                    const elbowOffset = pressPhase * 8 * s;
                    const leftElbowX = bodyX - 15 * s - elbowOffset;
                    const rightElbowX = bodyX + 15 * s + elbowOffset;
                    const handX = bodyX + press;

                    // Upper arms
                    drawSegment(bodyX - 12 * s, shoulderY, leftElbowX, shoulderY + 5 * s, 10 * s, '#cbd5e1');
                    drawSegment(bodyX + 12 * s, shoulderY, rightElbowX, shoulderY + 5 * s, 10 * s, '#cbd5e1');

                    // Forearms to hands
                    drawSegment(leftElbowX, shoulderY + 5 * s, handX - 8 * s, handY, 10 * s, '#cbd5e1');
                    drawSegment(rightElbowX, shoulderY + 5 * s, handX + 8 * s, handY, 10 * s, '#cbd5e1');

                    // Cable - thicker when resisting
                    ctx.strokeStyle = '#f43f5e';
                    ctx.lineWidth = 5 + pressPhase * 4;
                    ctx.beginPath();
                    ctx.moveTo(cableX, cableY);
                    ctx.lineTo(handX, handY);
                    ctx.stroke();

                    // Anchor post
                    ctx.fillStyle = '#334155';
                    ctx.fillRect(cableX - 12 * s, cableY - 60 * s, 24 * s, 120 * s);

                    // Head - stable
                    ctx.beginPath();
                    ctx.arc(bodyX, cy - 75 * s, 18 * s, 0, 2 * Math.PI);
                    ctx.fillStyle = '#cbd5e1';
                    ctx.fill();

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("PALLOF PRESS", 20, 20);

                    ctx.fillStyle = '#f59e0b';
                    ctx.font = `bold ${13 * s}px sans-serif`;
                    ctx.fillText("ANTI-ROTATION = FOUNDATION OF POWER", 20, 45);

                    if (pressPhase > 0.5) {
                        ctx.fillStyle = '#22d3ee';
                        ctx.font = `bold ${12 * s}px sans-serif`;
                        ctx.fillText("OBLIQUE SLINGS BRACING", 20, h - 50);
                    }

                    drawForce(handX + 10, handY, -1, 0, "RESIST TWIST");
                }
                else if (type === 'head_loading_basic' || type === 'head_loading') {
                    // ELITE CERVICAL ALIGNMENT: Stillness + Deep Core Activation Under Axial Load
                    const breathPhase = easeInOutCubic((Math.sin(t * 1.4) + 1) / 2);
                    const armReachPhase = Math.min(1, t / 3);

                    const headX = cx;
                    const headY = cy - 60 * s - breathPhase * 6 * s;
                    const shoulderY = cy - 20 * s;
                    const hipY = cy + 40 * s;
                    const footY = cy + 100 * s;

                    // Gravity line
                    ctx.save();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(cx, footY);
                    ctx.lineTo(cx, headY - 50 * s);
                    ctx.stroke();
                    ctx.restore();

                    // Stable body
                    drawSegment(cx - 15 * s, footY, cx - 8 * s, hipY, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, footY, cx + 8 * s, hipY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, shoulderY, 16 * s, '#475569');

                    // Breath expansion glow
                    const breathExpand = breathPhase * 10 * s;
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#22d3ee';
                    ctx.beginPath();
                    ctx.ellipse(cx, (shoulderY + hipY) / 2, 30 * s + breathExpand, 50 * s + breathExpand / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // Multifidus glow
                    if (breathPhase > 0.5) {
                        drawMuscle(cx - 4 * s, hipY + 10 * s, cx - 4 * s, shoulderY - 10 * s, 12 * s, true);
                        drawMuscle(cx + 4 * s, hipY + 10 * s, cx + 4 * s, shoulderY - 10 * s, 12 * s, true);
                    }

                    // --- NEW REALISTIC HOLDING ARMS ---
// 1. Define the ball's position (it moves with the head breath)
const ballY = headY - 38 * s; // Matches the ball drawing coordinate

// 2. Define Shoulders (Fixed)
const shL_x = cx - 20 * s; 
const shR_x = cx + 20 * s;
const sh_y = shoulderY;

// 3. Define Target Hand Positions (Holding sides of ball)
const handL_target_x = cx - 14 * s; // Left hand on left side of ball
const handR_target_x = cx + 14 * s; // Right hand on right side of ball
const hand_target_y = ballY;

// 4. Define Target Elbow Positions (Flared out for stability)
const elbowL_target_x = cx - 45 * s;
const elbowR_target_x = cx + 45 * s;
const elbow_target_y = (sh_y + ballY) / 2; // Midpoint vertically

// 5. Define Start Positions (Hands at sides)
const handL_start_x = cx - 25 * s;
const handR_start_x = cx + 25 * s;
const hand_start_y = cy + 40 * s; // Hips

const elbowL_start_x = cx - 30 * s; 
const elbowR_start_x = cx + 30 * s;
const elbow_start_y = cy + 10 * s;

// 6. Interpolate based on armReachPhase (Smooth animation up)
const reach = easeInOutCubic(armReachPhase); 

const hLx = handL_start_x + (handL_target_x - handL_start_x) * reach;
const hLy = hand_start_y + (hand_target_y - hand_start_y) * reach;
const eLx = elbowL_start_x + (elbowL_target_x - elbowL_start_x) * reach;
const eLy = elbow_start_y + (elbow_target_y - elbow_start_y) * reach;

const hRx = handR_start_x + (handR_target_x - handR_start_x) * reach;
const hRy = hand_start_y + (hand_target_y - hand_start_y) * reach;
const eRx = elbowR_start_x + (elbowR_target_x - elbowR_start_x) * reach;
const eRy = elbow_start_y + (elbow_target_y - elbow_start_y) * reach;

// 7. Draw The Arms (Shoulder -> Elbow -> Hand)
drawSegment(shL_x, sh_y, eLx, eLy, 10 * s, '#cbd5e1'); // Left Upper
drawSegment(eLx, eLy, hLx, hLy, 9 * s, '#cbd5e1');     // Left Forearm
drawSegment(shR_x, sh_y, eRx, eRy, 10 * s, '#cbd5e1'); // Right Upper
drawSegment(eRx, eRy, hRx, hRy, 9 * s, '#cbd5e1');     // Right Forearm

// Draw Hands gripping (Small circles)
ctx.beginPath(); ctx.arc(hLx, hLy, 5 * s, 0, 2 * Math.PI); ctx.fillStyle = '#22d3ee'; ctx.fill();
ctx.beginPath(); ctx.arc(hRx, hRy, 5 * s, 0, 2 * Math.PI); ctx.fillStyle = '#22d3ee'; ctx.fill();

                    // Head & ball - perfectly stable
                    ctx.beginPath(); ctx.arc(headX, headY, 22 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    drawEquipment('ball', headX, headY - 38 * s, 0);

                    // === TEXT WITH FIXED SCALED FONTS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("CERVICAL AXIAL DECOMPRESSION", 20, 20);

                    ctx.fillStyle = breathPhase > 0.5 ? '#f59e0b' : '#22d3ee';
                    ctx.font = `bold ${12 * s}px sans-serif`;
                    ctx.fillText(breathPhase > 0.5 ? "EXHALE — RELAX & HOLD" : "INHALE — LENGTHEN & ACTIVATE", 20, 45);

                    if (breathPhase > 0.6) {
                        ctx.fillStyle = '#22d3ee';
                        ctx.font = `bold ${11 * s}px sans-serif`;
                        ctx.fillText("DEEP CORE FIRING", cx - 60, cy - 10);
                        ctx.fillText("(Multifidus + TA)", cx - 60, cy + 8);
                    }

                    ctx.fillStyle = '#f59e0b';
                    ctx.font = `bold ${11 * s}px sans-serif`;
                    ctx.fillText("GRAVITY LINE — PERFECT ALIGNMENT", cx + 15, footY - 25);

                    ctx.fillStyle = '#f59e0b';
                    ctx.font = `bold ${10 * s}px sans-serif`;
                    ctx.fillText("STILLNESS UNDER LOAD = TRUE STRENGTH", 20, h - 30);
                }
                else if (type === 'head_hinge') {  // Realistic Head-Loaded Hip Hinge with Hands Holding Ball
    const phase = easeInOutCubic((Math.sin(t * 1.8) + 1) / 2);  // Slower, smoother hinge
    const hingeAngle = phase * 50 * (Math.PI / 180);  // Up to ~50° for deeper hinge
    const hipShiftBack = -phase * 30 * s;  // Butt pushes back for realism (negative to shift opposite to lean)
    const hipX = cx + hipShiftBack;
    const thighLength = 50 * s;
    const shinLength = 50 * s;
    const kneeY = cy + shinLength;
    const footY = kneeY + shinLength;
    const deltaX = hipShiftBack;
    const thighEffectiveLength = Math.sqrt(thighLength ** 2 - deltaX ** 2);
    const hipY = kneeY - thighEffectiveLength;
    // Torso (spine) hinged from hips
    ctx.save();
    ctx.translate(hipX, hipY);
    ctx.rotate(hingeAngle);
    drawSegment(0, -60 * s, 0, 20 * s, 18 * s, '#475569');  // Thicker neutral spine
    ctx.restore();
    // Calculate shoulder position (top of torso)
    const shoulderX = hipX + Math.sin(hingeAngle) * 60 * s;
    const shoulderY = hipY - 60 * s * Math.cos(hingeAngle);
    // Head position (consistent with shoulder, no extra offset)
    const headX = shoulderX;
    const headY = shoulderY - 60 * s;  // Adjusted for better proportion
    // Draw head
    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
    // Draw ball on head
    drawEquipment('ball', headX, headY - 28 * s, 0);
    // Legs with knees: shins vertical, thighs angled
    const leftFootX = cx - 20 * s;
    const rightFootX = cx + 20 * s;
    const leftKneeX = leftFootX;
    const rightKneeX = rightFootX;
    const leftHipX = hipX - 20 * s;
    const rightHipX = hipX + 20 * s;
    // Left leg (thigh and shin)
    drawSegment(leftHipX, hipY, leftKneeX, kneeY, 16 * s, '#22d3ee');  // Thigh
    drawSegment(leftKneeX, kneeY, leftFootX, footY, 16 * s, '#22d3ee');  // Shin
    // Right leg (thigh and shin)
    drawSegment(rightHipX, hipY, rightKneeX, kneeY, 16 * s, '#22d3ee');  // Thigh
    drawSegment(rightKneeX, kneeY, rightFootX, footY, 16 * s, '#22d3ee');  // Shin
    // NEW: Both hands holding the ball - realistic bent arms
    // Left arm (visible in side view as "front" arm)
    const leftHandX = headX - 10 * s;
    const leftHandY = headY - 20 * s;
    const leftElbowX = shoulderX - 20 * s;  // Flare out left
    const leftElbowY = (shoulderY + leftHandY) / 2 + 10 * s;  // Slight down curve
    drawSegment(shoulderX, shoulderY, leftElbowX, leftElbowY, 8 * s, '#cbd5e1');
    drawSegment(leftElbowX, leftElbowY, leftHandX, leftHandY, 8 * s, '#cbd5e1');
    // Right arm (behind in side view, slightly offset for visibility)
    const rightHandX = headX + 10 * s;
    const rightHandY = headY - 20 * s;
    const rightElbowX = shoulderX + 20 * s;  // Flare out right
    const rightElbowY = (shoulderY + rightHandY) / 2 + 10 * s;
    drawSegment(shoulderX, shoulderY, rightElbowX, rightElbowY, 8 * s, '#cbd5e1');
    drawSegment(rightElbowX, rightElbowY, rightHandX, rightHandY, 8 * s, '#cbd5e1');
    // NEW: Neck glow during deep hinge (like VMO in split_squat)
    if (phase > 0.6) {
        drawMuscle(shoulderX, shoulderY - 10 * s, headX, headY + 10 * s, 14 * s, true, "AXIAL LOAD", 'right');
    }
    // NEW: Glutes/Hams glow for lower body engagement
    if (phase > 0.6) {
        drawMuscle(hipX, hipY - 10 * s, hipX, hipY + 20 * s, 20 * s, true, "GLUTES/HAMS", 'left');
    }
    // Captions and Cues
    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED HIP HINGE", 20, 30);
    drawForce(hipX, hipY + 60 * s, -1, 0, "PUSH BUTT BACK");  // Adjusted direction for realism
    if (phase > 0.5) {
        ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 11px sans-serif'; ctx.fillText("HANDS HOLD BALL", 20, h - 30);
    }
}
                else if (type === 'head_split') {
    const phase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
    const depth = phase * 35 * s;  // Deeper drop
    const headX = cx + Math.sin(t * 2) * 2 * s;  // Slight natural sway
    const headY = cy - 60 * s + depth * 0.3;  // Head stays high and stable
    const hipY = cy + 10 * s + depth;
    const frontFootX = cx + 55 * s;
    const backFootX = cx - 55 * s;
    const frontKneeX = cx + 45 * s;
    const backKneeX = cx - 20 * s;

    // Weight perfectly balanced on head
    drawEquipment('ball', headX, headY - 35 * s, t * 0.5);  // Slight wobble for realism

    // Front leg — deep ATG, knee well over toe
    drawSegment(cx, hipY, frontKneeX, cy + 45 * s + depth, 18 * s, '#22d3ee');
    drawSegment(frontKneeX, cy + 45 * s + depth, frontFootX, cy + 100 * s, 16 * s, '#22d3ee');

    // Back leg — straight, heel up
    drawSegment(cx, hipY, backKneeX, cy + 70 * s + depth * 0.5, 16 * s, '#475569');
    drawSegment(backKneeX, cy + 70 * s + depth * 0.5, backFootX, cy + 100 * s, 14 * s, '#475569');

    // Torso — perfectly upright, no lean
    drawSegment(cx, hipY, cx, hipY - 80 * s, 18 * s, '#22d3ee');

    // Head — stable on top
    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

    // VMO glow on front thigh when deep
    if (phase > 0.6) {
        drawMuscle(frontKneeX - 5 * s, cy + 45 * s + depth, frontKneeX + 10 * s, cy + 60 * s + depth, 16 * s, true, "VMO", 'right');
    }

    // Caption
    ctx.fillStyle = '#fff'; ctx.font = `bold ${14 * s}px sans-serif`; ctx.fillText("HEAD-LOADED ATG SPLIT SQUAT", 20, 30);

    // Key cue when deep
    if (phase > 0.7) {
        ctx.fillStyle = '#f59e0b'; ctx.font = `bold ${12 * s}px sans-serif`;
        ctx.fillText("KNEE OVER TOE • TORSO TALL", 20, 55);
    }
}
                else if (type === 'head_coiling') {  // Coiling (simple version)
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED COILING", 20, 30);
                    // (reuses coiling_lunge logic + ball on head - you already have coiling_lunge, so it will look good)
                }
                else if (type === 'head_march') {
                    const marchCycle = Math.sin(t * 5);  // Faster, smoother march
                    const leftKneeUp = marchCycle > 0 ? Math.abs(marchCycle) * 45 * s : 0;
                    const rightKneeUp = marchCycle < 0 ? Math.abs(marchCycle) * 45 * s : 0;

                    const headX = cx + Math.sin(t * 5) * 4 * s;  // Tiny natural sway
                    const headY = cy - 40 * s;
                    drawEquipment('ball', headX, headY - 28 * s, 0);

                    // Upright torso
                    drawSegment(cx, cy - 20 * s, cx, cy + 40 * s, 18 * s, '#475569');

                    // Left leg - marches when right is down
                    const leftThighY = cy + 40 * s + leftKneeUp * 0.5;
                    drawSegment(cx - 15 * s, cy + 40 * s, cx - 15 * s, leftThighY, 16 * s, leftKneeUp > 0 ? '#22d3ee' : '#475569');
                    drawSegment(cx - 15 * s, leftThighY, cx - 20 * s, cy + 90 * s + leftKneeUp * 0.8, 14 * s, leftKneeUp > 0 ? '#22d3ee' : '#475569');

                    // Right leg
                    const rightThighY = cy + 40 * s + rightKneeUp * 0.5;
                    drawSegment(cx + 15 * s, cy + 40 * s, cx + 15 * s, rightThighY, 16 * s, rightKneeUp > 0 ? '#22d3ee' : '#475569');
                    drawSegment(cx + 15 * s, rightThighY, cx + 20 * s, cy + 90 * s + rightKneeUp * 0.8, 14 * s, rightKneeUp > 0 ? '#22d3ee' : '#475569');

                    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED MARCH", 20, 30);
                    drawForce(headX, headY, 0, 0.3, "STABLE CORE");
                }
                else if (type === 'meta_release') {
                    // Seated figure crossing leg
                    const hipY = cy + 20 * s;
                    const headY = hipY - 60 * s;

                    // Torso & Head
                    ctx.beginPath(); ctx.moveTo(cx, hipY); ctx.quadraticCurveTo(cx + 10 * s, (hipY + headY) / 2, cx + 5 * s, headY);
                    ctx.lineWidth = 14 * s; ctx.strokeStyle = '#475569'; ctx.stroke();
                    ctx.beginPath(); ctx.arc(cx + 5 * s, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Legs: Left leg planted, Right leg crossed over knee
                    drawSegment(cx, hipY, cx - 10 * s, cy + 90 * s, 14 * s, '#475569'); // Planted leg

                    // Crossed Leg (Target)
                    const kneeX = cx + 25 * s; const kneeY = hipY - 10 * s;
                    const footTargetX = cx - 10 * s; const footTargetY = hipY + 10 * s;
                    drawSegment(cx, hipY, kneeX, kneeY, 14 * s, '#22d3ee'); // Thigh
                    drawSegment(kneeX, kneeY, footTargetX, footTargetY, 12 * s, '#22d3ee'); // Shin/Foot

                    // Hands working on the foot
                    const handPhase = Math.sin(t * 3);
                    drawSegment(cx + 5 * s, headY + 10 * s, footTargetX + 5 * s, footTargetY - 5 * s, 8 * s, '#cbd5e1'); // Arm

                    // The Specific Spot Highlight (Metatarsal 1-2)
                    ctx.save();
                    ctx.translate(footTargetX, footTargetY);
                    ctx.rotate(handPhase * 0.1);
                    ctx.fillStyle = '#f43f5e';
                    ctx.beginPath(); ctx.arc(0, 0, 6 * s + (handPhase * 2 * s), 0, 2 * Math.PI); ctx.fill();
                    ctx.restore();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("METATARSAL SPLAY RELEASE", 20, 30);
                    if (handPhase > 0) drawForce(footTargetX, footTargetY - 20 * s, 0, 1, "PRESS & SPLAY");
                }

                else if (type === 'ql_straddle') {
                    // Wide stance, single arm kettlebell hinge
                    const hingePhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const hingeAngle = hingePhase * 45 * (Math.PI / 180);

                    const hipY = cy + 10 * s;
                    const footY = cy + 90 * s;

                    // Wide Stance Legs
                    drawSegment(cx - 30 * s, footY, cx - 5 * s, hipY, 16 * s, '#475569');
                    drawSegment(cx + 30 * s, footY, cx + 5 * s, hipY, 16 * s, '#475569');

                    // Hinging Torso
                    ctx.save();
                    ctx.translate(cx, hipY);
                    ctx.rotate(hingeAngle); // Forward lean

                    // Spine
                    drawSegment(0, 0, 0, -70 * s, 18 * s, '#22d3ee'); // Blue to show QL activation focus
                    // Head
                    ctx.beginPath(); ctx.arc(0, -85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Arms
                    // Non-working arm (on hip/side)
                    drawSegment(10 * s, -60 * s, 20 * s, -30 * s, 8 * s, '#cbd5e1');

                    // Working Arm (Holding Kettlebell)
                    // Arm hangs straight down relative to world (gravity), so we counter-rotate slightly or simplify geometry
                    drawSegment(-10 * s, -60 * s, -10 * s, 10 * s, 8 * s, '#cbd5e1');

                    // Kettlebell
                    const kbX = -10 * s; const kbY = 15 * s;
                    ctx.fillStyle = '#1e293b';
                    ctx.beginPath(); ctx.arc(kbX, kbY + 10 * s, 12 * s, 0, 2 * Math.PI); ctx.fill(); // Bell
                    ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 3; ctx.strokeRect(kbX - 6 * s, kbY, 12 * s, 10 * s); // Handle

                    ctx.restore();

                    // Highlight the QL area
                    if (hingePhase > 0.3) {
                        ctx.save();
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = '#f59e0b'; // Orange warning/activation
                        // Draw rectangle at lower back on the opposite side of weight
                        ctx.translate(cx, hipY);
                        ctx.rotate(hingeAngle);
                        ctx.fillRect(5 * s, -30 * s, 10 * s, 20 * s);
                        ctx.restore();
                    }

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("QL STRADDLE HINGE", 20, 30);
                    drawForce(cx, hipY - 20 * s, 0, -1, "ANTI-ROTATION");
                }
                else if (type === 'hft_swing') {
                    const hipY = cy; const kneeY = cy + 60 * s; const footY = cy + 100 * s;
                    drawSegment(cx - 10 * s, hipY, cx - 10 * s, footY, 6 * s, '#475569');
                    const swingPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                    const swing = swingPhase * 30 * s;
                    const kneeBend = swingPhase * 5 * s; // Bend knee during swing
                    const kneeX = cx + 10 * s + swing / 2;
                    const kneePosY = kneeY + kneeBend;
                    ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(kneeX, kneePosY, cx + 10 * s + swing, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                    ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("TOE TENSION", cx - 10 * s, footY + 20 * s);
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HFT KINETIC SWING", 20, 30);
                    drawForce(cx + 10 * s + swing, footY, swing > 0 ? 1 : -1, 0, "MOMENTUM");
                    // Actionable cue: Toe tension highlight
                    if (swingPhase > 0.6) {
                        ctx.save(); ctx.globalAlpha = 0.7; ctx.fillStyle = '#22d3ee'; ctx.beginPath(); ctx.arc(cx + 10 * s + swing, footY, 5 * s, 0, 2 * Math.PI); ctx.fill();
                        ctx.restore();
                    }
                }
                else if (type === 'coiling_lunge' || type === 'head_coiling') {
                    // ELITE COILING LUNGE: Integrated Torsion + Head Over Foot
                    const lungePhase = easeInOutCubic((Math.sin(t * 1.2) + 1) / 2);
                    const coilPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);

                    const lungeDepth = lungePhase * 25 * s;
                    const coilTwist = coilPhase * 0.4;        // Rotation in radians
                    const coilSideBend = coilPhase * 15 * s;  // Lateral offset

                    const frontFootX = cx + 50 * s;
                    const backFootX = cx - 50 * s;
                    const hipY = cy + 20 * s + lungeDepth;
                    const footY = cy + 100 * s;

                    // Legs - stable
                    drawSegment(cx, hipY, frontFootX, footY, 16 * s, '#22d3ee');
                    drawSegment(cx, hipY, backFootX, footY, 16 * s, '#475569');

                    // Torso base point at hips
                    ctx.save();
                    ctx.translate(cx, hipY);

                    // Apply coil: twist + side bend
                    ctx.rotate(coilTwist);
                    const torsoMidX = coilSideBend * Math.sign(coilTwist);
                    const torsoTopY = -70 * s;

                    // Draw curved torso showing spiral
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(torsoMidX, torsoTopY / 2, 0, torsoTopY);
                    ctx.lineWidth = 18 * s;
                    ctx.strokeStyle = '#22d3ee';
                    ctx.stroke();

                    // Head - stays connected to top of torso, no drift
                    const headX = torsoMidX * 0.3;  // Slight follow-through but minimal
                    const headY = torsoTopY - 15 * s;
                    ctx.beginPath();
                    ctx.arc(headX, headY, 18 * s, 0, 2 * Math.PI);
                    ctx.fillStyle = '#cbd5e1';
                    ctx.fill();

                    ctx.restore(); // Back to world space

                    // Optional ball for head_coiling
                    if (type === 'head_coiling') {
                        drawEquipment('ball', cx + headX, hipY + headY - 35 * s, 0);
                    }

                    // Head Over Foot line (from crown to front foot)
                    ctx.save();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 6]);
                    ctx.beginPath();
                    ctx.moveTo(cx + headX, hipY + headY);
                    ctx.lineTo(frontFootX, footY);
                    ctx.stroke();
                    ctx.restore();

                    // Spiral torsion glow during peak coil
                    if (coilPhase > 0.6) {
                        ctx.save();
                        ctx.globalAlpha = 0.4 + Math.sin(t * 8) * 0.2;
                        ctx.strokeStyle = '#22d3ee';
                        ctx.lineWidth = 6 * s;
                        ctx.translate(cx, hipY - 30 * s);
                        ctx.beginPath();
                        for (let i = 1; i < 7; i++) {
                            const radius = i * 10 * s;
                            ctx.arc(0, 0, radius, 0, Math.PI * 1.5 * coilPhase);
                        }
                        ctx.stroke();
                        ctx.restore();
                    }

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText(type === 'head_coiling' ? "HEAD-LOADED COILING LUNGE" : "COILING LUNGE", 20, 20);

                    ctx.fillStyle = '#f59e0b';
                    ctx.font = `bold ${13 * s}px sans-serif`;
                    ctx.fillText("HEAD OVER FOOT", cx - 70, hipY + headY - 20);

                    ctx.fillStyle = '#22d3ee';
                    ctx.font = `bold ${12 * s}px sans-serif`;
                    ctx.fillText("TORSION LOADING = ELASTIC POWER", 20, 50);

                    if (coilPhase > 0.7) {
                        ctx.fillStyle = '#f97316';
                        ctx.font = `bold ${11 * s}px sans-serif`;
                        ctx.fillText("COIL → STORE → WHIP RELEASE", 20, h - 30);
                    }
                }
                else if (type === 'shoulder_release') {
                    const headX = cx, headY = cy - 60 * s, shY = cy - 40 * s, shL = cx - 25 * s, shR = cx + 25 * s;
                    drawSegment(cx, shY, cx, cy + 50 * s, 14 * s, '#475569'); drawSegment(shL, shY, shR, shY, 4 * s);
                    ctx.beginPath(); ctx.arc(headX, headY, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    drawMuscle(shR, shY, headX, headY + 10 * s, 15 * s, cycle > 0, "TISSUE RELEASE");
                    const ballRoll = Math.sin(t * 2) * 3 * s; // Rolling motion
                    drawEquipment('smash_ball', shR - 8 * s + ballRoll, shY - 5 * s, t * 2); // Rotate ball
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SOFT TISSUE MOBILIZATION", 20, 30);
                    // Actionable cue: Breathe label
                    ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("BREATHE DEEP", shR + 10 * s, shY);
                }
                else if (type === 'foot_roll') {
                    const footY = cy + 80 * s; const ankleX = cx;
                    // Draw Foot with arch curve
                    const heelX = ankleX - 20 * s; const toeX = ankleX + 20 * s;
                    const archPhase = Math.sin(t * 2) * 5 * s; // Arch flex
                    ctx.beginPath(); ctx.moveTo(heelX, footY); ctx.quadraticCurveTo(ankleX, footY - 10 * s - archPhase, toeX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();

                    // Draw Leg (Standing) with slight bend
                    const kneeY = cy + 20 * s; const hipY = cy - 40 * s;
                    const shinBend = Math.sin(t * 2) * 2 * s;
                    ctx.beginPath(); ctx.moveTo(ankleX, footY); ctx.quadraticCurveTo(ankleX + shinBend, (footY + kneeY) / 2, ankleX, kneeY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 10 * s; ctx.stroke(); // Shin
                    ctx.beginPath(); ctx.moveTo(ankleX, kneeY); ctx.quadraticCurveTo(ankleX - shinBend, (kneeY + hipY) / 2, ankleX, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke(); // Thigh

                    // Draw Torso/Head with slight lean
                    const headY = hipY - 50 * s;
                    const torsoLean = Math.sin(t * 2) * 3 * s;
                    ctx.beginPath(); ctx.moveTo(ankleX, hipY); ctx.quadraticCurveTo(ankleX + torsoLean / 2, (hipY + headY) / 2, ankleX + torsoLean, headY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 14 * s; ctx.stroke(); // Torso
                    ctx.beginPath(); ctx.arc(ankleX + torsoLean, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    const ballPosPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const ballPos = ballPosPhase * 20 * s - 10 * s;
                    drawEquipment('smash_ball', ankleX + ballPos, footY + 5 * s, t * 2); // Rolling ball
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("PLANTAR RELEASE", 20, 30);
                    // Actionable cue: Pressure point
                    ctx.save(); ctx.globalAlpha = 0.5 + Math.cos(t * 3) * 0.3; ctx.beginPath(); ctx.arc(ankleX + ballPos, footY + 5 * s, 8 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f43f5e'; ctx.fill();
                    ctx.restore();
                }
                else if (type === 'spinal_wave') {
                    const ballX = cx, ballY = cy + 40 * s; drawEquipment('swiss', ballX, ballY, 0);
                    const curvePhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const curve = 30 * s + (curvePhase * 30 * s); // Deeper curve
                    const bodyColor = curvePhase > 0.5 ? '#22d3ee' : '#475569';
                    ctx.beginPath(); ctx.moveTo(cx - 40 * s, cy + 40 * s); ctx.quadraticCurveTo(cx, cy - curve, cx + 40 * s, cy + 40 * s);
                    ctx.lineWidth = 14 * s; ctx.strokeStyle = bodyColor; ctx.lineCap = 'round'; ctx.stroke();
                    ctx.beginPath(); ctx.arc(cx - 45 * s, cy + 35 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill(); // Head
                    if (curvePhase > 0.5) { ctx.fillStyle = '#22c55e'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("SEGMENTATION", cx - 20 * s, cy - 60 * s); }
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SPINAL WAVE", 20, 30);
                    // Actionable cue: Wave direction
                    drawForce(cx, cy, curvePhase > 0.5 ? 0 : 0, curvePhase > 0.5 ? -1 : 1, "WAVE UP");
                }
                else if (type === 'hyperarch_hop') {
                    const hopPhase = easeInOutCubic(Math.abs(Math.sin(t * 3))); // Half speed for control
                    const hop = hopPhase * 15 * s;
                    const footY = cy + 80 * s - hop; const hipY = cy - 60 * s - hop;
                    const ankleFlex = hopPhase * 5 * s; // Ankle dorsiflexion
                    const leftAnkleY = footY - ankleFlex; const leftAnkleX = cx - 10 * s;
                    ctx.beginPath(); ctx.moveTo(cx - 10 * s, hipY); ctx.quadraticCurveTo(cx - 10 * s, (hipY + leftAnkleY) / 2, leftAnkleX, leftAnkleY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(leftAnkleX, leftAnkleY); ctx.lineTo(cx - 10 * s, footY); ctx.stroke(); // Foot
                    const rightAnkleY = footY + ankleFlex; const rightAnkleX = cx + 10 * s;
                    ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(cx + 10 * s, (hipY + rightAnkleY) / 2, rightAnkleX, rightAnkleY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(rightAnkleX, rightAnkleY); ctx.lineTo(cx + 10 * s, footY); ctx.stroke();
                    drawSegment(cx, hipY, cx, hipY - 60 * s, 14 * s, '#475569');
                    if (hop > 5 * s) { ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("LOCKED ANKLE", cx + 20 * s, footY); }
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("2-FOOT FASCIAL HOP", 20, 30);
                    drawForce(cx, footY, 0, -1, "RECOIL");
                    // Actionable cue: Heel suspend
                    ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(cx, footY - 5 * s, 3 * s, 0, 2 * Math.PI); ctx.fill(); // Heel point
                    ctx.restore();
                }
                else if (type === 'standing_pull') {
                    const hipY = cy + 20 * s; const footY = cy + 100 * s;
                    drawSegment(cx - 15 * s, hipY, cx - 20 * s, footY, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, hipY, cx + 20 * s, footY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#22d3ee'); // Torso
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    const pullPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                    const pull = pullPhase * 20 * s;
                    // Arms pulling back from high cable with elbow flare
                    const cableX = cx - 80 * s; const cableY = hipY - 100 * s;
                    const elbowX = cx - 30 * s - Math.abs(pull) + pullPhase * 5 * s; const handX = cx + 20 * s + pullPhase * 10 * s; const handY = hipY - 80 * s - pullPhase * 5 * s;

                    ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2 + pullPhase; ctx.beginPath(); ctx.moveTo(cableX, cableY); ctx.lineTo(handX, handY); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(cx, hipY - 60 * s); ctx.quadraticCurveTo(elbowX, hipY - 70 * s, handX, handY); ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 8 * s; ctx.stroke();
                    drawMuscle(cx, hipY - 60 * s, elbowX, hipY - 70 * s, 16 * s, true, "RHOMBOID", 'left');
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("CABLE FACE PULL", 20, 30);
                    // Actionable cue: Squeeze blades
                    if (pullPhase > 0.7) {
                        ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#22d3ee'; ctx.fillRect(cx - 20 * s, hipY - 70 * s, 40 * s, 20 * s);
                        ctx.fillStyle = '#000'; ctx.font = 'bold 8px sans-serif'; ctx.fillText("SQUEEZE", cx - 15 * s, hipY - 60 * s);
                        ctx.restore();
                    }
                }
                else if (type === 'inversion_hang') {
                    // ENHANCED: Dynamic hang with progression cues - hang, twist, leg swing/pull-up
                    const hangPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const hangDrop = hangPhase * 40 * s; // Drop from bar
                    const barY = cy - 100 * s;
                    drawEquipment('pullup_bar', cx, barY, 0);
                    const handY = barY + 10 * s; // Grip
                    const torsoY = handY + 20 * s + hangDrop;
                    const hipY = torsoY + 40 * s;
                    const kneeY = hipY + 30 * s + hangDrop * 0.5;
                    const footY = kneeY + 40 * s;
                    // Arms hanging straight
                    drawSegment(cx - 10 * s, handY, cx - 10 * s, torsoY, 8 * s, '#22d3ee');
                    drawSegment(cx + 10 * s, handY, cx + 10 * s, torsoY, 8 * s, '#22d3ee');
                    // Torso relaxed hang
                    ctx.beginPath(); ctx.moveTo(cx - 15 * s, torsoY); ctx.quadraticCurveTo(cx, torsoY + 10 * s, cx + 15 * s, torsoY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();
                    // Head
                    ctx.beginPath(); ctx.arc(cx, torsoY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    // Legs swinging for level 3 cue
                    const swingPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const legSwing = swingPhase * 20 * s - 10 * s;
                    const leftKneeX = cx - 15 * s + legSwing; const leftFootX = cx - 25 * s + legSwing * 1.5;
                    ctx.beginPath(); ctx.moveTo(cx - 10 * s, hipY); ctx.quadraticCurveTo(leftKneeX, kneeY, leftFootX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                    const rightKneeX = cx + 15 * s - legSwing; const rightFootX = cx + 25 * s - legSwing * 1.5;
                    ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(rightKneeX, kneeY, rightFootX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                    // Twist for level 2
                    if (hangPhase > 0.5) {
                        ctx.save(); ctx.translate(cx, torsoY); ctx.rotate(Math.sin(t * 2) * 0.2); ctx.beginPath(); ctx.arc(0, -15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill(); ctx.restore();
                        drawForce(cx, torsoY, Math.sin(t * 2) > 0 ? 1 : -1, 0, "TWIST");
                    }
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("INVERSION HANG & SWING", 20, 30);
                    // Actionable cue: Relax/ swing
                    drawForce(cx, footY, legSwing > 0 ? 1 : -1, 0, "LEG SWING");
                }
                else if (type === 'diaphragm_breath') {
                    const breathPhase = easeInOutCubic((Math.sin(t * 1.2) + 1) / 2);
                    const diaphragmDrop = breathPhase * 20 * s;
                    const bellyExpand = breathPhase * 25 * s;
                    const ribExpand = breathPhase * 15 * s;

                    const hipY = cy + 40 * s;
                    const chestY = cy - 20 * s;
                    const headY = cy - 80 * s;

                    // Body
                    drawSegment(cx - 15 * s, cy + 100 * s, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, cy + 100 * s, cx, hipY, 16 * s, '#475569');

                    // 360 expansion
                    ctx.save();
                    ctx.translate(cx, (hipY + chestY) / 2);
                    ctx.scale(1 + ribExpand / 50, 1 + bellyExpand / 80);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 30 * s, 50 * s, 0, 0, Math.PI * 2);
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 12 * s;
                    ctx.stroke();
                    ctx.restore();

                    // Diaphragm piston
                    ctx.beginPath();
                    ctx.ellipse(cx, hipY - diaphragmDrop, 25 * s, 10 * s, 0, 0, Math.PI);
                    ctx.fillStyle = '#22d3ee';
                    ctx.fill();

                    // Hydraulic glow
                    ctx.save();
                    ctx.globalAlpha = breathPhase * 0.6;
                    ctx.fillStyle = 'rgba(34,211,238,0.4)';
                    ctx.fillRect(cx - 20 * s, hipY - 40 * s, 40 * s, 80 * s);
                    ctx.restore();

                    // Head stable
                    ctx.beginPath(); ctx.arc(cx, headY, 18 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("DIAPHRAGMATIC BREATHING", 20, 20);

                    ctx.fillStyle = breathPhase > 0.5 ? '#f59e0b' : '#22d3ee';
                    ctx.font = `bold ${12 * s}px sans-serif`;
                    ctx.fillText(breathPhase > 0.5 ? "EXHALE — DIAPHRAGM RISES" : "INHALE — 360° EXPANSION", 20, 45);

                    ctx.fillStyle = '#22d3ee';
                    ctx.font = `bold ${10 * s}px sans-serif`;
                    ctx.fillText("HYDRAULIC CORE PRESSURE", 20, h - 40);
                }
                else if (type === 'contra_pull') {
                    // ENHANCED: Explosive snap with quick recoil, hip drive
                    const pullPhase = easeInOutCubic((Math.sin(t * 4) + 1) / 2); // Faster for snap
                    const pull = pullPhase * 40 * s;
                    const recoil = Math.sin(t * 8) * 5 * s * pullPhase; // Quick snap back
                    const hipY = cy + 20 * s; const footY = cy + 100 * s;
                    // Contralateral stance: Right hand pull, left foot back
                    drawSegment(cx + 10 * s, footY, cx + 5 * s, hipY, 16 * s, '#475569');
                    drawSegment(cx - 20 * s, footY, cx - 10 * s, hipY, 16 * s, '#22d3ee'); // Emphasize back leg
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    // Band from anchor to hand
                    const anchorX = cx - 60 * s; const anchorY = hipY - 50 * s;
                    const handX = cx + pull - recoil; const handY = hipY - 50 * s;
                    ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 4 + pullPhase * 2; ctx.beginPath(); ctx.moveTo(anchorX, anchorY); ctx.lineTo(handX, handY); ctx.stroke();
                    // Arm explosive pull with elbow bend
                    const elbowX = (cx + handX) / 2 + Math.sin(t * 6) * 3 * s; const elbowY = handY + 5 * s * pullPhase;
                    ctx.beginPath(); ctx.moveTo(cx, hipY - 50 * s); ctx.quadraticCurveTo(elbowX, elbowY, handX, handY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                    drawMuscle(cx, hipY - 50 * s, handX, handY, 16 * s, pullPhase > 0.7, "SNAP", 'right');
                    // Hip drive cue
                    if (pullPhase > 0.8) {
                        ctx.save(); ctx.globalAlpha = 0.7 + Math.sin(t * 10) * 0.3; drawForce(cx, hipY, 1, 0, "HIP DRIVE"); ctx.restore();
                    }
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("EXPLOSIVE CONTRA SNAP", 20, 30);
                    drawForce(handX, handY, -1, 0, "RECOIL");
                }
                else if (type === 'royal_coil') {
                    const phase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const coil = phase * 25 * s;
                    const hipY = cy + 20 * s;
                    const frontFootX = cx + 50 * s;
                    const backFootX = cx - 50 * s;
                    const headX = frontFootX + coil * 0.3;
                    const headY = hipY - 80 * s + coil * 0.2;

                    // Legs
                    drawSegment(cx, hipY, frontFootX, cy + 100 * s, 16 * s, '#22d3ee');
                    drawSegment(cx, hipY, backFootX, cy + 100 * s, 16 * s, '#475569');

                    // Torso coil
                    ctx.save();
                    ctx.translate(cx, hipY);
                    ctx.rotate(coil * 0.04);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(10 * s * Math.sin(t * 2), -40 * s, 0, -80 * s);
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 18 * s;
                    ctx.stroke();
                    ctx.restore();

                    // Head
                    ctx.beginPath(); ctx.arc(headX, headY, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ROYAL COIL PULSE", 20, 30);
                    drawForce(headX, headY, coil > 0 ? 1 : -1, 0, "TORSION LOAD");
                }
                else if (type === 'catapult_bounce') {
                    const bouncePhase = Math.abs(Math.sin(t * 6));
                    const bounce = bouncePhase * 12 * s;
                    const hipY = cy + 20 * s - bounce;
                    const footY = cy + 100 * s;

                    drawSegment(cx - 15 * s, footY, cx, hipY, 16 * s, '#22d3ee');
                    drawSegment(cx + 15 * s, footY, cx, hipY, 16 * s, '#22d3ee');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ELASTIC CATAPULT BOUNCE", 20, 30);
                    if (bouncePhase > 0.7) drawForce(cx, footY, 0, -1, "RECOIL");
                }
                else if (type === 'foot_flow') {
                    const phase = Math.sin(t * 3);
                    const pronation = phase * 10 * s;
                    const footY = cy + 80 * s;
                    const heelX = cx - 20 * s;
                    const toeX = cx + 30 * s + pronation;

                    ctx.beginPath();
                    ctx.moveTo(heelX, footY);
                    ctx.quadraticCurveTo(cx, footY - 15 * s - Math.abs(pronation), toeX, footY);
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 8 * s;
                    ctx.stroke();

                    drawSegment(cx, cy + 20 * s, cx, cy - 60 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, cy - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("PRONATION-SUPINATION FLOW", 20, 30);
                    drawForce(toeX, footY, phase > 0 ? 1 : -1, 0, "FOOT OPPOSITION");
                }
                else if (type === 'spiral_flow') {
                    const phase = Math.sin(t * 2);
                    const twist = phase * 30 * s;
                    const hipY = cy + 20 * s;

                    ctx.save();
                    ctx.translate(cx, hipY);
                    ctx.rotate(twist * 0.02);
                    drawSegment(-20 * s, 0, 20 * s, -80 * s, 16 * s, '#22d3ee');
                    ctx.restore();

                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SPIRAL LINE FLOW", 20, 30);
                }
                else if (type === 'spinal_wave_seg') {
                    const wave = Math.sin(t * 2) * 30 * s;
                    ctx.beginPath();
                    ctx.moveTo(cx - 40 * s, cy + 40 * s);
                    ctx.quadraticCurveTo(cx, cy - wave, cx + 40 * s, cy + 40 * s);
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 16 * s;
                    ctx.stroke();

                    ctx.beginPath(); ctx.arc(cx - 40 * s, cy + 35 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SPINAL WAVE SEGMENTATION", 20, 30);
                }
                else if (type === 'pos_sling_snap') {
                    const snapPhase = easeInOutCubic(Math.abs(Math.sin(t * 4)));
                    const snap = snapPhase * 40 * s;
                    const hipY = cy + 20 * s;

                    // Contralateral pull
                    drawSegment(cx + 20 * s, hipY - 50 * s, cx + snap, hipY - 50 * s, 10 * s, '#22d3ee');
                    drawSegment(cx - 20 * s, cy + 100 * s, cx - 10 * s, hipY, 16 * s, '#22d3ee');

                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("POSTERIOR OBLIQUE SLING SNAP", 20, 30);
                    if (snapPhase > 0.7) drawForce(cx + snap, hipY - 50 * s, 1, 0, "SNAP");
                }
                else {
                    // FALLBACK
                    const pulsePhase = easeInOutCubic(Math.abs(Math.sin(t * 4)));
                    const pulse = pulsePhase * 5 * s;
                    drawSegment(cx, cy - 50 * s - pulse, cx, cy + 50 * s, 4 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, cy - 60 * s - pulse, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText(type.toUpperCase().replace(/_/g, ' '), 20, 30);
                }
            } catch (e) { }
            if (playing) animationRef.current = requestAnimationFrame(loop);
        };
        loop();
        return () => {
            observer.disconnect(); // Stop listening to resize
            cancelAnimationFrame(animationRef.current);
        };
    }, [type, playing]);
    return <canvas ref={ref} className="relative w-full h-full bg-slate-950 rounded-lg shadow-inner overflow-hidden" />;
};


const getGrade = (score) => {
  if (typeof score !== 'number' || isNaN(score)) return 'C';
  if (score >= 95) return 'A+';
  if (score >= 90) return 'A';
  if (score >= 85) return 'A-';
  if (score >= 80) return 'B+';
  if (score >= 75) return 'B';
  if (score >= 70) return 'B-';
  if (score >= 65) return 'C+';
  if (score >= 60) return 'C';
  if (score >= 55) return 'C-';
  if (score >= 50) return 'D';
  return 'F';
};

// --- NEW: Progress Streak Component (Retention Booster) ---
const StreakTracker = ({ streakDays, onReset }) => (
    <div className="bg-gradient-to-r from-orange-500/20 to-red-500/20 border border-orange-500/30 rounded-lg p-4 mb-4">
        <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-2">
                <div className="text-orange-400 streak-flame"><Icons.Flame /></div>
                <span className="text-sm font-bold text-orange-300">Current Streak</span>
            </div>
            {streakDays > 0 && <button onClick={onReset} className="text-xs text-orange-400 hover:text-orange-300">Reset</button>}
        </div>
        <div className="text-2xl font-black text-orange-400">{streakDays}</div>
        <div className="text-xs text-orange-300 mt-1">Days Consecutive Scans</div>
        {streakDays >= 7 && <div className="text-xs text-emerald-400 mt-1 font-bold"> On Fire! Bonus Protocol Unlocked</div>}
    </div>
);

// --- NEW: Goal Tracker Component (Retention Booster) ---
const GoalTracker = ({ currentScore, targetScore, progress, onUpdateGoal, forecast }) => {
    const completion = (currentScore / targetScore) * 100;
    const onTrack = currentScore >= targetScore * 0.8;
    const pred = forecast?.predicted || currentScore + 10; // Fallback

    return (
        <div className="bg-slate-900/50 border border-slate-700 rounded-lg p-4 mb-4">
            <div className="flex justify-between items-center mb-2">
                <span className="text-sm font-bold text-slate-300">Goal: {targetScore}% Integrity</span>
                <button onClick={onUpdateGoal} className="text-xs text-cyan-400 hover:text-cyan-300">Edit</button>
            </div>
            <div className="w-full bg-slate-800 rounded-full h-2 overflow-hidden mb-2">
                <div className="goal-progress" style={{ width: `${completion}%` }} />
            </div>
            <div className="text-xs text-emerald-400 font-bold flex items-center gap-1">
                <Icons.ArrowUp /> Projected: {pred}% in {progress.duration} days {onTrack ? '🎉' : '💪 Keep Going!'}
            </div>
            <div className="text-xs text-slate-400 flex justify-between">
                <span>Current: {currentScore}%</span>
                <span>{Math.round(completion)}% to Goal</span>
            </div>
        </div>
    );
};

// ─────────────────────────────────────────────────────────────────────
// THE UPGRADED ELITE COACH — V84.0 KINETIC VOICE ENGINE
// ─────────────────────────────────────────────────────────────────────
const ProgramPlayer = ({ program, onClose, onFeedback }) => {
    const [step, setStep] = useState(0);
    const [playing, setPlaying] = useState(true);
    const [timeLeft, setTimeLeft] = useState(program[0]?.duration || 60);
    const [voiceOn, setVoiceOn] = useState(false);
    const [musicOn, setMusicOn] = useState(false);
    const [rated, setRated] = useState(false);
    const [completed, setCompleted] = useState(false);
    const [currentExercise, setCurrentExercise] = useState(program[0]);

    const lastSpokenId = useRef(null);
    const sessionCueIndex = useRef({});  // remembers which cue we used this session

    const toggleVoice = () => {
        const next = !voiceOn;
        if (!next) window.speechSynthesis.cancel();
        setVoiceOn(next);
    };

    useEffect(() => {
        if (!musicOn) return;
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const master = ctx.createGain(); master.gain.value = 0.05; master.connect(ctx.destination);
        const osc432 = ctx.createOscillator(); osc432.type = 'sine'; osc432.frequency.value = 432;
        const osc528 = ctx.createOscillator(); osc528.type = 'triangle'; osc528.frequency.value = 528;
        const g = ctx.createGain(); g.gain.value = 0.26;
        const f = ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 820;
        osc432.connect(master);
        osc528.connect(g).connect(f).connect(master);
        osc432.start(); osc528.start();
        return () => { osc432.stop(); osc528.stop(); ctx.close(); };
    }, [musicOn]);

    // --- THE NEW VOICE LOGIC ---
    useEffect(() => {
        if (!voiceOn || !currentExercise || currentExercise.id === lastSpokenId.current) return;
        lastSpokenId.current = currentExercise.id;

        window.speechSynthesis.cancel();

        const voices = window.speechSynthesis.getVoices();
        // Prioritize deep/authoritative voices
        const best = voices.find(v =>
            /Daniel|Alex|Fred|Google.*male|Microsoft.*David/i.test(v.name)
        ) || voices.find(v => v.lang.includes('en')) || voices[0];

        const speak = (text) => {
            const u = new SpeechSynthesisUtterance(text);
            u.voice = best;
            u.rate = 0.95; // Slightly slower for clarity
            u.pitch = 0.9; // Slightly deeper for authority
            u.volume = 1.0;
            window.speechSynthesis.speak(u);
        };

        // *** THE UPGRADED DATABASE ***
        const masterCoach = {
            // --- POSTURE & NECK ---
            meta_release: [
                "Find the groove between the big toe and the second toe.",
                "Press deep. This might be uncomfortable. Breathe into it.",
                "Soften the tissues. Allow the toes to splay apart. This releases the entire foot."
            ],
            ql_straddle: [
                "Wide stance. Hinge from the hips, do not round the back.",
                "As you lower the weight, fight the rotation. Keep your chest square to the floor.",
                "This is purely for the SI joint and QL. Feel the opposite side of your lower back fire to keep you stable."
            ],
            head_loading: [
                "Lengthen the spine. Imagine the ball is floating, and you are reaching up to keep contact.",
                "Chin tucked. Don't let the ribs flare. Breathe into the back of your neck. The deeper you breathe, the more you activate your core",
                "Axial decompression. Feel the multifidus muscles waking up along your spine."
            ],
            head_loading_march: [
                "Maintain the column. Head over hips over heels. No wobble.",
                "As you lift the knee, drive the crown of your head higher.",
                "Stabilize. The weight is teaching your spine how to resist gravity."
            ],

            // --- FEET & GAIT ---
            plantar_release: [
                "Find the trigger point near the heel. Apply pressure and breathe.",
                "Your foot is a sensory organ. Wake it up. Roll the inner arch.",
                "Melt the fascia. When this releases, your hamstring and glute will fire instantly."
            ],
            towel_curl: [
                "Spread the toes wide, then grip. Dominate the floor.",
                "Don't just curl the toes, pull the arch up. Build the windlass mechanism.",
                "This is intrinsic foot strength. It's the foundation of all athletic power."
            ],
            hyperarch: [
                "Heels suspended. Do not let them touch the ground. You are a spring.",
                "Pop. Pop. Pop. Minimal ground contact time. Stiffness is speed.",
                "Load the Achilles. Recoil through the glute. Stay elastic."
            ],

            // --- KNEES & LEGS ---
            split_squat: [
                "Full range. Let that front knee travel well past the toe. Restore the VMO.",
                "Back leg straight. Squeeze the glute on the trailing leg to open the hip flexor.",
                "Hamstring covers the calf at the bottom. Pressure proves the pipe."
            ],
            atg_split_squat: [
                "Drive the knee forward. Keep the heel flat if you can, or elevate it.",
                "This is structural integrity. You are bulletproofing the knee joint.",
                "Long range strength. Fight for depth."
            ],

            // --- FASCIA & BOUNCE ---
            body_bounce: [
                "Loose and rhythmic. Shake out the tension. Let the shoulders drop.",
                "Shift the hips left and right. Feel the lateral fascial line engaging.",
                "Lymphatic flush. Bounce on the balls of the feet. No muscle, just elasticity."
            ],
            body_wave: [
                "Initiate from the tailbone. Ripple up through the spine.",
                "Segmental motion. Vertebra by vertebra. Unlock the thoracic cage.",
                "Flow like water. Remove the rigid blocks in your back."
            ],

            // --- ROTATION & CORE ---
            trunk_twist: [
                "Hips and thoracic spine move together. Protect the lumbar.",
                "Let the arms swing dead weight. Centrifugal force drives the blood flow.",
                "Spiral line activation. Wring out the tension in the obliques."
            ],
            pallof: [
                "Resist rotation. Shoulders down. Ribs locked to pelvis.",
                "Anti-rotation is the prerequisite for power. Do not let the band win.",
                "Breathe behind the shield. Brace the core, but keep breathing."
            ],
            landmine_rotation: [
                "Pivot the foot! All power comes from the hip drive.",
                "Arms stay straight. The bar moves because your hips rotate.",
                "Transfer force from the ground, through the core, into the bar."
            ],
            band_twist: [
                "Explosive hips. Snap the rotation. Control the return.",
                "Load the posterior oblique sling. Lat to opposite glute.",
                "Power comes from the coil. Twist and drive."
            ],
            coiling: [
                "Side bend and rotate. Head over the load-bearing foot.",
                "Load the spring. Feel the tension wrap around your torso.",
                "The Royal Coil. Spiraling energy through the core. Maximize torsion."
            ],

            // --- SHOULDERS & ARMS ---
            arm_raise: [
                "Thumbs up, ribs down. Do not arch your back to get the arms up.",
                "True shoulder flexion. Reach for the ceiling, create space in the joint.",
                "Open the deep front arm line. Breathe into the armpits."
            ],
            alt_arm_raise: [
                "Contralateral rhythm. This is the gait cycle. Left arm, right leg.",
                "Reach high. Reciprocate. One side lengthens, the other shortens.",
                "Sync with your breath. Restore the cross-crawl pattern."
            ],
            chest_opener: [
                "Dynamic opening. Squeeze the shoulder blades together at the back.",
                "Open the front line. Undo the sitting posture.",
                "Expand the ribcage. Big inhale as you open."
            ],
            trap_release: [
                "Lean into the wall. Find the knot in the upper trap.",
                "Pin the tissue, then move the arm. Floss the nerve.",
                "Drop the shoulder. Stop wearing your shoulders as earrings."
            ],
            standing_pull: [
                "Retract the scapula first. Pull with the back, not the arms.",
                "Squeeze the mid-back. Lower trapezius activation.",
                "Postural reset. Pull the shoulders back and down."
            ],
            contra_pull: [
                "Step back and pull. Connect the right hand to the left foot.",
                "Feel the X pattern across your back. That is the posterior oblique sling.",
                "Tension through the torso. Do not let the spine twist."
            ],

            // --- POWER & INTEGRATION ---
            med_ball_power: [
                "Reach high, slam hard! Use your whole bodyweight.",
                "Flex at the hips. Drive the ball through the floor.",
                "Explosive flexion. Turn potential energy into kinetic power."
            ],
            spinal_wave: [
                "Roll down, chin to chest. Roll up, stacking the spine.",
                "Articulate every joint. If a section feels stuck, spend time there.",
                "Hydrate the discs. Movement is the pump."
            ],
            diaphragm_breath: [
                "Breathe into the belly, not the chest. 360 degree expansion.",
                "Intra-abdominal pressure. This is your internal weight belt.",
                "Calm the nervous system. Slow, nasal inhale. Long exhale."
            ],
            inversion_hang: [
                "Let gravity do the work. create space between the vertebrae.",
                "Relax the lower back. Let the hips heavy.",
                "Decompression. Undo the compressive forces of the day."
            ]
        };

        const cues = masterCoach[currentExercise.id] || [
            "Focus on quality movement.",
            "Control the range of motion.",
            "Breathe rhythmically."
        ];

        // Cycle through cues based on session history
        const index = (sessionCueIndex.current[currentExercise.id] || 0) % cues.length;
        sessionCueIndex.current[currentExercise.id] = index + 1;
        const line = cues[index];

        if (step === 0) {
            speak("Beginning Protocol. Let's go.");
            setTimeout(() => speak(line), 2500);
        } else {
            speak(line);
        }

    }, [voiceOn, currentExercise, step]);

    useEffect(() => { lastSpokenId.current = null; sessionCueIndex.current = {}; }, [step]);

    // Standard logic
    useEffect(() => {
        setCurrentExercise(program[step]);
        setRated(false);
        if (program[step]) setTimeLeft(program[step].duration);
        setPlaying(true);
    }, [step, program]);

    useEffect(() => {
        let i;
        if (playing && timeLeft > 0 && !completed)
            i = setInterval(() => setTimeLeft(t => t - 1), 1000);
        else if (timeLeft === 0) setPlaying(false);
        return () => clearInterval(i);
    }, [playing, timeLeft, completed]);

    const changeLevel = (dir) => {
        const idx = currentExercise.currentLevelIdx + dir;
        if (idx >= 0 && idx < currentExercise.allLevels.length) {
            setCurrentExercise({ ...currentExercise, ...currentExercise.allLevels[idx], currentLevelIdx: idx });
        }
    };

    const submitFeedback = (rating) => {
        onFeedback(currentExercise.id, currentExercise.currentLevelIdx, rating);
        setRated(true);
        setTimeout(() => {
            if (step < program.length - 1) setStep(s => s + 1);
            else { setCompleted(true); setPlaying(false); }
        }, 900);
    };

    const openVideo = () => {
        const q = currentExercise.videoSearch?.startsWith('http')
            ? currentExercise.videoSearch
            : `https://www.youtube.com/results?search_query=${encodeURIComponent(currentExercise.videoSearch || currentExercise.name)}`;
        window.open(q, '_blank');
    };

    if (completed) {
        return (
            <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center p-4 backdrop-blur-md no-print animate-popIn">
                <div className="bg-slate-900 w-full max-w-lg rounded-2xl border border-slate-700 shadow-2xl p-8 flex flex-col items-center text-center">
                    <div className="w-20 h-20 bg-emerald-500/20 rounded-full flex items-center justify-center mb-6">
                        <svg className="w-10 h-10 text-emerald-400" fill="none" stroke="currentColor" strokeWidth="3" viewBox="0 0 24 24"><path d="M20 6 9 17l-5-5" /></svg>
                    </div>
                    <h2 className="text-3xl font-black text-white mb-2">SESSION COMPLETE</h2>
                    <p className="text-slate-400 mb-8">Your body just changed forever.</p>
                    <button onClick={onClose} className="btn-primary w-full">RETURN</button>
                </div>
            </div>
        );
    }

    return (
        <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center p-4 backdrop-blur-md no-print">
            <div className="bg-slate-900 w-full max-w-6xl h-[90vh] rounded-2xl border border-slate-700 shadow-2xl flex flex-col md:flex-row overflow-hidden">
                {/* Canvas */}
                <div className="w-full md:w-2/3 bg-black flex flex-col relative border-r border-slate-800">
                    <div className="absolute top-4 left-4 z-10 pointer-events-none">
                        <span className="text-[10px] font-bold px-2 py-1 rounded border bg-slate-800 text-white border-slate-600">
                            {currentExercise.baseTitle ? `FLOW STEP ${currentExercise.currentLevelIdx + 1}` : `LEVEL ${currentExercise.currentLevelIdx + 1}`}
                        </span>                        </div>
                    <div className="absolute top-4 right-4 z-10 flex gap-2 pointer-events-auto">
                        <button onClick={toggleVoice} className={`px-4 py-1.5 text-[10px] font-bold rounded flex items-center gap-2 shadow-lg transition-all ${voiceOn ? 'bg-cyan-600 text-white' : 'bg-slate-800 text-slate-400 border border-slate-600'}`}>
                            <Icons.Speaker /> COACH {voiceOn ? 'ON' : 'OFF'}
                        </button>
                        <button onClick={() => setMusicOn(m => !m)} className={`px-4 py-1.5 text-[10px] font-bold rounded flex items-center gap-2 shadow-lg transition-all ${musicOn ? 'bg-green-600 text-white' : 'bg-slate-800 text-slate-400 border border-slate-600'}`}>
                            <Icons.Music /> 432·528Hz
                        </button>
                        <button onClick={openVideo} className="px-3 py-1 bg-red-600 hover:bg-red-500 text-white text-[10px] font-bold rounded flex items-center gap-2 shadow-lg shadow-red-900/50 transition-all">
                            <Icons.Video /> TUTORIAL
                        </button>
                    </div>
                    <div className="flex-1 relative">
                        <KineticCanvas type={currentExercise.demoType} playing={playing} />
                        <div className="absolute bottom-8 left-1/2 -translate-x-1/2 text-5xl font-black text-white font-mono pointer-events-none">
                            {Math.floor(timeLeft / 60)}:{(timeLeft % 60).toString().padStart(2, '0')}
                        </div>
                    </div>
                    <div className="h-16 bg-slate-950 border-t border-slate-800 flex items-center px-6 justify-between">
                        <button onClick={() => setPlaying(p => !p)} className="text-white hover:text-cyan-400">
                            {playing ? <Icons.Pause /> : <Icons.Play />}
                        </button>
                        <div className="flex-1 flex items-center justify-center gap-8">
    <button 
        onClick={() => setStep(Math.max(0, step - 1))}
        disabled={step === 0}
        className="px-8 py-4 bg-slate-800 hover:bg-slate-700 disabled:opacity-50 rounded-xl font-black text-xl uppercase tracking-wider text-white transition-all shadow-lg"
    >
        ← PREV
    </button>

    <div className="text-4xl font-black text-cyan-400">
        {step + 1} / {program.length}
    </div>

    <button 
        onClick={() => setStep(Math.min(program.length - 1, step + 1))}
        disabled={step === program.length - 1}
        className="px-8 py-4 bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 disabled:opacity-50 rounded-xl font-black text-xl uppercase tracking-wider text-white transition-all shadow-lg shadow-cyan-900/50"
    >
        NEXT →
    </button>
</div>
                    </div>
                </div>

                {/* RIGHT PANEL */}
                <div className="w-full md:w-1/3 bg-slate-950 flex flex-col p-6 overflow-y-auto">
                    <div className="flex justify-between items-center mb-6"><h2 className="text-lg font-bold text-white flex gap-2"><Icons.List /> Protocol V84.0</h2><button onClick={onClose} className="text-slate-400 hover:text-white"><Icons.Close /></button></div>
                    <div>
                        <div className="mb-6">
    <h3 className="text-2xl font-black text-white mb-3 text-center">
        {currentExercise.baseTitle || currentExercise.name}
    </h3>
    {program.length > 1 && (
        <p className="text-center text-lg text-cyan-400 font-bold">
            Step {step + 1} of {program.length}
        </p>
    )}
                            <p className="text-sm text-cyan-400 mb-4">
                                {currentExercise.baseTitle && `Step ${step + 1} of ${program.length}`}
                            </p>                            </div>
                        <div className="flex items-center gap-2 mb-4">
                            <button onClick={() => changeLevel(-1)} disabled={currentExercise.currentLevelIdx === 0} className="text-[10px] bg-slate-800 hover:bg-slate-700 disabled:opacity-30 px-2 py-1 rounded border border-slate-700 text-slate-300 flex items-center gap-1"><Icons.ArrowDown /> REGRESS</button>
                            <div className="flex gap-1">
                                {currentExercise.allLevels.map((_, idx) => (
                                    <div key={idx} className={`w-2 h-2 rounded-full ${idx === currentExercise.currentLevelIdx ? 'bg-cyan-400' : 'bg-slate-800'}`}></div>
                                ))}
                            </div>
                            <button onClick={() => changeLevel(1)} disabled={currentExercise.currentLevelIdx === currentExercise.allLevels.length - 1} className="text-[10px] bg-slate-800 hover:bg-slate-700 disabled:opacity-30 px-2 py-1 rounded border border-slate-700 text-slate-300 flex items-center gap-1">PROGRESS <Icons.ArrowUp /></button>
                        </div>
                        <div className="flex flex-wrap gap-2 mb-4">
                            <span className="text-xs bg-slate-800 px-2 py-1 rounded text-cyan-400 border border-slate-700">{currentExercise.duration}s</span>
                            <span className="text-xs bg-emerald-900/30 px-2 py-1 rounded text-emerald-400 border border-emerald-900/50">{currentExercise.reason}</span>
                        </div>
                        <p className="text-sm text-slate-400 leading-relaxed mb-4">{currentExercise.desc}</p>
                        <h4 className="text-xs font-bold text-slate-500 uppercase mb-2">Technique</h4>
                        <ul className="space-y-2 mb-6">{currentExercise.steps.map((s, i) => <li key={i} className="text-sm text-slate-300 flex gap-2"><span className="text-cyan-500 font-bold">{i + 1}.</span>{s}</li>)}</ul>
                        <div className="bg-slate-900 border border-slate-800 p-4 rounded-xl mb-4">
                            <h4 className="text-[10px] font-bold text-slate-500 uppercase mb-3 text-center">How was this set?</h4>
                            {rated ? (
                                <div className="text-center text-xs text-emerald-400 font-bold py-2 animate-pulse">Feedback Saved</div>
                            ) : (
                                <div className="flex gap-2">
                                    <button onClick={() => submitFeedback('easy')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-emerald-900/30 border border-slate-700 hover:border-emerald-500/50 text-[10px] font-bold text-slate-300 hover:text-emerald-400 transition-all">TOO EASY</button>
                                    <button onClick={() => submitFeedback('good')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-blue-900/30 border border-slate-700 hover:border-blue-500/50 text-[10px] font-bold text-slate-300 hover:text-blue-400 transition-all">JUST RIGHT</button>
                                    <button onClick={() => submitFeedback('hard')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-red-900/30 border border-slate-700 hover:border-red-500/50 text-[10px] font-bold text-slate-300 hover:text-red-400 transition-all">TOO HARD</button>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="mt-auto pt-6 border-t border-slate-800">
                        <h4 className="text-xs font-bold text-slate-500 uppercase mb-3">Session Roadmap</h4>
                        <div className="space-y-2">{program.map((p, idx) => <div key={idx} onClick={() => setStep(idx)} className={`text-xs p-2 rounded cursor-pointer flex justify-between ${idx === step ? 'bg-cyan-900/20 text-cyan-400' : 'text-slate-500'}`}><span>{idx + 1}. {p.baseTitle}</span>
                            {p.reason === "Universal Primer" && <span className="text-[9px] font-bold text-emerald-400 bg-emerald-900/30 px-1 rounded ml-2">UNIVERSAL</span>}
                            {p.reason.includes("Fixes Knee") && <span className="text-[9px] font-bold text-red-400 bg-red-900/30 px-1 rounded ml-2">KNEE RELIEF</span>}
                            {p.reason.includes("Spinal") && <span className="text-[9px] font-bold text-yellow-400 bg-yellow-900/30 px-1 rounded ml-2">BACK RELIEF</span>}
                            <span className="opacity-50 ml-auto">LVL {p.currentLevelIdx + 1}</span></div>)}</div>
			    
                    </div>
                </div>
            </div>
        </div>
    );
};
const TrendGraph = ({ history }) => {
    if (history.length < 2) {
        return (
            <div className="mb-6 p-4 bg-slate-900/30 rounded text-center text-xs text-slate-500">
                Scan again to see trend
            </div>
        );
    }

    // FIX 1: Limit to strictly the last 20 items to prevent overcrowding
    const recentHistory = history.slice(0, 20).reverse(); // Reverse so oldest is left, newest is right
    const scores = recentHistory.map(h => h.score);

    const h = 50, w = 280;
    const points = scores.map((s, i) => {
        const x = (i / (scores.length - 1)) * w;
        const y = h - (s / 100) * h;
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="mb-6">
            <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">
                Recovery Trend (Last {scores.length})
            </div>
            <div className="h-[50px] w-full bg-slate-900/30 rounded relative overflow-hidden">
                <svg className="w-full h-full" viewBox={`0 0 ${w} ${h}`} preserveAspectRatio="none">
                    <polyline points={points} fill="none" stroke="#22d3ee" strokeWidth="2" vectorEffect="non-scaling-stroke" />
                    {scores.map((s, i) => (
                        <circle 
                            key={i} 
                            cx={(i / (scores.length - 1)) * w} 
                            cy={h - (s / 100) * h} 
                            r="3" 
                            fill="#0f172a" 
                            stroke="#22d3ee" 
                            strokeWidth="2" 
                        />
                    ))}
                </svg>
            </div>
        </div>
    );
};

const FascialLineTrends = ({ history }) => {
    if (history.length < 2) return null;
    const lines = [
        { key: 'head', name: 'Superficial Back Line', color: 'from-purple-500 to-pink-500' },
        { key: 'shoulders', name: 'Deep Front Arm Line', color: 'from-blue-500 to-cyan-500' },
        { key: 'spine', name: 'Deep Front Line', color: 'from-emerald-500 to-teal-500' },
        { key: 'hip', name: 'Lateral Line', color: 'from-orange-500 to-amber-500' },
        { key: 'gait', name: 'Spiral Line', color: 'from-red-500 to-rose-500' }
    ];
    const latest = history[0];
    const previous = history[1];
    return (
        <div className="mt-8 animate-popIn">
            <h3 className="text-lg font-black text-cyan-400 uppercase tracking-widest text-center mb-6">
                Fascial Line Trends
            </h3>
            <div className="space-y-4">
                {lines.map((line, idx) => {
                    const current = latest[line.key]?.val || 0;
                    const prev = previous[line.key]?.val || 0;
                    const delta = current - prev;
                    const isPositive = delta >= 0;
                    // Mini sparkline data
                    const data = history.slice(0, 10).reverse().map(h => h[line.key]?.val || 50);
                    const max = Math.max(...data, 100);
                    const min = Math.min(...data, 0);
                    const range = max - min || 1;
                    const points = data.map((v, i) => {
    const x = (i / (data.length - 1)) * 100;
    const y = 100 - ((v - min) / range) * 100;
    return `${x},${y}`;
}).join(' ');
                    
                    // Unique ID for gradients to prevent conflict
                    const gradId = `gradient-${line.key}`;

                    return (
                        <div key={line.key} className="bg-slate-900/70 border border-slate-700 rounded-2xl p-5 hover:border-cyan-500/50 transition-all">
                            <div className="flex justify-between items-start mb-3">
                                <div>
                                    <div className="text-sm font-bold text-white">{line.name}</div>
                                    <div className="text-xs text-slate-400 mt-1">
                                        Current: <span className="font-mono text-cyan-300">{current}%</span>
                                    </div>
                                </div>
                                <div className={`text-2xl font-black ${isPositive ? 'text-emerald-400' : 'text-red-400'}`}>
                                    {isPositive ? '+' : ''}{delta.toFixed(1)}
                                </div>
                            </div>
                            <div className="relative h-16 bg-slate-950/50 rounded-xl overflow-hidden">
                                <svg className="absolute inset-0 w-full h-full" preserveAspectRatio="none">
                                    <defs>
                                        <linearGradient id={gradId} x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" stopColor="#22d3ee" stopOpacity="0.8" />
                                            <stop offset="100%" stopColor="#a78bfa" stopOpacity="0.8" />
                                        </linearGradient>
                                    </defs>
                                    <polyline
                                        fill="none"
                                        stroke={`url(#${gradId})`}
                                        strokeWidth="3"
                                        points={points}
                                        vectorEffect="non-scaling-stroke"
                                        className="drop-shadow-lg"
                                    />
                                </svg>
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

const ReaderMode = ({ item, onClose }) => {
    // Force scroll to top on mount
    const scrollRef = useRef(null);
    useEffect(() => {
        if (scrollRef.current) scrollRef.current.scrollTop = 0;
    }, []);

    return (
        <div ref={scrollRef} className="fixed inset-0 bg-slate-950 z-50 overflow-y-auto no-print flex justify-center">
            <div className="w-full max-w-3xl bg-slate-900 min-h-screen border-x border-slate-800 shadow-2xl relative">
                <button onClick={onClose} className="fixed top-6 right-6 p-3 bg-slate-800 hover:bg-slate-700 rounded-full text-white shadow-lg z-50"><Icons.Close /></button>
                <div className={`h-64 w-full bg-gradient-to-br ${item.color} flex items-end p-8`}>
                    <div>
                        <div className="text-xs font-bold text-white/80 uppercase tracking-widest mb-2">MASTERCLASS</div>
                        <h1 className="text-4xl font-black text-white tracking-tighter mb-2">{item.title}</h1>
                        <p className="text-lg text-white/90 font-medium">{item.subtitle}</p>
                    </div>
                </div>
                <div className="p-8 md:p-12 space-y-8">
                    <div className="flex gap-4 border-b border-slate-800 pb-8">
                        <div className="w-12 h-12 rounded-full bg-slate-800 flex items-center justify-center text-xl">🎓</div>
                        <div>
                            <div className="text-sm font-bold text-white"> {item.author}</div>
                        </div>
                    </div>
                    <div className="prose prose-invert max-w-none">
                        <p className="text-lg text-slate-300 leading-relaxed font-light border-l-4 border-cyan-500 pl-4 mb-8">{item.desc}</p>
                        <h3 className="text-xl font-bold text-white mb-4">Core Principles</h3>
                        {item.sections && item.sections.map((sec, i) => (
                            <div key={i} className="mb-8">
                                <h4 className="text-lg font-bold text-cyan-400 mb-2">{sec.head}</h4>
                                <p className="text-slate-300 leading-relaxed">{sec.body}</p>
                            </div>
                        ))}
                        <h3 className="text-xl font-bold text-white mb-4">Key Terminology</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {item.key_terms && item.key_terms.map((term, i) => (
                                <div key={i} className="bg-slate-950 p-4 rounded border border-slate-800 text-sm text-cyan-400 font-mono">{term}</div>
                            ))}
                        </div>
                    </div>
                    <div className="pt-12 text-center">
                        <button onClick={onClose} className="btn-primary w-auto inline-flex">RETURN TO DASHBOARD</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

const KnowledgeBase = ({ onOpen }) => (
    <div className="p-8 space-y-6 pb-24">
        <div className="border-b border-slate-800 pb-4 mb-6">
            <h2 className="text-2xl font-black text-white tracking-tighter mb-2">MASTERING <span className="text-cyan-500">MOVEMENT</span></h2>
        </div>
        <div className="grid grid-cols-1 gap-4">
            {ACADEMY.map((item, i) => (
                <div key={i} onClick={() => onOpen(item)} className="bg-slate-900/50 border border-slate-700 rounded-xl p-6 hover:border-cyan-500/50 transition-all group cursor-pointer hover:bg-slate-800/50">
                    <div className={`h-1 w-10 rounded-full bg-gradient-to-r ${item.color} mb-4`}></div>
                    <h3 className="text-lg font-bold text-white mb-1 group-hover:text-cyan-400 transition-colors">{item.title}</h3>
                    <div className="text-xs font-bold text-slate-400 uppercase mb-3">{item.subtitle}</div>
                    <p className="text-sm text-slate-400 leading-relaxed line-clamp-2">{item.desc}</p>
                    <div className="mt-4 text-xs font-bold text-cyan-600 flex items-center gap-1">READ MASTERCLASS <Icons.Video /></div>
                </div>
            ))}
        </div>
    </div>
);

// --- NEW: Goal Setter Modal ---
const GoalSetter = ({ currentGoal, onSave, onClose }) => {
    const [target, setTarget] = useState(currentGoal.target || 80);
    const [duration, setDuration] = useState(currentGoal.duration || 30);
    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
            <div className="bg-slate-900 w-full max-w-md rounded-xl border border-slate-700 p-6">
                <h3 className="text-lg font-bold text-white mb-4">Set Your Goal</h3>
                <div className="space-y-4">
                    <div>
                        <label className="text-xs text-slate-400 mb-1 block">Target Score (%)</label>
                        <input type="range" min="50" max="100" value={target} onChange={(e) => setTarget(e.target.value)} className="w-full" />
                        <div className="text-sm text-white">{target}%</div>
                    </div>
                    <div>
                        <label className="text-xs text-slate-400 mb-1 block">Duration (Days)</label>
                        <input type="number" min="7" max="90" value={duration} onChange={(e) => setDuration(e.target.value)} className="w-full bg-slate-800 border border-slate-700 rounded px-3 py-2 text-white text-sm" />
                    </div>
                    <div className="flex gap-2 pt-4">
                        <button onClick={onClose} className="flex-1 py-2 bg-slate-800 hover:bg-slate-700 rounded text-white text-sm">Cancel</button>
                        <button onClick={() => onSave({ target, duration })} className="flex-1 py-2 bg-cyan-600 hover:bg-cyan-500 rounded text-white text-sm font-bold">Save Goal</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

// --- NEW: Share Report Component ---
const ShareReport = ({ audit, symptoms, onClose }) => {
    return (
        <div className="fixed inset-0 bg-black/90 z-50 flex items-center justify-center p-4 backdrop-blur-md">
            <div className="bg-gradient-to-br from-slate-900 to-slate-950 p-1 rounded-2xl border border-cyan-500/50 shadow-[0_0_50px_rgba(34,211,238,0.2)]">
                {/* THE CARD TO SCREENSHOT */}
                <div className="bg-slate-900 rounded-xl p-8 w-full max-w-sm text-center relative overflow-hidden">
                    
                    {/* Background Glow */}
                    <div className="absolute top-0 left-0 w-full h-32 bg-gradient-to-b from-cyan-900/20 to-transparent pointer-events-none"></div>

                    <div className="relative z-10">
    <div className="text-xs font-black text-cyan-400 tracking-[0.3em] mb-6">BIOMECHANICS REPORT</div>
    
    {/* VIRAL HOOK: SPLIT SCORE VIEW */}
<div className="flex justify-center items-center gap-6 mb-8">
    <div className="text-center">
        <div className="text-5xl font-black text-white">
            {audit.score}<span className="text-2xl">%</span>
        </div>
        <div className="text-sm text-slate-400 uppercase">Structural Integrity</div>
        
        <div className="text-4xl font-black text-red-400 mt-4">
            {audit.bioAge} <span className="text-lg">yrs</span>
        </div>
        <div className="text-sm text-slate-400 uppercase">Biological Age</div>
        
        <div className="w-32 mx-auto my-6">
            <BioAvatar audit={audit} symptoms={symptoms} />
        </div>
        
        <div className="w-24 h-24 bg-white rounded-xl mx-auto mb-4 flex items-center justify-center">
            <div className="text-black font-black text-center text-xs">QR to App</div>
        </div>
    </div>
</div>

    {/* Reuse the BioAvatar Component! */}

                        <div className="grid grid-cols-2 gap-4 text-xs font-bold text-slate-500 mb-6">
                            <div className="bg-slate-800/50 p-2 rounded">HEAD: {audit.head.grade}</div>
                            <div className="bg-slate-800/50 p-2 rounded">SPINE: {audit.spine.grade}</div>
                            <div className="bg-slate-800/50 p-2 rounded">HIPS: {audit.hip.grade}</div>
                            <div className="bg-slate-800/50 p-2 rounded">GAIT: {audit.gait.grade}</div>
                        </div>

                        <div className="text-[10px] text-slate-600 mb-4">Analyzed by Bio-Metric Pro Neural Core</div>
                        
                        <button onClick={onClose} className="w-full py-3 bg-white text-black font-black rounded-lg hover:scale-105 transition-transform">
                            DONE / SCREENSHOT THIS
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};

// --- UPGRADED DASHBOARD (V86) ---
const ClinicalDashboard = ({ audit, onClose }) => {
    // State to toggle views
    const [mode, setMode] = useState('metrics'); // 'metrics' or '3d'
    
    // Safety Fallbacks to prevent crashes if data is missing
    const score = audit?.score || 0;
    const headVal = audit?.head?.val || 0;
    const hipVal = audit?.hip?.val || 0;
    const gaitVal = audit?.gait?.val || 0;

    // Derived Physics
    const forceLeak = 100 - score;
    const shearForce = Math.max(0, 100 - headVal);

    // Metrics List
    const metrics = [
        { label: "Kinetic Efficiency", val: score, desc: "Force transfer coeff.", color: "bg-emerald-500" },
        { label: "Axial Shear Load", val: shearForce, desc: "Spinal torque risk", color: "bg-red-500" },
        { label: "Pelvic Stability", val: hipVal, desc: "Lumbo-pelvic control", color: "bg-blue-500" },
        { label: "Gait Recoil", val: gaitVal, desc: "Fascial elasticity", color: "bg-amber-500" }
    ];

    return (
        <div className="fixed inset-0 bg-black/95 z-[90] flex items-center justify-center p-4 backdrop-blur-xl animate-popIn">
            <div className="bg-slate-900 w-full max-w-5xl h-[85vh] rounded-2xl border border-slate-700 shadow-2xl flex flex-col overflow-hidden">
                
                {/* Header with Toggle */}
                <div className="p-6 border-b border-slate-800 flex justify-between items-center bg-slate-950">
                    <div className="flex items-center gap-4">
                        <div className="w-3 h-12 bg-cyan-500 rounded-sm"></div>
                        <div>
                            <h2 className="text-2xl font-black text-white uppercase tracking-tighter">Clinical Kinetics</h2>
                            <div className="flex gap-2 mt-1">
                                <button 
                                    onClick={() => setMode('metrics')}
                                    className={`text-[10px] font-bold px-3 py-1 rounded transition-colors ${mode === 'metrics' ? 'bg-cyan-900 text-cyan-400' : 'text-slate-500 hover:text-white'}`}
                                >
                                    DATA VIEW
                                </button>
                                <button 
                                    onClick={() => setMode('3d')}
                                    className={`text-[10px] font-bold px-3 py-1 rounded transition-colors ${mode === '3d' ? 'bg-purple-900 text-purple-400' : 'text-slate-500 hover:text-white'}`}
                                >
                                    3D HOLODECK
                                </button>
                            </div>
                        </div>
                    </div>
                    <button onClick={onClose} className="p-2 hover:bg-slate-800 rounded-full text-slate-400 hover:text-white"><Icons.Close /></button>
                </div>

                {/* Content Area */}
                <div className="flex-1 overflow-hidden relative">
                    {mode === 'metrics' ? (
                        <div className="h-full overflow-y-auto p-8 grid grid-cols-1 lg:grid-cols-2 gap-8">
                            {/* Visual Bars */}
                            <div className="space-y-6">
                                <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl">
                                    <h3 className="text-sm font-bold text-slate-400 uppercase mb-6 flex items-center gap-2"><Icons.Layers /> Load Distribution</h3>
                                    <div className="space-y-4">
                                        {metrics.map((m, i) => (
                                            <div key={i}>
                                                <div className="flex justify-between text-xs mb-1">
                                                    <span className="text-slate-300 font-bold">{m.label}</span>
                                                    <span className="text-slate-400 font-mono">{m.val}%</span>
                                                </div>
                                                <div className="w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                                                    <div className={`h-full ${m.color}`} style={{ width: `${m.val}%` }}></div>
                                                </div>
                                                <div className="text-[10px] text-slate-500 mt-1">{m.desc}</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>

                            {/* Text Report */}
                            <div className="bg-slate-950 p-6 rounded-xl border border-slate-800 font-mono text-xs text-slate-300 leading-loose">
                                <p className="mb-4 text-cyan-500">>> SYSTEM DIAGNOSTICS...</p>
                                <p>FORCE LEAKAGE: <span className="text-red-400">{forceLeak}%</span></p>
                                <p>STRUCTURAL AGE: <span className="text-white">{audit.bioAge} YEARS</span></p>
                                <div className="h-px bg-slate-800 my-4"></div>
                                <p className="text-slate-500">OPTIMIZATION:</p>
                                <p className="text-white font-bold">INITIATE PHASE {score > 80 ? '3' : '1'} PROTOCOLS.</p>
                            </div>
                        </div>
                    ) : (
                        /* 3D VIEW MODE */
                        <div className="h-full w-full p-4 flex flex-col md:flex-row gap-4 bg-slate-950">
                            <div className="flex-1 h-full min-h-[400px]">
                                {audit.landmarks3D ? (
                                    <BioArchitect3D landmarks={audit.landmarks3D} width={600} height={600} />
                                ) : (
                                    <div className="w-full h-full flex flex-col items-center justify-center text-slate-500 bg-black rounded-xl border border-slate-800 border-dashed">
                                        <Icons.Scan className="w-12 h-12 mb-4 opacity-50" />
                                        <p>NO VOLUMETRIC DATA.</p>
                                        <p className="text-xs mt-2 text-slate-600">Please perform a new scan to capture 3D depth.</p>
                                    </div>
                                )}
                            </div>
                            
                            {/* 3D Sidebar */}
                            <div className="w-full md:w-72 bg-slate-900 border-l border-slate-700 p-6">
                                <h3 className="text-purple-400 font-black text-sm mb-4 uppercase tracking-widest flex items-center gap-2">
                                    Volumetric Analysis
                                </h3>
                                <p className="text-xs text-slate-400 mb-6 leading-relaxed">
                                    Visualizing Z-axis (depth) data to detect hidden rotational torque.
                                </p>
                                <div className="p-4 bg-purple-900/10 border border-purple-500/20 rounded-lg mb-4">
                                    <div className="text-xs font-bold text-white mb-1">Rotational Stability</div>
                                    <div className="text-2xl font-black text-purple-400">{audit.landmarks3D ? "Active" : "N/A"}</div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

// --- CAMERA COMPONENT ---
const CameraCapture = ({ onCapture, onClose }) => {
    const videoRef = useRef(null);
    const [timer, setTimer] = useState(null);
    const [cameraError, setCameraError] = useState(false);

    useEffect(() => {
        let stream = null;
        navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
            stream = s;
            if (videoRef.current) videoRef.current.srcObject = stream;
        }).catch(err => { console.error(err); onClose(); });
        return () => { if (stream) stream.getTracks().forEach(t => t.stop()); };
    }, []);

    const trigger = () => setTimer(3);

    useEffect(() => {
        if (timer === null) return;
        if (timer > 0) setTimeout(() => setTimer(timer - 1), 1000);
        else {
            const cvs = document.createElement('canvas');
            cvs.width = videoRef.current.videoWidth;
            cvs.height = videoRef.current.videoHeight;
            // Flip horizontally to match mirror view
            const ctx = cvs.getContext('2d');
            ctx.translate(cvs.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(videoRef.current, 0, 0);
            onCapture(cvs.toDataURL('image/jpeg'));
        }
    }, [timer]);

    return (
        <div className="fixed inset-0 bg-black/95 z-[60] flex flex-col items-center justify-center p-4 animate-popIn">
            <div className="relative w-full max-w-lg bg-slate-900 border border-slate-700 rounded-2xl overflow-hidden shadow-2xl">
                <video ref={videoRef} autoPlay playsInline className="w-full bg-black transform scale-x-[-1]" />
                {timer > 0 && <div className="absolute inset-0 flex items-center justify-center bg-black/40 text-9xl font-black text-white animate-ping backdrop-blur-sm">{timer}</div>}
                <div className="absolute bottom-6 left-0 right-0 flex justify-center gap-4">
                    <button onClick={onClose} className="px-6 py-2 bg-slate-800 text-slate-300 rounded-full font-bold border border-slate-600 hover:bg-slate-700 transition-all">CANCEL</button>
                    <button onClick={trigger} className="px-6 py-2 bg-cyan-600 text-white rounded-full font-bold shadow-lg flex items-center gap-2 hover:bg-cyan-500 transition-all"><Icons.Camera /> {timer ? 'CAPTURING...' : 'CAPTURE (3s)'}</button>
                </div>
            </div>
        </div>
    );
};



const App = () => {

    const viewportRef = useRef(null);
    const rightPanelRef = useRef(null);

    const [uploads, setUploads] = useState({ front: null, side: null, back: null });
    const [liveScore, setLiveScore] = useState(null);
    const [lastAlertScore, setLastAlertScore] = useState(100);
    const [isModelLoading, setIsModelLoading] = useState(false);
    const [cameraActive, setCameraActive] = useState(null);
    const [system, setSystem] = useState({ detector: null });
    // --- APP STATE ---
    // Ensure we start with null or valid data
    const [audit, setAudit] = useState(null);
    const [history, setHistory] = useState([]);
    const [status, setStatus] = useState({ analyzing: false, logs: [], analyzed: false });
    const [ready, setReady] = useState(false); // Added ready state
    

    const [symptoms, setSymptoms] = useState([]);
    const [userPrefs, setUserPrefs] = useState({ lowImpact: false, noJumps: false, noEquipment: false });
const [tab, setTab] = useState('dashboard');

useEffect(() => {
        if (viewportRef.current) {
            viewportRef.current.scrollTo({ top: 0, behavior: 'smooth' });
        }
    }, [tab]);

// ... inside App component ...

    // FORCE RIGHT PANEL TO TOP ON CHANGE
    useEffect(() => {
        if (rightPanelRef.current) {
            rightPanelRef.current.scrollTo({ top: 0, behavior: 'smooth' });
        }
    }, [tab, postAnalysisMode, audit]); 

    // ... rest of effects

    const [showReader, setShowReader] = useState(null);
    const [rightPanelTab, setRightPanelTab] = useState('twin');
    const [activeProgram, setActiveProgram] = useState(null);
    const [generatedRoutine, setGeneratedRoutine] = useState(null); // The waiting area
    const [showClinical, setShowClinical] = useState(false);
    const [chatHistory, setChatHistory] = useState(() => {
    try {
        const saved = localStorage.getItem('bio_chat_memory');
        return saved ? JSON.parse(saved) : [];
    } catch (e) { return []; }
});


    // --- INIT ---
    useEffect(() => {
        // SANITIZATION ROUTINE
        try {
            const saved = localStorage.getItem('biometric_data_v99'); // BUMP TO V99
            if (saved) {
                const data = JSON.parse(saved);

                // DATA CLEANSE V99: Extreme Prejudice
                if (data.history && Array.isArray(data.history)) {
                    const saneHistory = data.history.filter(h => {
                        if (!h || typeof h.score !== 'number' || isNaN(h.score)) return false;
                        // Ensure all parts exist and are numbers
                        const parts = ['head', 'shoulders', 'spine', 'hip', 'gait'];
                        return parts.every(p => h[p] && typeof h[p].val === 'number' && !isNaN(h[p].val));
                    });

                    if (saneHistory.length > 0) {
                        setHistory(saneHistory);
                        setAudit(saneHistory[0]);
                        setReady(true);
                        setTab('dashboard');
                    }
                }

                if (data.symptoms) setSymptoms(data.symptoms);
                if (data.prefs) setUserPrefs(data.prefs);
            }
        } catch (e) {
            console.error("Data Load Failed - Resetting", e);
            localStorage.removeItem('biometric_data_v99');
        }

        // FORCE RESET ANALYZING STATE
        setStatus(s => ({ ...s, analyzing: false, logs: [] }));
        document.body.classList.remove('analyzing');
        document.querySelectorAll('.upload-slot').forEach(s => s.classList.remove('scanning'));

    }, []);

    // Save State (Debounced)
    useEffect(() => {
        if (!ready && history.length === 0) return;
        const data = { history, symptoms, prefs: userPrefs };
        localStorage.setItem('biometric_data_v99', JSON.stringify(data));
    }, [history, symptoms, userPrefs, ready]);



    // DAILY HABIT STATE
    const [dailyRoutine, setDailyRoutine] = useState([]);
    const [achievements, setAchievements] = useState([
        { id: 1, name: "First Step", desc: "Complete your first scan", unlocked: false, icon: <Icons.Check /> },
        { id: 2, name: "Consistency King", desc: "Scan 3 days in a row", unlocked: false, icon: <Icons.History /> },
        { id: 3, name: "Elite Structure", desc: "Achieve a Score > 80", unlocked: false, icon: <Icons.Award /> }
    ]);

    // Exercise History to ensure variety
    const [exerciseHistory, setExerciseHistory] = useState({});

    // Equipment Filter
    const [useEquipment, setUseEquipment] = useState(true);

    // NEW: Retention States
    const [streakDays, setStreakDays] = useState(0);
    const [currentGoal, setCurrentGoal] = useState({ target: 80, duration: 30, startDate: new Date().toDateString() });
    const [showGoalSetter, setShowGoalSetter] = useState(false);
    const [showShare, setShowShare] = useState(false);
    const [beforeImage, setBeforeImage] = useState(null); // First ever scan
    const [afterImage, setAfterImage] = useState(null);  // Latest scan
    const [showProtocolButton, setShowProtocolButton] = useState(false);
    const [currentTheme, setCurrentTheme] = useState('power');  // Weekly theme: power, recovery, mobility
    const [postAnalysisMode, setPostAnalysisMode] = useState(false);
    const [isModelReady, setIsModelReady] = useState(false);
    const [liveMode, setLiveMode] = useState(false);
    const [cameraError, setCameraError] = useState(false);
    const [liveKeypoints, setLiveKeypoints] = useState(null);
    const [sideKeypoints, setSideKeypoints] = useState(null);
    const liveVideoRef = useRef(null);
    const liveCanvasRef = useRef(null);
    const [liveCountdown, setLiveCountdown] = useState(null);

    const debouncedRunAnalysis = React.useCallback(() => {
        if (status.analyzing) return; // Ignore duplicates
        requestAnimationFrame(runAnalysis); // Queue after UI paints (smooth!)
    }, [status.analyzing]);
    const uploadRefs = { front: useRef(null), side: useRef(null), back: useRef(null) };

    const addLog = (msg) => setStatus(prev => ({ ...prev, logs: [`> ${msg}`, ...prev.logs].slice(0, 4) }));

    // NEW: Handle Exercise Feedback (ENHANCED for goodStreaks)
    const handleFeedback = (exerciseId, levelIdx, rating) => {
        const newHistory = { ...exerciseHistory };
        const existing = newHistory[exerciseId] || {};
        let goodStreaks = existing.goodStreaks || 0;
        if (rating === 'good') {
            goodStreaks = Math.min(3, goodStreaks + 1);
        } else {
            goodStreaks = 0;
        }
        newHistory[exerciseId] = {
            ...existing,
            lastUsed: new Date().toDateString(),
            lastLevel: levelIdx,
            lastRating: rating,
            goodStreaks
        };

    // LIVE MODE: Start webcam and run continuous detection
    useEffect(() => {
        if (!liveMode || !system.detector) return;

        let stream = null;
        let animationFrameId = null;

        const startCamera = async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "user" }
                });
                if (liveVideoRef.current) {
                    liveVideoRef.current.srcObject = stream;
                }

                const detectLoop = async () => {
  if (!liveVideoRef.current || liveVideoRef.current.readyState < 2) {
    animationFrameId = requestAnimationFrame(detectLoop);
    return;
  }

  const results = await system.detector.detectForVideo(
    liveVideoRef.current,
    performance.now()
  );

  if (results.landmarks && results.landmarks[0]) {
    const keypoints = results.landmarks[0];

    // LOWERED THRESHOLD + MORE LENIENT COUNT
    const requiredIndices = [11,12,23,24,25,26]; // shoulders, hips, knees
    const visibleCount = requiredIndices.filter(i => 
      keypoints[i] && (keypoints[i].visibility || keypoints[i].score || 0) > 0.5
    ).length;

    if (visibleCount >= 4) {  // Reduced from 6 → 4 (much more forgiving)
      // Good enough pose detected
      if (liveCountdown === null) {
        setLiveCountdown(5);
        addLog("Good pose locked — capturing in 5s");
      }

      const score = calculateLivePostureScore(keypoints);
      setLiveScore(score);

      // Gentle real-time feedback
      if (score < 70 && lastAlertScore >= 80) {
        if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
        SFX.play(300, 'sine', 0.4);
        setLastAlertScore(score);
      } else if (score >= 80) {
        setLastAlertScore(100);
      }

      setLiveKeypoints(keypoints);
      drawLiveSkeleton(keypoints);

    } else {
      // Not enough keypoints — helpful feedback
      setLiveScore(null);
      setLiveCountdown(null);
      setLiveKeypoints(null);
    }
  } else {
    setLiveScore(null);
    setLiveCountdown(null);
    setLiveKeypoints(null);
  }

  animationFrameId = requestAnimationFrame(detectLoop);
};

                detectLoop();
            } catch (err) {
                console.error("Camera access denied", err);
                addLog("Camera access blocked — allow in browser");
                setLiveMode(false);
            }
        };

        startCamera();

        return () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (stream) stream.getTracks().forEach(track => track.stop());
            setLiveKeypoints(null);
        };
    }, [liveMode, system.detector]);

// ← PASTE THE NEW useEffect RIGHT HERE
useEffect(() => {
    if (liveCountdown === null || liveCountdown === 0) return;

    if (liveCountdown > 0) {
        const timer = setTimeout(() => setLiveCountdown(liveCountdown - 1), 1000);
        return () => clearTimeout(timer);
    } else {
        // Countdown finished → capture front view and analyze
        const video = liveVideoRef.current;
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1); // Un-mirror for correct capture
        ctx.drawImage(video, 0, 0);

        const dataUrl = canvas.toDataURL('image/jpeg');
        setUploads(prev => ({ ...prev, front: { url: dataUrl, analyzed: false } }));

        // Auto-run analysis
        setLiveMode(false);
        runAnalysis();

        setLiveCountdown(null);
    }
}, [liveCountdown]);

    // Helper: Draw skeleton on live canvas
    const drawLiveSkeleton = (keypoints) => {
        const canvas = liveCanvasRef.current;
        if (!canvas || !liveVideoRef.current) return;

        const video = liveVideoRef.current;
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Scale keypoints to canvas size
        const scaled = keypoints.map(kp => ({
            x: kp.x * canvas.width,
            y: kp.y * canvas.height
        }));

        // Connections (same as your static version)
        const connections = [
            [11,12],[11,13],[13,15],[12,14],[14,16], // arms
            [11,23],[12,24],[23,25],[24,26],         // torso to hips/legs
            [23,24]                                  // hips
        ];

        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';

        connections.forEach(([a, b]) => {
            if (keypoints[a]?.visibility > 0.3 && keypoints[b]?.visibility > 0.3) {
                ctx.beginPath();
                ctx.moveTo(scaled[a].x, scaled[a].y);
                ctx.lineTo(scaled[b].x, scaled[b].y);
                ctx.stroke();
            }
        });

        // Keypoint dots
        scaled.forEach((kp, i) => {
            if (keypoints[i]?.visibility > 0.5) {
                ctx.fillStyle = '#0f172a';
                ctx.beginPath();
                ctx.arc(kp.x, kp.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#22d3ee';
                ctx.beginPath();
                ctx.arc(kp.x, kp.y, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    };
        setExerciseHistory(newHistory);
        // Visual feedback log
        const rateMsg = rating === 'easy' ? "Marked Easy (Progressing next time)" : rating === 'hard' ? "Marked Hard (Regressing next time)" : "Marked Good (Maintaining)";
        addLog(rateMsg);
    };

    // NEW HELPER: Quick trend delta (improvement over last 3 sessions)
    const getTrendDelta = (history, bodyPart) => {
        if (history.length < 2) return 0;
        const recent = history.slice(0, 3).map(h => h[bodyPart].val).reverse(); // Last 3 vals (lower val = worse)
        return (recent[0] - recent[recent.length - 1]) / recent.length; // Positive = improving
    };

    useEffect(() => {
    const init = async () => {
        const checkReady = () => new Promise(resolve => {
            if (window.mpReady && window.mpVision) {
                resolve();
            } else {
                setTimeout(checkReady, 100);
            }
        });

        await checkReady();
        console.log("MediaPipe fully loaded");

        const mp = window.mpVision;

        addLog("Warming AI Engine...");
        try {
            const vision = await mp.FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
            );

            const poseLandmarker = await mp.PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task`,
                    delegate: "CPU"
                },
                runningMode: "IMAGE",
                numPoses: 1
            });

            setSystem(prev => ({ ...prev, detector: poseLandmarker }));
            setIsModelReady(true);
            addLog("Neural Engine Online. Ready for analysis");
        } catch (e) {
            console.error("Init Error:", e);
            addLog("Hardware Acceleration Error. Retrying...");
            setTimeout(init, 2000);
        }
    }
    init();
}, []);

    // NEW: Streak Calculation
    const calculateStreak = (hist) => {
        if (hist.length === 0) return;
        const dates = hist.map(h => new Date(h.date).toDateString()).sort();
        let streak = 0;
        const today = new Date().toDateString();
        if (dates[dates.length - 1] === today) streak = 1;
        for (let i = dates.length - 2; i >= 0; i--) {
            const prevDate = new Date(dates[i]);
            const nextDate = new Date(dates[i + 1]);
            if (nextDate - prevDate === 86400000) { // 24 hours
                streak++;
            } else break;
        }
        setStreakDays(streak);
    };

    // NEW: Save Goal
    const saveGoal = (goal) => {
        setCurrentGoal(goal);
        localStorage.setItem('bio_goal', JSON.stringify(goal));
        setShowGoalSetter(false);
        addLog(`Goal Set: ${goal.target}% in ${goal.duration} days`);
    };

    useEffect(() => {
        if (chatHistory.length > 0) localStorage.setItem('bio_chat_memory', JSON.stringify(chatHistory));
    }, [chatHistory]);

    // Save exercise history whenever it changes
    useEffect(() => {
        if (Object.keys(exerciseHistory).length > 0) localStorage.setItem('bio_exercise_history', JSON.stringify(exerciseHistory));
    }, [exerciseHistory]);

    // NEW: Reset Streak (For Testing/Edge Cases)
    const resetStreak = () => setStreakDays(0);

    const updateBadges = (hist) => {
        setAchievements(prev => prev.map(badge => {
            if (badge.id === 1 && hist.length > 0) return { ...badge, unlocked: true };
            if (badge.id === 2 && hist.length >= 3) return { ...badge, unlocked: true };
            if (badge.id === 3 && hist.some(h => h.score > 80)) return { ...badge, unlocked: true };
            return { ...badge, unlocked: false };
        }));
    };
// --- FIX: TURN BUTTON BLUE WHEN PHOTO UPLOADED ---
    useEffect(() => {
        // As soon as the AI is ready AND a photo exists -> Enable Button
        const aiReady = system.detector != null;
        const photoUploaded = uploads.front || uploads.side || uploads.back;
        
        if (aiReady && photoUploaded) {
            setReady(true);
        }
    }, [system.detector, uploads]);
    const handleFile = (e, view) => {
        if (e.target.files[0]) {
            setUploads(prev => ({ ...prev, [view]: { url: URL.createObjectURL(e.target.files[0]), analyzed: false } }));
            addLog(`${view.toUpperCase()} View Loaded`);
        }
    };

    const toggleSymptom = (sym) => {
        setSymptoms(prev => prev.includes(sym) ? prev.filter(s => s !== sym) : [...prev, sym]);
    };

    const toggleDailyTask = (index) => {
        const newRoutine = [...dailyRoutine];
        newRoutine[index].completed = !newRoutine[index].completed;
        setDailyRoutine(newRoutine);
    };

    // --- ULTIMATE OFFLINE BIO-COACH (MAX SOPHISTICATION, NO GEMINI) ---
const handleChat = async (input) => {
    // =========================================================================
    // 🧠 LAYER 1: COGNITIVE PRE-PROCESSING & STATE AWARENESS
    // =========================================================================
    
    setChatHistory(prev => [...prev, { sender: 'user', text: input }]);
    
    // Artificial "Cognitive Load" delay for realism
    await new Promise(r => setTimeout(r, 800 + Math.random() * 400)); 

    // 1.1 Fuzzy Match Utility
    const fuzzyMatch = (source, target) => {
        const a = source.toLowerCase();
        const b = target.toLowerCase();
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;
        const matrix = [];
        for (let i = 0; i <= b.length; i++) { matrix[i] = [i]; }
        for (let j = 0; j <= a.length; j++) { matrix[0][j] = j; }
        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
                }
            }
        }
        return 1 - (matrix[b.length][a.length] / Math.max(a.length, b.length));
    };

    // 1.2 Context Engines
    const getTimeContext = () => {
        const h = new Date().getHours();
        if (h < 11) return { phase: "Morning", focus: "Activation", icon: "🌅", advice: "Hydrate your fascia immediately." };
        if (h < 17) return { phase: "Day", focus: "Postural Reset", icon: "☀️", advice: "Break the sitting cycle." };
        return { phase: "Evening", focus: "Decompression", icon: "🌙", advice: "Switch to parasympathetic breathing." };
    };

    const detectSentiment = (str) => {
        if (["pain", "hurt", "dying", "agony", "injury"].some(w => str.includes(w))) return "distress";
        if (["ready", "let's go", "pumped", "start"].some(w => str.includes(w))) return "motivated";
        return "neutral";
    };

    // =========================================================================
    // 🧬 LAYER 2: KNOWLEDGE GRAPH & PREDICTIVE MODELING
    // =========================================================================

    const anatomyMatrix = {
        "suboccipital": "head", "scm": "head", "jaw": "head", "tmj": "head", "migraine": "head", "neck": "head",
        "pec": "shoulders", "rotator": "shoulders", "trap": "shoulders", "shoulder": "shoulders",
        "lats": "spine", "erector": "spine", "disk": "spine", "sciatica": "spine", "back": "spine", "lumbar": "spine",
        "psoas": "hip", "glute": "hip", "piriformis": "hip", "groin": "hip", "hip": "hip",
        "plantar": "gait", "shin": "gait", "ankle": "gait", "foot": "gait", "knee": "gait", "bunions": "gait"
    };

    // Predictive Analysis (The "Scare" Factor)
    const calculateRisk = (part, score) => {
        if (score > 85) return { risk: "Low", prediction: "Sustainable longevity." };
        if (score > 70) return { risk: "Moderate", prediction: "Performance leak detected." };
        return { risk: "High", prediction: "Chronic injury likely within 18 months if uncorrected." };
    };

    // =========================================================================
    // ⚙️ LAYER 3: CORE LOGIC EXECUTION
    // =========================================================================

    const lower = input.toLowerCase();
    const timeCtx = getTimeContext();
    const sentiment = detectSentiment(lower);
    
    // Analyze Audit State
    let worst = { part: "balanced", score: 100, key: "" };
    let second = { part: "great", score: 100, key: "" };
    
    if (audit) {
        const map = {
            head: { name: "Head/Neck", tips: "Head Loading" },
            shoulders: { name: "Shoulders", tips: "Standing Pulls" },
            spine: { name: "Spine", tips: "Spinal Waves" },
            hip: { name: "Hips", tips: "Split Squats" },
            gait: { name: "Gait", tips: "Hyperarch Hops" }
        };
        for (let key in map) {
            const val = audit[key]?.val || 100;
            if (val < worst.score) {
                second = worst;
                worst = { part: map[key].name, score: val, key, tips: map[key].tips };
            } else if (val < second.score) {
                second = { part: map[key].name, score: val, key, tips: map[key].tips };
            }
        }
    }

    // =========================================================================
    // 💬 LAYER 4: RESPONSE SYNTHESIS (With Actions)
    // =========================================================================

    let reply = "";
    let action = null; // Object { label: string, type: string, payload: any }
    let contextBonus = "";

    // 4.1 Keyword Matching (Intent Detection)
    const isAcademy = lower.includes("learn") || lower.includes("reading") || lower.includes("class") || lower.includes("academy");
    const isRoutine = lower.includes("plan") || lower.includes("routine") || lower.includes("workout") || lower.includes("start");
    const isPain = lower.includes("pain") || lower.includes("hurt");
    
    // Fuzzy Anatomy Match
    let bestMatchKey = null;
    Object.keys(anatomyMatrix).forEach(term => {
        if (fuzzyMatch(lower, term) > 0.85) bestMatchKey = anatomyMatrix[term];
    });

    // --- LOGIC BRANCHES ---

    // BRANCH A: Direct Action Request (Navigation)
    if (isAcademy) {
        reply = "Knowledge is the first step to correction. I'm opening the **Movement Academy** now. Start with the 'Biotensegrity' masterclass.";
        action = { label: "OPEN ACADEMY", type: "NAVIGATE", payload: "academy" };
    }
    // BRANCH B: Routine Generation
    else if (isRoutine) {
        reply = `I've constructed a ${timeCtx.phase} protocol targeting your **${worst.part}** (${worst.score}%).\n\n` +
                `**Objective:** Restore elastic recoil and alignment.\n` +
                `**Key Move:** ${worst.tips}\n\n` +
                `Ready to execute sequence?`;
        action = { label: "LAUNCH SESSION", type: "START_SESSION", payload: generatedRoutine };
    }
    // BRANCH C: Anatomy/Pain Specific
    else if (bestMatchKey && audit) {
        const score = audit[bestMatchKey]?.val || "?";
        const risk = calculateRisk(bestMatchKey, score);
        reply = `You asked about **${bestMatchKey.toUpperCase()}**. Your biometric score here is **${score}%**.\n\n` +
                `**Kinetic Reality:** ${risk.prediction}\n` +
                `In biotensegrity, the site of pain is rarely the source. This is likely a compensation pattern.`;
        
        // Contextual Recommendation
        if (bestMatchKey === 'head') contextBonus = "\n\n💡 *Tip: Check your tongue posture. Press tongue to roof of mouth to stabilize the deep neck line.*";
        if (bestMatchKey === 'gait') contextBonus = "\n\n💡 *Tip: Stop heel striking. Land mid-foot to engage the fascial spring.*";
        
        reply += contextBonus;
        
        // Suggest specific fix
        action = { label: `FIX ${bestMatchKey.toUpperCase()}`, type: "START_SESSION", payload: null }; // Will trigger preset load
    }
    // BRANCH D: General Greetings / Status
    else if (lower.includes("hi") || lower.includes("hello") || lower.includes("status")) {
        reply = `Systems Online. ${timeCtx.icon} **Good ${timeCtx.phase}.**\n\n` +
                `**Current Bio-Integrity:** ${audit?.score || "?"}%\n` +
                `**Weakest Link:** ${worst.part} (${worst.score}%)\n` +
                `**Advisory:** ${timeCtx.advice}\n\n` +
                `What is your directive?`;
    }
    // BRANCH E: Lifestyle/Nutrition (Expansion)
    else if (lower.includes("water") || lower.includes("diet") || lower.includes("sleep")) {
        reply = `**Fascial Health Protocol:**\n\n` +
                `1. **Hydration:** Fascia is 70% water. If you are dehydrated, you are brittle. Drink 0.5oz per lb of bodyweight.\n` +
                `2. **Collagen:** The building block of your web. Bone broth or Vitamin C + Glycine.\n` +
                `3. **Sleep:** Tensegrity creates space during REM sleep. If you don't sleep, you shrink.`;
    }
    // FALLBACK
    else {
        reply = `I am analyzing your query against your biomechanical data.\n\n` +
                `**Current Priority:** Fix the ${worst.part} (${worst.score}%).\n` +
                `Unless your question solves that, it is a distraction. Focus on the foundation.`;
        action = { label: "VIEW DATA", type: "NAVIGATE", payload: "progress" };
    }

    // Distress Override
    if (sentiment === "distress") {
        reply = `⚠️ **Pain Signal Detected.**\n\n` +
                `Stop immediately. Pain is not gain; it is a request for change. ` +
                `We need to downregulate your nervous system. Switch to **Parasympathetic Breathing** now.`;
        action = { label: "EMERGENCY RESET", type: "LOAD_PRESET", payload: "Sedentary Reset" };
    }

    // =========================================================================
    // 🚀 LAYER 5: EXECUTION
    // =========================================================================
    
    // Add to history with potential action button
    setChatHistory(prev => [...prev, { 
        sender: 'ai', 
        text: reply, 
        action: action 
    }]);
    
    // Audio Feedback (Optional voice line)
    if (window.speechSynthesis && !lower.includes("silent")) {
        // Only speak the first sentence to be less annoying
        const utterance = new SpeechSynthesisUtterance(reply.split('.')[0]);
        utterance.rate = 1.1;
        utterance.volume = 0.2;
        // window.speechSynthesis.speak(utterance); // Uncomment for voice
    }
};

// 3. ACTION HANDLER (Paste into App component where you define handleChat)
const handleCoachAction = (action) => {
    if (!action) return;
    
    addLog(`Executing: ${action.type} -> ${action.label}`);
    
    switch (action.type) {
        case 'NAVIGATE':
            setTab(action.payload);
            setPostAnalysisMode(false); // Close side panel if needed for mobile
            break;
        case 'START_SESSION':
    if (action.payload) {
        setActiveProgram(action.payload);
    } else {
        // Force generation AND immediate launch
        generateProgram(); 
        // We use a tiny timeout to let the state update, then grab it
        setTimeout(() => {
            setActiveProgram(prev => prev || generatedRoutine); 
        }, 100);
    }
    break;
        case 'LOAD_PRESET':
            loadPreset(action.payload);
            break;
        default:
            console.warn("Unknown Action", action);
    }
};
    // REPLACE the remaining arrow function with this:
function drawSkeleton(keypoints, view) {
  const canvas = document.getElementById(`canvas-${view}`);
  if (!canvas || !uploadRefs[view].current) return;

  const img = uploadRefs[view].current;
  const container = canvas.parentElement;
  const contW = container.clientWidth;
  const contH = container.clientHeight;

  const dpr = window.devicePixelRatio || 1;
  canvas.width = contW * dpr;
  canvas.height = contH * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  ctx.clearRect(0, 0, contW, contH);

  // Letterbox image (object-contain)
  const imgRatio = img.naturalWidth / img.naturalHeight;
  const contRatio = contW / contH;
  let drawW, drawH, offsetX = 0, offsetY = 0;
  if (imgRatio > contRatio) {
    drawH = contH;
    drawW = drawH * imgRatio;
    offsetX = (contW - drawW) / 2;
  } else {
    drawW = contW;
    drawH = drawW / imgRatio;
    offsetY = (contH - drawH) / 2;
  }
  ctx.drawImage(img, offsetX, offsetY, drawW, drawH);

  // Scale keypoints to drawn image size
  const scaledKeypoints = keypoints.map(kp => ({
    x: kp.x * drawW + offsetX,
    y: kp.y * drawH + offsetY,
    score: kp.score || kp.visibility || 0
  }));

  // Connections (MediaPipe indices)
  const connections = [
    [11,12],[11,13],[13,15],[12,14],[14,16],
    [11,23],[12,24],[23,25],[24,26],[23,24]
  ].filter(pair => {
    const a = keypoints[pair[0]];
    const b = keypoints[pair[1]];
    return a && b && a.score > 0.15 && b.score > 0.15;
  });

  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  connections.forEach(([i, j]) => {
    const p1 = scaledKeypoints[i];
    const p2 = scaledKeypoints[j];
    const avgScore = (p1.score + p2.score) / 2;
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = avgScore > 0.4 ? '#22d3ee' : 'rgba(34,211,238,0.6)';
    ctx.lineWidth = avgScore > 0.4 ? 5 : 3;
    ctx.stroke();
  });

  // Keypoints (skip face 0–10)
  scaledKeypoints.forEach((kp, i) => {
    if (i > 10 && kp.score > 0.15) {
      ctx.beginPath();
      ctx.arc(kp.x, kp.y, 8, 0, Math.PI * 2);
      ctx.fillStyle = '#0f172a';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(kp.x, kp.y, 6, 0, Math.PI * 2);
      ctx.fillStyle = kp.score > 0.5 ? '#22d3ee' : '#f59e0b';
      ctx.fill();
    }
  });
};

const startLiveMode = async () => {
    setCameraError(false);
    try {
        // Direct user gesture → requests permission properly
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user", width: 1280, height: 720 }
        });
        if (liveVideoRef.current) {
            liveVideoRef.current.srcObject = stream;
        }
        setLiveMode(true);
    } catch (err) {
        console.error("Camera access failed:", err);
        setCameraError(true);
        alert("Camera access was blocked. Please allow camera permission in your browser settings and try again.");
    }
};
    // ... inside the App component return statement ...

    const runAnalysis = async () => {
        // 1. HELPER: Validity Check
        const valid = (lm) => lm && (lm.score > 0.5 || lm.visibility > 0.5);

        let captured3DData = null; 
        let net = system.detector;

        // --- NEW: Initialize proportion variables BEFORE the loop ---
        let frontShoulderWidth = null; 
        let estHeight = null;

        if (!navigator.onLine) {
            addLog(" Offline — Connect to analyze.");
            setStatus(prev => ({ ...prev, analyzing: false }));
            return;
        }

        // 2. UI LOADING STATE
        setStatus(prev => ({
            ...prev,
            analyzing: true,
            logs: ["Initiating Neural Core V85...", ...prev.logs]
        }));
        document.body.classList.add('analyzing'); 
        document.querySelectorAll('.upload-slot.active').forEach(slot => slot.classList.add('scanning'));

        await new Promise(r => setTimeout(r, 50)); 

        // 3. PREPARE DATA
        const views = Object.keys(uploads).filter(k => uploads[k] && uploads[k].url);
        if (views.length === 0 && symptoms.length === 0) {
            addLog("Upload at least one photo.");
            setStatus(prev => ({ ...prev, analyzing: false }));
            return;
        }

        document.querySelectorAll('.upload-slot').forEach(slot => slot.classList.remove('scanning'));

        let rawScores = { head: [], shoulders: [], spine: [], hip: [], gait: [] };
        
        // --- THE UNIFIED "GOOD" LOGIC ENGINE ---
        // Helper for Angle/Torsion
        const calculateTorsion = (p1, p2) => {
            if (!p1 || !p2) return 0;
            const width = Math.abs(p1.x - p2.x);
            const depth = Math.abs(p1.z - p2.z); 
            return Math.atan2(depth, width) * (180 / Math.PI);
        };

        // Helper: Normalize dev for angles (0-1 scale)
        const normAngleDev = (angle) => Math.min(Math.abs(180 - angle) / 90, 1);

        // THE "GOOD" RATE METRIC (Sensitivity 50 - Fixed & Isolated)
        const rateMetric = (point1, point2, axis = 'y', sensitivity = 50) => {
            if (!point1 || !point2) return 65;
            const score1 = point1.score || point1.visibility || 0;
            const score2 = point2.score || point2.visibility || 0;

            if (score1 < 0.15 || score2 < 0.15) return 65;
            
            const visualDelta = Math.abs(point1[axis] - point2[axis]);
            const zDelta = Math.abs((point1.z || 0) - (point2.z || 0)) * 0.8;
            const trueDeviation = Math.max(0, visualDelta - zDelta);
            
            // The "Good" Math: Gentler curve
            const baseScore = 100 - (Math.min(trueDeviation, 0.2) * sensitivity * 50);
            const confWeight = (score1 + score2) / 2;
            
            return Math.max(40, Math.min(100, Math.floor(baseScore * confWeight)));
        };

        try {
            for (const view of views) {
                const img = uploadRefs[view].current;
                if (!img || img.naturalWidth === 0) continue;

                const result = await system.detector.detect(img);

                if (!result || !result.landmarks || result.landmarks.length === 0) {
                    addLog(` NO SKELETON FOUND in ${view}.`);
                    continue;
                }

                // Capture 3D Data (Prefer Front)
                if (result.worldLandmarks && result.worldLandmarks.length > 0) {
                    const worldLm = result.worldLandmarks[0];
                    if (view === 'front') {
                        captured3DData = worldLm;
                        addLog("Captured high-quality 3D depth from front view");
                    } else if (!captured3DData) {
                        captured3DData = worldLm; 
                        addLog(`Captured 3D depth from ${view} view (backup)`);
                    }
                }

                // 2D Keypoints mapping
                const keypoints = result.landmarks[0].map((lm, i) => ({
                    x: lm.x, y: lm.y, z: 0, score: lm.visibility || 1.0, name: i
                }));
                const p = keypoints;
                const landmarks3D = result.worldLandmarks ? result.worldLandmarks[0] : result.landmarks[0];
                
                // Draw visual feedback
                drawSkeleton(keypoints, view); 

                // --- NEW FIX: EXTRACT PROPORTIONS INSIDE THE LOOP ---
                // This prevents the ReferenceError because 'view' and 'p' exist here
                if (view === 'front' && !frontShoulderWidth) {
                    const lSh = p[11]; 
                    const rSh = p[12]; 
                    if (valid(lSh) && valid(rSh)) {
                        frontShoulderWidth = Math.abs(lSh.x - rSh.x); // Normalized width (0-1)
                    }
                }
                // Extract estHeight from any view (max y - min y of keypoints)
                if (!estHeight) {
                    const ys = p.filter(kp => valid(kp)).map(kp => kp.y);
                    if (ys.length > 0) {
                        estHeight = Math.max(...ys) - Math.min(...ys) || 1; 
                    }
                }
                // ---------------------------------------------------

                // --- SINGLE PASS ANALYSIS (NO DUPLICATES) ---
                if (view === 'front') {
                    const lSh = landmarks3D[11], rSh = landmarks3D[12];
                    const lHip = landmarks3D[23], rHip = landmarks3D[24];
                    const lAnk = p[27], rAnk = p[28];
                    const nose = p[0];
                    const lEye = p[2], rEye = p[5];

                    // 1. Shoulders (Level + Torsion)
                    if (valid(lSh) && valid(rSh)) {
                        rawScores.shoulders.push(rateMetric(lSh, rSh, 'y', 8));
                        const shTorsion = calculateTorsion(lSh, rSh);
                        // Weighted torsion score
                        rawScores.shoulders.push(100 - (shTorsion * 2.5)); 
                    }

                    // 2. Hips (Level)
                    if (valid(lHip) && valid(rHip)) {
                        rawScores.hip.push(rateMetric(lHip, rHip, 'y', 6));
                    }

                    // 3. Gait (Stance Width & Symmetry)
                    if (lAnk && rAnk && lAnk.score >= 0.3 && rAnk.score >= 0.3) {
                        const pronation = Math.abs(lAnk.x - rAnk.x);
                        rawScores.gait.push(100 - (Math.min(pronation, 0.15) * 600));
                    }

                    // 4. Head (Eye Level)
                    if (lEye && rEye && lEye.score > 0.2 && rEye.score > 0.2) {
                        rawScores.head.push(rateMetric(lEye, rEye, 'y', 15));
                    }

                    // 5. Spine (Center Alignment)
                    if (nose && lHip && rHip && nose.score > 0.2) {
                        const hipCenterX = (lHip.x + rHip.x) / 2;
                        const deviation = Math.abs(nose.x - hipCenterX);
                        const spineScore = 100 - (deviation * 400); 
                        rawScores.spine.push(Math.max(40, Math.min(100, spineScore)));
                    }
                }

                if (view === 'back') {
                    const lSh = p[11], rSh = p[12];
                    const lHip = p[23], rHip = p[24];

                    if (valid(lSh) && valid(rSh)) {
                        rawScores.shoulders.push(rateMetric(lSh, rSh, 'y', 8));
                    }
                    if (valid(lHip) && valid(rHip)) {
                        rawScores.hip.push(rateMetric(lHip, rHip, 'y', 6));
                    }
                }

                if (view === 'side') {
                    // Neck Angle
                    const reqNeck = [0, 11, 23];
                    if (reqNeck.every(idx => p[idx] && p[idx].score >= 0.3)) {
                        const neckAngle = calculateAngle(p[0], p[11], p[23]);
                        rawScores.head.push(100 - (normAngleDev(neckAngle) * 40));
                    }
                    // Lumbar Spine
                    const reqLumbar = [23, 25, 11];
                    if (reqLumbar.every(idx => p[idx] && p[idx].score >= 0.3)) {
                        const lumbarAngle = calculateAngle(p[23], p[25], p[11]);
                        rawScores.spine.push(100 - (normAngleDev(lumbarAngle) * 50));
                    }
                    // Ankle Mobility
                    const reqAnkle = [23, 25, 27];
                    if (reqAnkle.every(idx => p[idx] && p[idx].score >= 0.3)) {
                        const ankleAngle = calculateAngle(p[23], p[25], p[27]);
                        rawScores.gait.push(100 - (normAngleDev(ankleAngle) * 40));
                    }
                }
            }
        } catch (err) { console.error(err); }

        // 4. AGGREGATE & INFER
        const avg = (arr) => {
            const valid = arr.filter(n => typeof n === 'number' && !isNaN(n));
            return valid.length ? valid.reduce((a, b) => a + b) / valid.length : null;
        };

        let final = {
            head: avg(rawScores.head),
            shoulders: avg(rawScores.shoulders),
            spine: avg(rawScores.spine),
            hip: avg(rawScores.hip),
            gait: avg(rawScores.gait)
        };

        // Get global proportions (use defaults if not extracted)
        const shoulderWidth = frontShoulderWidth || 0.2;  // Default if no front view
        estHeight = estHeight || 1;  // Default if no keypoints

        // Apply normalization, torsion, and symptoms to final
        Object.keys(final).forEach(k => {
            if (final[k] === null || isNaN(final[k])) final[k] = 75;
            // Normalize: e.g., for head, divide raw dev by estHeight before penalty
            final[k] = Math.max(40, Math.min(100, Math.floor(final[k] / estHeight * 100))); 
        });

        // Integrate 3D torsion (z) for rotation penalty
        if (captured3DData) {
            const lSh3D = captured3DData[11], rSh3D = captured3DData[12];
            if (lSh3D && rSh3D) {
                const torsionAngle = calculateTorsion(lSh3D, rSh3D); 
                const torsionPenalty = torsionAngle * 1.5; 
                final.shoulders = Math.max(40, final.shoulders - torsionPenalty);
            }
            const lHip3D = captured3DData[23], rHip3D = captured3DData[24];
            if (lHip3D && rHip3D) {
                const hipTorsion = calculateTorsion(lHip3D, rHip3D);
                const hipPenalty = hipTorsion * 1.2; 
                final.hip = Math.max(40, final.hip - hipPenalty);
            }
            const lAnk3D = captured3DData[27], rAnk3D = captured3DData[28];
            if (lAnk3D && rAnk3D) {
                const gaitTorsion = calculateTorsion(lAnk3D, rAnk3D);
                const gaitPenalty = gaitTorsion * 1.8; 
                final.gait = Math.max(40, final.gait - gaitPenalty);
            }
        }

        // Symptom Weighting: Boost penalty if symptom-linked
        if (symptoms.includes('Neck Pain')) final.head *= 0.9; 
        if (symptoms.includes('Back Pain')) final.spine *= 0.9;
        if (symptoms.includes('Knee Pain')) final.gait *= 0.85; 
        if (symptoms.includes('Foot Pain')) final.gait *= 0.9;
        if (symptoms.includes('Shoulder Pain')) final.shoulders *= 0.9;

        const scoreValues = Object.values(final).filter(v => typeof v === 'number');
        const average = scoreValues.length ? scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length : 70;
        const minimum = scoreValues.length ? Math.min(...scoreValues) : 70;
        
        // Weighted Total: Weakest link drags score down (Realistic)
        const totalScore = Math.floor((average * 0.7) + (minimum * 0.3));

        const baselineAge = 30; 
        const agePenalty = (100 - totalScore) * 0.4;
        const structuralAge = Math.floor(baselineAge + agePenalty);

        const newAudit = {
            date: new Date().toLocaleDateString(),
            score: totalScore,
            bioAge: structuralAge,
            ageDiff: structuralAge - baselineAge,
            landmarks3D: captured3DData, 
            forecast: { predicted: Math.floor(Math.max(0, totalScore + 5)), slope: 0.5 },
            head: { val: final.head, grade: getGrade(final.head) },
            shoulders: { val: final.shoulders, grade: getGrade(final.shoulders) },
            spine: { val: final.spine, grade: getGrade(final.spine) },
            gait: { val: final.gait, grade: getGrade(final.gait) },
            hip: { val: final.hip, grade: getGrade(final.hip) }
        };

        addLog("Synchronizing Biometric Data...");
        await new Promise(r => setTimeout(r, 4200)); 

        setAudit(newAudit);
        setHistory([newAudit, ...history]);

        const latestImage = uploads.side?.url || uploads.front?.url || uploads.back?.url;
        if (history.length === 0) setBeforeImage(latestImage);
        setAfterImage(latestImage);

        setStatus(prev => ({ ...prev, analyzing: false }));
        
        // Save to LocalStorage
        localStorage.setItem('biometric_data_v99', JSON.stringify({ history: [newAudit, ...history], symptoms, prefs: userPrefs }));

        setTab(history.length === 0 ? 'results' : 'dashboard');

        SFX.success();
        generateProgram();                     
        setShowProtocolButton(true);           
        setPostAnalysisMode(true);             
        document.body.classList.remove('analyzing');
        document.querySelectorAll('.upload-slot').forEach(slot => slot.classList.remove('scanning'));
        
        // Confetti
        const confettiContainer = document.createElement('div');
        confettiContainer.style.position = 'fixed';
        confettiContainer.style.inset = '0';
        confettiContainer.style.pointerEvents = 'none';
        confettiContainer.style.zIndex = '100';
        document.body.appendChild(confettiContainer);
        for (let i = 0; i < 50; i++) {
            const c = document.createElement('div');
            const color = ['#22d3ee', '#fff', '#0ea5e9'][Math.floor(Math.random() * 3)];
            c.className = 'confetti';
            c.style.left = Math.random() * 100 + 'vw';
            c.style.background = color;
            c.style.animationDelay = Math.random() * 2 + 's';
            confettiContainer.appendChild(c);
        }
        setTimeout(() => confettiContainer.remove(), 4000);
    };
    // --- V101.0 APEX ARCHITECT ENGINE (TRUE VARIANCE & ROULETTE SELECTION) ---
const generateProgram = () => {
    if (!audit) return;

    // 1. PHASE CALCULATOR
    const score = audit.score;
    let userPhase = 1;
    if (score >= 85) userPhase = 5;      
    else if (score >= 75) userPhase = 3; 
    else if (score >= 65) userPhase = 2; 
    else userPhase = 1;                  

    if (history.length < 5) userPhase = 1;

    const parts = ['head', 'shoulders', 'spine', 'hip', 'gait'];


// 1. GRANULAR PHASE CALCULATOR (Per-Part)
const partPhases = {};
parts.forEach(part => {  // parts is always defined as array, no error
    const partScore = audit[part]?.val || 70;  // Safe fallback if audit[part] undefined
    let phase = 1;
    if (partScore >= 85) phase = 5;
    else if (partScore >= 75) phase = 3;
    else if (partScore >= 65) phase = 2;
    if (history.length < 5) phase = Math.min(phase, 2); // Cap early users
    partPhases[part] = phase;
});

// Use average for global, but per-part for filtering
userPhase = Math.floor(Object.values(partPhases).reduce((a,b) => a+b, 0) / parts.length);

// WEEKLY THEME (Cycles every week)
const now = new Date();
const start = new Date(now.getFullYear(), 0, 1);
const diff = (now - start) + ((start.getDay() === 0 ? -6 : 1) - start.getDay()) * 86400000;
const week_num = Math.ceil(diff / 604800000);  // 604800000 = 7 days ms
const themes = ['power', 'recovery', 'mobility'];
const currentTheme = themes[week_num % 3];

    // 2. TARGET IDENTIFICATION
    const sortedParts = parts.sort((a, b) => audit[a].val - audit[b].val);
    const weakestLink = sortedParts[0];
    const secondaryLink = sortedParts[1];

// SYMPTOM SEVERITY CALC (0-1 scale)
const symptomSeverity = symptoms.length / 4; // Max 4 symptoms, safe /0=0
const symptomMap = {
    'Neck Pain': ['head', 'shoulders'],
    'Back Pain': ['spine', 'hip'],
    'Knee Pain': ['gait', 'hip'],
    'Foot Pain': ['gait']
};

// Combo Detection (e.g., neck+back = spine bonus)
const affectedParts = new Set();
symptoms.forEach(sym => {  // symptoms is always array (empty ok)
    const mapped = symptomMap[sym] || [];  // Safe empty array if no match
    mapped.forEach(p => affectedParts.add(p));  // forEach on safe array
});

    // 3. RETRIEVE GLOBAL USAGE STATS (Total times done)
    // We calculate this on the fly to penalize over-used moves
    const globalUsage = {};
    Object.keys(exerciseHistory).forEach(key => {
        // We use a rough estimate based on history length or specific counters if you added them
        // For now, we assume if it's in history, it's been done at least once + goodStreaks
        globalUsage[key] = (exerciseHistory[key].goodStreaks || 0) + 1; 
    });

    // 4. GENERATE LOTTERY POOL
    let lotteryPool = EXERCISE_DB.map(ex => {
        // --- HARD FILTERS ---
        if (!useEquipment && ex.equipment === 'required') return null;
        if (userPrefs.noEquipment && ex.equipment === 'required') return null;
        if (userPrefs.lowImpact && ex.pattern.includes('power')) return null;
        if (userPrefs.noJumps && (ex.id.includes('hop') || ex.id.includes('bounce'))) return null;
        if (ex.requires_mastery && !ex.requires_mastery.every(id => exerciseHistory[id]?.goodStreaks >= 2)) return null;

        // --- TICKET ALLOCATION (The Weighting) ---
        let tickets = 100; 

        // A. Relevance (The Need)
        if (ex.target_grade === weakestLink) tickets += 300;       
        else if (ex.target_grade === secondaryLink) tickets += 150; 
        else if (audit[ex.target_grade]?.val < 70) tickets += 50; 

        // B. Pain Synergy (The Override)
        if (ex.synergies && ex.synergies.some(s => symptoms.includes(s))) {
            tickets += 500; 
// B. Pain Synergy + Severity (Dynamic Multiplier)
let painBoost = 0;
if (ex.synergies && Array.isArray(ex.synergies)) {  // Guard Array.isArray
    const matches = ex.synergies.filter(s => symptoms.includes(s)).length;
    painBoost = matches * 300 * (1 + symptomSeverity); // Base 300, up to 600 if severe
    if (affectedParts.has(ex.target_grade)) painBoost *= 1.5; // Combo 50% extra
}
tickets += painBoost;
        }

        // C. Phase Alignment
        if (ex.phase === userPhase) tickets += 150;       
        else if (ex.phase === userPhase - 1) tickets += 50; 
        else if (ex.phase > userPhase) tickets = 0; // Hard lock on future content

// In lotteryPool map, after C:
if (currentTheme === 'power' && (ex.pattern ?.includes('power') || false)) {
    tickets += 200;
} else if (currentTheme === 'recovery' && (ex.pattern ?.includes('release') || false)) {
    tickets += 200;
} else if (currentTheme === 'mobility' && (ex.pattern ?.includes('flow') || false)) {
    tickets += 200;
}

        // D. VARIANCE ENGINE (The Fix)
        const hist = exerciseHistory[ex.id];
        const lastDate = hist?.lastUsed;
        const today = new Date().toDateString();
        
        // 1. Immediate Staleness (Nuclear Penalty)
        // If done today, reduce chance by 99% (but leave 1% in case DB is small)
        if (lastDate === today) tickets *= 0.01; 

        // 2. Inverse Frequency (The "Variety" Enforcer)
        // The more you've done it, the less likely it is.
        const timesDone = globalUsage[ex.id] || 0;
        if (timesDone > 0) {
            // Decay formula: Tickets / (1 + (timesDone * 0.2))
            // Example: Done 5 times = Tickets / 2.
            tickets = tickets / (1 + (timesDone * 0.25)); 
        }

        // 3. Discovery Bonus (The "New" Boost)
        if (!hist) tickets += 400; // Massive boost for untouched exercises

        // 4. Session Exclusion (Prevent "Generate" -> "Generate" duplicates)
        // If this exercise is in the currently displayed routine, kill its tickets
        if (activeProgram && activeProgram.some(p => p.id === ex.id)) {
             tickets *= 0.001;
        }

        return { ...ex, tickets: Math.max(1, Math.floor(tickets)) };
    }).filter(e => e && e.tickets > 0);

    // 5. ROULETTE WHEEL SELECTION 
    // This replaces the "Sort and Slice" method. 
    // It creates a probability distribution so lower scores still have a chance.
    const routine = [];
    const usedPatterns = new Set();
    const usedIDs = new Set();

    const drawFromPool = (pool, criteriaFn, reasonLabel) => {
        // Filter candidates
        let candidates = pool.filter(ex => !usedIDs.has(ex.id) && criteriaFn(ex));
        
        // Pattern diversity filter (Soft filter)
        const freshPatternCandidates = candidates.filter(ex => !usedPatterns.has(ex.pattern));
        if (freshPatternCandidates.length > 0) candidates = freshPatternCandidates;

        if (candidates.length === 0) return null;

        // ROULETTE LOGIC
        const totalWeight = candidates.reduce((sum, ex) => sum + ex.tickets, 0);
        let randomValue = Math.random() * totalWeight;
        let selected = null;

        for (const ex of candidates) {
            randomValue -= ex.tickets;
            if (randomValue <= 0) {
                selected = ex;
                break;
            }
        }
        // Fallback (rare rounding errors)
        if (!selected) selected = candidates[candidates.length - 1];

        if (selected) {
            routine.push({ ...selected, smartReason: reasonLabel });
            usedPatterns.add(selected.pattern);
            usedIDs.add(selected.id);
        }
        return selected;
    };

    // --- SLOT CONFIGURATION ---

    // Slot 1: The Critical Fix (Must hit weak link or pain)
    drawFromPool(lotteryPool, ex => ex.target_grade === weakestLink || (ex.synergies && ex.synergies.some(s => symptoms.includes(s))), `Primary Fix: ${weakestLink.toUpperCase()}`);

    // Slot 2: The Secondary Support
    drawFromPool(lotteryPool, ex => ex.target_grade === secondaryLink, `Support: ${secondaryLink.toUpperCase()}`);

    // Slot 3: Phase Power (The "Fun" one)
    drawFromPool(lotteryPool, ex => ex.phase === userPhase, `Phase ${userPhase} Power`);

    // Slot 4: Structural Balance (Opposite pattern of what we've picked)
    drawFromPool(lotteryPool, ex => true, "Structural Balance");

    // Slot 5: Discovery (Prioritize things with high tickets - likely new ones)
    drawFromPool(lotteryPool, ex => !exerciseHistory[ex.id], "New Stimulus");

    // Slot 6: Wildcard (Pure Chaos)
    drawFromPool(lotteryPool, ex => true, "System Flush");

    // Failsafe fill
    while (routine.length < 4 && lotteryPool.length > routine.length) {
        drawFromPool(lotteryPool, ex => true, "Volume Filler");
    }

    // 6. BUILD FINAL OBJECTS
    const finalRoutine = routine.map(ex => {
        const hist = exerciseHistory[ex.id] || {};
        let levelIdx = hist.lastLevel || 0;

        // Smart Progression
        if (hist.lastRating === 'easy') levelIdx = Math.min(ex.levels.length - 1, levelIdx + 1);
        else if (hist.lastRating === 'hard') levelIdx = Math.max(0, levelIdx - 1);
        else if (userPhase >= 3 && ex.levels.length > 2) levelIdx = Math.max(levelIdx, 1);

// MASTERY GATE: Lock levels >2 until phase >=3 or goodStreaks >=2
if (levelIdx > 1 && (userPhase < 3 || hist.goodStreaks < 2)) {
    levelIdx = 1; // Force regress to safe level
}

        const levelData = ex.levels[levelIdx] || ex.levels[0];
        let duration = levelData.duration || 60;
        if (userPhase >= 4) duration += 30; 

        return {
            ...levelData,
            id: ex.id,
            baseTitle: ex.title,
            reason: ex.smartReason,
            allLevels: ex.levels,
            currentLevelIdx: levelIdx,
            duration: duration
        };
    });

    setGeneratedRoutine(finalRoutine);
    addLog(`V101 Logic: Generated ${finalRoutine.length} Unique Vectors`);
};
    // --- PRESET LOADER ---
   const loadPreset = (presetName) => {
    const exerciseIds = PRESET_PROTOCOLS[presetName];
    if (!exerciseIds || exerciseIds.length === 0) return;

    let routine = exerciseIds.map((id, overallIdx) => {
        const ex = EXERCISE_DB.find(e => e.id === id);
        if (!ex) return null;

        // FORCE level 0 (first level) for head_loading_progression
        // For all other exercises, use smart progression (level 1 or saved)
        let levelIdx = 0;
        if (id !== "head_loading_progression") {
            const hist = exerciseHistory[id] || {};
            levelIdx = hist.lastLevel || (ex.levels.length > 1 ? 1 : 0);
        }

        const levelData = ex.levels[levelIdx];

        return {
            ...levelData,
            id: ex.id,
            baseTitle: ex.title,
            reason: presetName,
            allLevels: ex.levels,
            currentLevelIdx: levelIdx,
            duration: levelData.duration || 90
        };
    }).filter(Boolean);

    setActiveProgram(routine);
    addLog(`Loaded ${presetName} — ${routine.length} movements`);
};
    // NEW: Update Goal Handler
    const updateGoal = () => setShowGoalSetter(true);

    return (
        <div className={`workspace bg-slate-950 text-white selection:bg-cyan-500 selection:text-black ${postAnalysisMode ? 'post-analysis' : ''}`}>
            {cameraActive && <CameraCapture onClose={() => setCameraActive(null)} onCapture={(url) => {
                setUploads(prev => ({ ...prev, [cameraActive]: { url, analyzed: false } }));
                setCameraActive(null);
                addLog(`Captured ${cameraActive} view via Camera`);
            }} />}

            {/* LIVE REAL-TIME MODE OVERLAY */}
                        {liveMode && (
                <div className="fixed inset-0 bg-black/95 z-[70] flex flex-col items-center justify-center p-4 animate-popIn">
                    <div className="relative w-full max-w-4xl h-[80vh] bg-slate-900 rounded-3xl overflow-hidden shadow-2xl border border-cyan-500/50">
                        {/* Webcam Video (mirrored) */}
                        <video
                            ref={liveVideoRef}
                            autoPlay
                            playsInline
                            muted
                            className="absolute inset-0 w-full h-full object-cover scale-x-[-1]"
                        />

                        {/* Live Skeleton Canvas */}
                        <canvas
                            ref={liveCanvasRef}
                            className="absolute inset-0 w-full h-full pointer-events-none"
                        />

                        <div className="absolute top-8 left-1/2 -translate-x-1/2 bg-black/70 backdrop-blur px-10 py-5 rounded-2xl border border-cyan-500 shadow-2xl text-center">
                            <div className="text-4xl font-black text-cyan-400">
                                {liveKeypoints 
                                    ? (liveCountdown !== null ? `CAPTURING IN ${liveCountdown}...` : "GOOD POSE LOCKED!")
                                    : "FINDING POSE..."
                                }
                            </div>

                            {liveScore !== null && (
                                <div className="mt-4 text-6xl font-black text-white">
                                    {liveScore}<span className="text-2xl text-cyan-400">%</span>
                                </div>
                            )}

                            <div className="text-sm text-slate-300 mt-4 max-w-md">
                                {liveKeypoints 
                                    ? "Hold steady — capturing front view automatically"
                                    : "Step back • Full body visible • Arms at sides • Face camera directly"
                                }
                            </div>
                        </div>

                        {cameraError && (
                            <div className="absolute inset-0 flex items-center justify-center bg-red-900/80 backdrop-blur">
                                <div className="text-center">
                                    <div className="text-4xl font-black text-white mb-4">Camera Blocked</div>
                                    <p className="text-white mb-4">Please allow camera access</p>
                                    <button 
                                        onClick={() => setLiveMode(false)}
                                        className="px-6 py-3 bg-white text-black rounded-xl font-bold"
                                    >
                                        Back
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Countdown Number */}
                        {liveCountdown !== null && (
                            <div className="absolute inset-0 flex items-center justify-center text-9xl font-black text-white animate-ping">
                                {liveCountdown}
                            </div>
                        )}

                        {/* Close Button */}
                        <button
                            onClick={() => {
                                setLiveMode(false);
                                if (liveVideoRef.current?.srcObject) {
                                    liveVideoRef.current.srcObject.getTracks().forEach(track => track.stop());
                                }
                                setLiveKeypoints(null);
                                setLiveCountdown(null);
                            }}
                            className="absolute top-6 right-6 w-16 h-16 bg-red-600/90 hover:bg-red-500 rounded-full flex items-center justify-center text-white text-3xl font-bold shadow-2xl"
                        >
                            ✕
                        </button>
                    </div>
                </div>
            )}

            {/* ALL MODALS IN ONE FRAGMENT */}
            <>
                {isModelLoading && (
                    <div className="fixed inset-0 bg-black/90 z-[100] flex flex-col items-center justify-center backdrop-blur-xl animate-popIn">
                        <div className="w-20 h-20 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-6"></div>
                        <div className="text-cyan-400 font-black text-xl tracking-widest animate-pulse">DOWNLOADING NEURAL CORE V85...</div>
                        <div className="text-slate-500 text-xs mt-2 uppercase">Initial load may take 5-10 seconds</div>
                    </div>
                )}
                {showReader && <ReaderMode item={showReader} onClose={() => setShowReader(null)} />}
                {showGoalSetter && <GoalSetter currentGoal={currentGoal} onSave={saveGoal} onClose={() => setShowGoalSetter(false)} />}
                {showShare && <ShareReport audit={audit} onClose={() => setShowShare(false)} />}
{showClinical && <ClinicalDashboard audit={audit} onClose={() => setShowClinical(false)} />}
            </>

            <div ref={viewportRef} className={`viewport ${status.analyzing ? 'analyzing-blur-fix' : ''}`}>


                <div className="text-center px-6">
                    <h1 className="text-5xl md:text-6xl font-black text-white mb-4 tracking-tight bg-gradient-to-r from-cyan-400 via-blue-500 to-cyan-400 bg-clip-text text-transparent animate-popIn">
                        MOVEMENT MECHANICS
                    </h1>
                    <p className="text-xl md:text-2xl text-slate-300 mb-4 max-w-5xl mx-auto leading-relaxed opacity-90">
                        Upload photos → Get an instant biomechanical analysis + personalized training protocol.
                    </p>

<div className="text-center mb-8">
    <p className="text-lg text-cyan-400 font-medium tracking-wide">
        Completely free • 100% private (nothing leaves your browser)
    </p>
</div>
                    {postAnalysisMode && audit && (
                        <div className="mb-12 p-6 md:p-10 bg-gradient-to-r from-purple-900/40 via-cyan-900/40 to-blue-900/40 rounded-3xl border-2 border-cyan-500/50 text-center animate-popIn shadow-2xl shadow-cyan-900/50 mx-2 md:mx-8 overflow-hidden">
                            <p className="text-sm md:text-xl font-bold text-cyan-300 mb-4 uppercase tracking-widest opacity-80">Today's Primary Limitation</p>

                            <div className="flex justify-center items-center py-2">
                                <h2 className="text-3xl sm:text-4xl md:text-6xl font-black text-white leading-tight tracking-tight uppercase">
                                    <span style={{ display: 'block', whiteSpace: 'normal', wordBreak: 'keep-all' }}>
                                        {Object.keys(audit).find(k => audit[k] && (audit[k].grade === 'F' || audit[k].grade === 'D'))?.replace(/_/g, ' ').toUpperCase() || 'PERFECT BALANCE'}
                                    </span>
                                </h2>
                            </div>

                            {/* ROBUST SCORE DISPLAY */}
                            <div className="mt-2 text-center">
                                <span className={`text-4xl font-black ${(audit.score || 0) < 50 ? 'text-red-500' : (audit.score || 0) < 80 ? 'text-orange-400' : 'text-emerald-400'
                                    }`}>
                                    SCORE: {isNaN(audit.score) ? 0 : audit.score}%
                                </span>
                            </div>

                            <p className="text-base md:text-xl text-slate-300 max-w-2xl mx-auto mt-6 leading-relaxed italic opacity-90">
                                Your entire protocol is laser-focused on resolving this first.
                            </p>
                        </div>
                    )}
                </div>
                {/* HEADER NAV - ENHANCED with Progress Tab */}
                                <div className="flex justify-between items-center mb-2 no-print">
                    <div className="w-full max-w-4xl mx-auto space-y-8">
                        

                        {/* ORIGINAL: STANDARD ANALYSIS BUTTON */}
                        <button
                            onClick={() => { if (!status.analyzing && ready) runAnalysis(); }}
                            disabled={status.analyzing || !ready}
                            className={`
                                btn-primary 
                                w-full 
                                text-3xl py-8 
                                rounded-3xl 
                                font-black 
                                uppercase 
                                tracking-widest 
                                shadow-2xl shadow-cyan-900/60
                                bg-size-200
                                ${ready && !status.analyzing
                                    ? 'animate-pulse-slow bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600 bg-pos-0 hover:bg-pos-100'
                                    : 'opacity-60 bg-gradient-to-r from-slate-600 to-slate-700'
                                }
                                transition-all duration-1000
                            `}
                        >
                            {status.analyzing ? "NEURAL ANALYSIS IN PROGRESS..." : ready ? "ANALYZE MY POSTURE" : "UPLOAD PHOTOS TO BEGIN"}
                        </button>
                    </div>
                </div>

                {tab === 'dashboard' ? (
                    <>
                        {/* COMBINED SIDE-BY-SIDE: SYMPTOMS (Left) & PRESETS (Right) */}
<div className="mb-6 no-print grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
    
    {/* LEFT: Pain Selectors */}
    <div className="bg-slate-900/30 p-3 rounded-xl border border-slate-800/50">
        <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">Pain / Symptoms</div>
        <div className="flex flex-wrap gap-2">
            {['Neck Pain', 'Back Pain', 'Knee Pain', 'Foot Pain'].map(sym => (
                <div key={sym} onClick={() => toggleSymptom(sym)} className={`symptom-chip ${symptoms.includes(sym) ? 'selected' : ''}`}>
                    {symptoms.includes(sym) && <Icons.Check />} {sym}
                </div>
            ))}
        </div>
    </div>

    {/* RIGHT: Quick Start Chips */}
    <div className="bg-slate-900/30 p-3 rounded-xl border border-slate-800/50">
        <div className="text-[10px] font-bold text-slate-500 uppercase mb-2 flex justify-between items-center">
            <span>Quick Start Protocols</span>
            <span className="text-cyan-600 text-[9px] bg-cyan-900/20 px-1.5 py-0.5 rounded border border-cyan-900/30">NO SCAN NEEDED</span>
        </div>
        <div className="flex flex-wrap gap-2">
            {Object.keys(PRESET_PROTOCOLS).map((presetName) => (
                <button 
                    key={presetName} 
                    onClick={() => loadPreset(presetName)}
                    className="px-2 py-1 bg-slate-800 hover:bg-cyan-900/20 border border-slate-700 hover:border-cyan-500/30 rounded text-[9px] font-bold text-slate-400 hover:text-cyan-400 transition-all uppercase tracking-wider flex items-center gap-1 shadow-sm"
                >
                    <Icons.Play className="w-2 h-2" /> {presetName}
                </button>
            ))}
        </div>
    </div>
</div>



                        {/* THIS MAKES THE 3 BOXES BIG AND NOT CUT OFF */}
                        <div className="flex-1 upload grid">
                            <div className="upload-grid gap-6 px-4">
                                {['front', 'side', 'back'].map(view => (
                                    <div key={view} className={`upload-slot ${uploads[view] ? 'active' : ''} ${status.analyzing && uploads[view] ? 'analyzing' : ''}`}>
                                        {uploads[view] ? (
                                            <div className="w-full h-full relative">
                                                <img
                                                    ref={el => { if (el) uploadRefs[view].current = el; }}
                                                    src={uploads[view].url}
                                                    className="absolute inset-0 w-full h-full object-cover opacity-0"
                                                    crossOrigin="anonymous"
                                                    alt={`User's ${view} body view for posture analysis`}
                                                />
                                                <canvas
                                                    id={`canvas-${view}`}
                                                    className="absolute inset-0 w-full h-full object-cover pointer-events-none z-10"
                                                />
                                                <div className="absolute top-2 right-2 bg-emerald-500 text-black text-[10px] font-bold px-2 py-1 rounded flex items-center gap-1 z-20"><Icons.Check /> ANALYZED</div>
                                                <div className="absolute inset-0 bg-black/40 opacity-0 hover:opacity-100 transition-opacity flex items-center justify-center text-xs font-bold uppercase tracking-widest z-20 cursor-pointer" onClick={() => uploadRefs[view].current.click()}>
                                                    Click to Change
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center h-full gap-8 relative">
                                                {/* Silhouette Guide */}
                                                <div className="absolute inset-0 flex items-center justify-center opacity-10 pointer-events-none">
                                                    <svg viewBox="0 0 200 400" className="w-1/2">
                                                        <circle cx="100" cy="60" r="30" fill="none" stroke="#22d3ee" strokeWidth="4" />
                                                        <rect x="70" y="100" width="60" height="120" rx="20" fill="none" stroke="#22d3ee" strokeWidth="4" />
                                                        <line x1="70" y1="140" x2="40" y2="200" stroke="#22d3ee" strokeWidth="4" />
                                                        <line x1="130" y1="140" x2="160" y2="200" stroke="#22d3ee" strokeWidth="4" />
                                                        <line x1="80" y1="220" x2="70" y2="320" stroke="#22d3ee" strokeWidth="4" />
                                                        <line x1="120" y1="220" x2="130" y2="320" stroke="#22d3ee" strokeWidth="4" />
                                                    </svg>
                                                </div>

                                                <div className="text-center z-10">
                                                    <p className="text-3xl font-black text-white mb-2 uppercase tracking-wider">{view}</p>
                                                    <p className="text-sm text-slate-400">Tap to upload or use camera</p>
                                                </div>

                                                <div className="flex gap-6 z-10">
                                                    <button onClick={() => uploadRefs[view].current.click()} className="px-8 py-4 bg-cyan-600 hover:bg-cyan-500 rounded-xl font-bold text-lg shadow-lg shadow-cyan-900/50 transition-all hover:scale-105">
                                                        Upload Photo
                                                    </button>
                                                    <button onClick={() => setCameraActive(view)} className="px-8 py-4 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-lg shadow-lg transition-all hover:scale-105">
                                                        Camera
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                        <div className="scanner-line"></div>
                                        <input type="file" ref={uploadRefs[view]} className="hidden" accept="image/*" onChange={(e) => handleFile(e, view)} />
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* LOGS AT BOTTOM */}
                        <div className="mt-4 flex gap-4 text-[10px] font-mono text-slate-500 bg-slate-900/50 p-2 rounded border border-slate-800 no-print">
                            {status.logs.map((l, i) => <span key={i}>{l}<br /></span>)}
                        </div>

                        {/* NEW: POST-ANALYSIS RESULTS PAGE - IMMEDIATE FEEDBACK */}
                        {status.analyzed && !status.analyzing && (
                            <div className="mt-12 animate-fadeIn">
                                {/* Hero Score + Avatar Section */}
                                <div className="bg-gradient-to-b from-cyan-900/40 to-purple-900/40 rounded-3xl p-8 shadow-2xl border border-cyan-500/30">
                                    <h2 className="text-4xl font-black text-center text-white mb-8 uppercase tracking-wider">Your Posture Score</h2>

                                    {/* Circular Gauge for Overall Score */}
                                    <div className="flex flex-col items-center mb-12">
                                        <div className="relative w-64 h-64">
                                            {/* Simple SVG Circular Progress Gauge */}
                                            <svg className="w-full h-full -rotate-90">
                                                <circle cx="128" cy="128" r="120" stroke="#1e293b" strokeWidth="16" fill="none" />
                                                <circle
                                                    cx="128" cy="128" r="120"
                                                    stroke={audit.score >= 80 ? "#10b981" : audit.score >= 60 ? "#f59e0b" : "#ef4444"}
                                                    strokeWidth="16"
                                                    fill="none"
                                                    strokeDasharray={`${2 * Math.PI * 120}`}
                                                    strokeDashoffset={`${2 * Math.PI * 120 * (1 - audit.score / 100)}`}
                                                    className="transition-all duration-2000 ease-out"
                                                    strokeLinecap="round"
                                                />
                                            </svg>
                                            <div className="absolute inset-0 flex items-center justify-center">
                                                <div className="text-center">
                                                    <div className="text-7xl font-black text-white">{audit.score}</div>
                                                    <div className="text-xl font-bold text-slate-300 uppercase tracking-wider">/100</div>
                                                </div>
                                            </div>
                                        </div>
                                        <p className="mt-6 text-2xl font-bold text-center text-white">
                                            {audit.score >= 80 ? "Excellent Alignment!" : audit.score >= 60 ? "Good, Room to Improve" : "Needs Attention"}
                                        </p>
                                    </div>

                                    {/* Digital Avatar - Simple Stick Figure Skeleton */}
                                    <div className="max-w-md mx-auto bg-black/60 rounded-2xl p-6 border border-cyan-400/50">
                                        <h3 className="text-xl font-bold text-center text-cyan-300 mb-4 uppercase">Your Biomechanical Avatar</h3>
                                        <div className="relative aspect-[3/5] bg-slate-900 rounded-xl overflow-hidden">
                                            {/* Composite background from side view or averaged */}
                                            {uploads.side && (
                                                <img src={uploads.side.url} className="absolute inset-0 w-full h-full object-cover opacity-30" alt="Background" />
                                            )}
                                            {/* SVG Skeleton Overlay - use keypoints from analysis */}
                                            <svg className="absolute inset-0 w-full h-full" viewBox="0 0 300 600" preserveAspectRatio="xMidYMid meet">
                                                {sideKeypoints ? (
                                                    <>
                                                        {/* Head - Nose (0), Ears (7,8), Eyes avg */}
                                                        {sideKeypoints[0]?.score > 0.5 && (
                                                            <circle
                                                                cx={150 + (sideKeypoints[0].x - 0.5) * 200}
                                                                cy={80 + (sideKeypoints[0].y - 0.2) * 400}
                                                                r="30"
                                                                fill={audit?.head.grade === 'F' ? '#ef4444' : audit?.head.grade === 'D' ? '#f59e0b' : '#22d3ee'}
                                                                opacity="0.8"
                                                            />
                                                        )}

                                                        {/* Spine: Shoulder (11/12 avg) → Hip (23/24 avg) */}
                                                        {(() => {
                                                            const leftShoulder = sideKeypoints[11];
                                                            const rightShoulder = sideKeypoints[12];
                                                            const leftHip = sideKeypoints[23];
                                                            const rightHip = sideKeypoints[24];

                                                            if (leftShoulder?.score > 0.5 && rightShoulder?.score > 0.5) {
                                                                const shoulderX = (leftShoulder.x + rightShoulder.x) / 2 * 300;
                                                                const shoulderY = (leftShoulder.y + rightShoulder.y) / 2 * 600;
                                                                const hipX = leftHip && rightHip ? (leftHip.x + rightHip.x) / 2 * 300 : shoulderX;
                                                                const hipY = leftHip && rightHip ? (leftHip.y + rightHip.y) / 2 * 600 : shoulderY + 200;

                                                                return (
                                                                    <line
                                                                        x1={shoulderX} y1={shoulderY}
                                                                        x2={hipX} y2={hipY}
                                                                        stroke={audit?.spine.grade === 'F' ? '#ef4444' : audit?.spine.grade === 'D' ? '#f59e0b' : '#22d3ee'}
                                                                        strokeWidth="12"
                                                                        strokeLinecap="round"
                                                                    />
                                                                );
                                                            }
                                                        })()}

                                                        {/* Arms - Left side visible in side view */}
                                                        {sideKeypoints[11]?.score > 0.5 && sideKeypoints[13]?.score > 0.5 && sideKeypoints[15]?.score > 0.5 && (
                                                            <>
                                                                <line x1={sideKeypoints[11].x * 300} y1={sideKeypoints[11].y * 600}
                                                                    x2={sideKeypoints[13].x * 300} y2={sideKeypoints[13].y * 600}
                                                                    stroke={audit?.shoulders.grade === 'F' ? '#ef4444' : audit?.shoulders.grade === 'D' ? '#f59e0b' : '#22d3ee'}
                                                                    strokeWidth="10" />
                                                                <line x1={sideKeypoints[13].x * 300} y1={sideKeypoints[13].y * 600}
                                                                    x2={sideKeypoints[15].x * 300} y2={sideKeypoints[15].y * 600}
                                                                    stroke={audit?.shoulders.grade === 'F' ? '#ef4444' : audit?.shoulders.grade === 'D' ? '#f59e0b' : '#22d3ee'}
                                                                    strokeWidth="10" />
                                                            </>
                                                        )}

                                                        {/* Legs */}
                                                        {sideKeypoints[23]?.score > 0.5 && sideKeypoints[25]?.score > 0.5 && sideKeypoints[27]?.score > 0.5 && (
                                                            <>
                                                                <line x1={sideKeypoints[23].x * 300} y1={sideKeypoints[23].y * 600}
                                                                    x2={sideKeypoints[25].x * 300} y2={sideKeypoints[25].y * 600}
                                                                    stroke={audit?.hip.grade === 'F' ? '#ef4444' : audit?.hip.grade === 'D' ? '#f59e0b' : '#10b981'}
                                                                    strokeWidth="12" />
                                                                <line x1={sideKeypoints[25].x * 300} y1={sideKeypoints[25].y * 600}
                                                                    x2={sideKeypoints[27].x * 300} y2={sideKeypoints[27].y * 600}
                                                                    stroke={audit?.gait.grade === 'F' ? '#ef4444' : audit?.gait.grade === 'D' ? '#f59e0b' : '#10b981'}
                                                                    strokeWidth="12" />
                                                            </>
                                                        )}
                                                    </>
                                                ) : (
                                                    // Fallback static skeleton while loading
                                                    <>
                                                        <circle cx="150" cy="80" r="30" fill="#22d3ee" opacity="0.6" />
                                                        <line x1="150" y1="110" x2="150" y2="400" stroke="#22d3ee" strokeWidth="8" opacity="0.6" />
                                                        <line x1="150" y1="150" x2="100" y2="300" stroke="#22d3ee" strokeWidth="8" opacity="0.6" />
                                                        <line x1="150" y1="150" x2="200" y2="300" stroke="#22d3ee" strokeWidth="8" opacity="0.6" />
                                                    </>
                                                )}
                                            </svg>
                                        </div>
                                        <p className="text-center text-sm text-slate-400 mt-4">Red = Major Deviation | Orange = Moderate | Green = Good</p>
                                    </div>
                                </div>
                            </div>
                        )}
                        {/* Quick Insights Chips */}
                        <div className="mt-12">
                            <h3 className="text-2xl font-bold text-center text-white mb-6 uppercase tracking-wider">Key Findings</h3>
                            <div className="flex flex-wrap justify-center gap-4">
                                {audit && [
                                    ...(audit.head.grade === 'F' || audit.head.grade === 'D' ? [{ name: "Forward Head Posture", severity: audit.head.grade === 'F' ? 'high' : 'medium' }] : []),
                                    ...(audit.shoulders.grade === 'F' || audit.shoulders.grade === 'D' ? [{ name: "Rounded / Uneven Shoulders", severity: audit.shoulders.grade === 'F' ? 'high' : 'medium' }] : []),
                                    ...(audit.spine.grade === 'F' || audit.spine.grade === 'D' ? [{ name: "Spinal Compression", severity: audit.spine.grade === 'F' ? 'high' : 'medium' }] : []),
                                    ...(audit.hip.grade === 'F' || audit.hip.grade === 'D' ? [{ name: "Pelvic Tilt / Hip Shift", severity: audit.hip.grade === 'F' ? 'high' : 'medium' }] : []),
                                    ...(audit.gait.grade === 'F' || audit.gait.grade === 'D' ? [{ name: "Weak Elastic Recoil", severity: audit.gait.grade === 'F' ? 'high' : 'medium' }] : []),
                                ].map((dev, i) => (
                                    <div key={i} className={`px-6 py-3 rounded-full font-bold text-lg shadow-lg transition-all hover:scale-105 ${dev.severity === 'high' ? 'bg-red-600 text-white' :
                                        'bg-orange-500 text-black'
                                        }`}>
                                        {dev.name}
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* ACADEMY LINK - RESTORED */}
                        <div className="mt-8 text-center pt-8 border-t border-slate-800">
                            <p className="text-sm font-bold text-slate-500 uppercase mb-4">WANT TO LEARN THE SCIENCE?</p>
                            <button onClick={() => setTab('academy')} className="px-8 py-3 bg-gradient-to-r from-slate-800 to-slate-900 border border-slate-700 hover:border-cyan-500 rounded-xl text-slate-300 font-bold flex items-center gap-2 mx-auto hover:text-cyan-400 transition-all">
                                <Icons.Video /> OPEN MOVEMENT ACADEMY
                            </button>
                        </div>

                        {/* LOGS AT BOTTOM */}
                        <div className="mt-4 flex gap-4 text-[10px] font-mono text-slate-500 bg-slate-900/50 p-2 rounded border border-slate-800 no-print">
                            {status.logs.map((l, i) => <span key={i}>{l}<br /></span>)}
                        </div>
                    </>
                ) : tab === 'progress' ? (
    <div className="p-6 space-y-8 overflow-y-auto">
        <div className="text-center mb-8">
            <h2 className="text-3xl font-black text-white mb-2">Progress Dashboard</h2>
            <p className="text-slate-400 text-lg">Watch your body evolve — one scan at a time.</p>
        </div>
        <StreakTracker streakDays={streakDays} onReset={resetStreak} />
        <GoalTracker
            currentScore={audit?.score || history[0]?.score || 0}
            targetScore={currentGoal.target}
            progress={currentGoal}
            forecast={audit?.forecast || history[0]?.forecast || null}
            onUpdateGoal={updateGoal}
        />
        
        {/* ADDED COMPONENTS HERE */}
        <TrendGraph history={history} />
        <FascialLineTrends history={history} />
        
        <div className="bg-slate-900/50 border border-slate-700 rounded-lg p-6">
            <h3 className="text-lg font-black text-white mb-4 flex items-center gap-3">
                <Icons.Award /> Milestones
            </h3>
            <div className="space-y-3">
                {achievements.map(a => (
                    <div key={a.id} className={`flex items-center justify-between p-4 rounded-xl border ${a.unlocked ? 'bg-emerald-900/30 border-emerald-600' : 'bg-slate-800/50 border-slate-700'}`}>
                        <div className="flex items-center gap-4">
                            <div className={`w-12 h-12 rounded-full flex items-center justify-center ${a.unlocked ? 'bg-emerald-600' : 'bg-slate-700'}`}>
                                {a.icon}
                            </div>
                            <div>
                                <div className="font-bold text-white">{a.name}</div>
                                <div className="text-xs text-slate-400">{a.desc}</div>
                            </div>
                        </div>
                        {a.unlocked && <Icons.Check className="text-emerald-400 w-8 h-8" />}
                    </div>
                ))}
            </div>
        </div>
        {audit && (
            <button onClick={() => setShowShare(true)} className="w-full py-4 bg-gradient-to-r from-cyan-600 to-purple-600 hover:from-cyan-500 hover:to-purple-500 text-white font-black rounded-2xl uppercase tracking-wider shadow-2xl shadow-cyan-900/50 flex items-center justify-center gap-3">
                <Icons.Share /> Share Progress Report
            </button>
        )}
    </div>
                ) : (
                    // Fallback to Academy for 'academy' or any unknown tab
                    <div className="min-h-screen bg-slate-950">
                        <KnowledgeBase onOpen={setShowReader} />
                    </div>
                )}
            </div>

            {/* RIGHT PANEL - The Value Engine */}
            {/* Removed 'flex flex-col' so it doesn't squeeze the content */}
            <div className={`glass-panel flex flex-col ${postAnalysisMode ? 'expanded' : ''}`}>
                {/* Removed 'shrink-0' because we aren't flexing anymore */}

                <div ref={rightPanelRef} className="p-6 border-b border-slate-800 bg-slate-900/50 flex-1 overflow-y-auto">

{/* OPTIMIZED HEADER: Perfect spacing, slightly smaller buttons & numbers */}
<div className="relative mb-10 pt-4"> {/* Reduced bottom margin, added top padding */}

    {/* Top Nav Buttons - Slightly smaller, more compact */}
    <div className="flex justify-center gap-3 mb-10 px-6"> {/* Reduced gap & added horizontal padding */}
        <button 
            onClick={() => { 
                setTab('dashboard'); 
                setPostAnalysisMode(false);
            }} 
            className={`px-7 py-3 text-base font-black uppercase tracking-widest rounded-xl transition-all duration-300 shadow-lg ${
                tab === 'dashboard' 
                    ? 'bg-gradient-to-r from-cyan-500 to-blue-600 text-white shadow-cyan-900/50' 
                    : 'bg-slate-800/50 text-slate-400 hover:text-white hover:bg-slate-700'
            }`}
        >
            SCAN
        </button>
        <button 
            onClick={() => { 
    if (audit) {
        setShowClinical(true); 
    } else {
        alert("Please perform a scan first to generate 3D data.");
    }
}}
            className={`px-7 py-3 text-base font-black uppercase tracking-widest rounded-xl transition-all duration-300 shadow-lg ${
                tab === 'progress' 
                    ? 'bg-gradient-to-r from-indigo-500 to-purple-600 text-white shadow-indigo-900/50' 
                    : 'bg-slate-800/50 text-slate-400 hover:text-white hover:bg-slate-700'
            }`}
        >
            DATA
        </button>
        <button 
            onClick={() => { 
                setTab('academy'); 
                setPostAnalysisMode(false);
            }} 
            className={`px-7 py-3 text-base font-black uppercase tracking-widest rounded-xl transition-all duration-300 shadow-lg ${
                tab === 'academy' 
                    ? 'bg-gradient-to-r from-emerald-500 to-teal-600 text-white shadow-emerald-900/50' 
                    : 'bg-slate-800/50 text-slate-400 hover:text-white hover:bg-slate-700'
            }`}
        >
            LEARN
        </button>
    </div>

    {/* Score + Bio Age Row - Slightly smaller numbers, better vertical alignment */}
    <div className="flex justify-center items-baseline gap-10 px-6"> 
        {/* Structural Score */}
        <div className="text-center">
            <div className="text-xs font-bold text-cyan-500 uppercase tracking-widest mb-1">Structural Score</div>
            <div className={`text-7xl font-black tracking-tighter leading-none text-yellow-400 ${audit && audit.date !== new Date().toLocaleDateString() ? 'opacity-50' : ''}`}>
                {audit && !isNaN(audit.score) ? audit.score : 0}
            </div>
        </div>

        {/* Biological Age */}
        {audit && (
            <div className="text-center">
                <div className="text-xs font-bold text-red-500 uppercase tracking-widest mb-1">Biological Age</div>
                <div className="text-7xl font-black tracking-tighter leading-none text-red-500">
                    {audit.bioAge}
                </div>
                <div className="text-xs font-bold text-slate-500 uppercase tracking-widest mt-1">Years Old</div>
            </div>
        )}
    </div>
</div>

{/* MY PROTOCOL BUTTON - Appears only after scan */}
                    {/* Change activeProgram to generatedRoutine in the check below */}


                    {/* MY PROTOCOL Button - Always visible after scan */}
                    {audit && (
    <>
                {/* BIG MY PROTOCOL BUTTON - FIXED VERSION */}
        <div className="mt-8 animate-popIn">
            <button
                onClick={() => {
                    // ALWAYS regenerate the latest protocol on click
                    generateProgram();
                    // Use a small timeout to ensure state has updated
                    setTimeout(() => {
                        setActiveProgram(generatedRoutine);
                    }, 100);
                }}
                className="w-full py-10 bg-gradient-to-r from-cyan-500 via-blue-600 to-purple-700 
                       hover:from-cyan-400 hover:via-blue-500 hover:to-purple-600 
                       text-white font-black text-4xl rounded-3xl uppercase tracking-widest 
                       shadow-2xl shadow-cyan-900/80 
                       border-4 border-cyan-400/60
                       transition-all duration-700 hover:scale-105 hover:shadow-cyan-500/50 flex items-center justify-center gap-6"
            >
                <Icons.List className="w-12 h-12" />
                MY PROTOCOL
            </button>
        </div>

        {/* Streak Bonus Message */}
        {streakDays >= 7 && generatedRoutine && (
            <div className="mt-4 p-4 bg-emerald-900/30 border border-emerald-700/50 rounded-xl text-center animate-popIn">
                <div className="text-emerald-400 font-black text-lg flex items-center justify-center gap-2">
                    <Icons.Flame className="streak-flame" /> {streakDays}-DAY STREAK BONUS
                </div>
                <p className="text-xs text-emerald-300 mt-1">+1 Advanced Flow Added</p>
            </div>
        )}

{/* SESSION CONFIGURATOR */}
<div className="mt-12 w-full space-y-3">
    {/* Row 1: Equipment */}
    <div className="flex bg-slate-900 p-1 rounded-xl border border-slate-700">
        <button 
            onClick={() => setUseEquipment(false)} 
            className={`flex-1 py-3 text-xs md:text-sm font-bold rounded-lg transition-all ${!useEquipment ? 'bg-cyan-600 text-white shadow-lg' : 'text-slate-500 hover:text-slate-300'}`}
        >
            BODYWEIGHT
        </button>
        <button 
            onClick={() => setUseEquipment(true)} 
            className={`flex-1 py-3 text-xs md:text-sm font-bold rounded-lg transition-all ${useEquipment ? 'bg-cyan-600 text-white shadow-lg' : 'text-slate-500 hover:text-slate-300'}`}
        >
            + EQUIPMENT
        </button>
    </div>

    {/* Row 2: Intensity */}
    <div className="flex bg-slate-900 p-1 rounded-xl border border-slate-700">
        <button 
            onClick={() => setUserPrefs(p => ({ ...p, lowImpact: true }))} 
            className={`flex-1 py-3 text-xs md:text-sm font-bold rounded-lg transition-all ${userPrefs.lowImpact ? 'bg-emerald-600 text-white shadow-lg' : 'text-slate-500 hover:text-slate-300'}`}
        >
            LOW IMPACT
        </button>
        <button 
            onClick={() => setUserPrefs(p => ({ ...p, lowImpact: false }))} 
            className={`flex-1 py-3 text-xs md:text-sm font-bold rounded-lg transition-all ${!userPrefs.lowImpact ? 'bg-orange-600 text-white shadow-lg' : 'text-slate-500 hover:text-slate-300'}`}
        >
            HIGH INTENSITY
        </button>
    </div>
</div>

<TrendGraph history={history} />

        {/* FASCIAL INTEGRITY REPORT - RIGHT BELOW THE BUTTON */}
        <div className="mt-12 animate-popIn">
            <div className="text-center mb-6">
                <h3 className="text-lg font-black text-cyan-400 uppercase tracking-widest">Fascial Integrity Report</h3>
            </div>
            <div className="space-y-5">
                {[
                    { label: "Superficial Back Line", sub: "Posture / Extension", data: audit.head, risk: "Restriction" },
                    { label: "Deep Front Arm Line", sub: "Shoulder Stability", data: audit.shoulders, risk: "Tightness" },
                    { label: "Deep Front Line", sub: "Core Foundation", data: audit.spine, risk: "Compression" },
                    { label: "Lateral Line", sub: "Hip & Side Balance", data: audit.hip, risk: "Asymmetry" },
                    { label: "Spiral Line", sub: "Rotational Power", data: audit.gait, risk: "Weak Recoil" }
                ].map((m, i) => (
                    <div key={i} className="bg-slate-900/70 backdrop-blur-sm border border-slate-700/80 p-6 rounded-2xl hover:border-cyan-500/60 transition-all shadow-xl">
                        <div className="flex justify-between items-start mb-4">
                            <div>
                                <div className="text-lg font-black text-white">{m.label}</div>
                                <div className="text-xs text-cyan-400 font-bold mt-1">{m.sub}</div>
                            </div>
                            <div className={`text-5xl font-black ${m.data.grade === 'A' ? 'text-emerald-400' : m.data.grade === 'B' ? 'text-blue-400' : m.data.grade === 'C' ? 'text-yellow-400' : m.data.grade === 'D' ? 'text-orange-400' : 'text-red-400'}`}>
                                {m.data.grade}
                            </div>
                        </div>
                        <div className="w-full bg-slate-800 h-4 rounded-full overflow-hidden mb-4">
                            <div className={`h-full transition-all duration-6000 ease-out ${m.data.grade === 'A' ? 'bg-emerald-500' : m.data.grade === 'B' ? 'bg-blue-500' : m.data.grade === 'C' ? 'bg-yellow-500' : m.data.grade === 'D' ? 'bg-orange-500' : 'bg-red-500'}`} 
                                 style={{ width: `${m.data.val}%` }} />
                        </div>
                        <div className="flex justify-between items-center">
                            <span className="text-sm text-slate-300 font-mono">Integrity: {m.data.val}%</span>
                            {m.data.grade !== 'A' && (
                                <span className="text-sm font-bold text-red-400 bg-red-900/40 px-4 py-1 rounded-full border border-red-800/50">
                                    {m.risk}
                                </span>
                            )}
                        </div>
                    </div>
                ))}
            </div>
        </div>

        {/* DIGITAL TWIN + AI COACH */}
        <div className="mt-16 animate-popIn">
            <div className="bg-slate-900/80 rounded-3xl p-8 border-4 border-cyan-600/50 shadow-2xl shadow-cyan-900/60">
                <div className="text-2xl font-black text-cyan-400 mb-6 text-center uppercase tracking-widest">Your Digital Twin</div>
                <div className="w-full max-w-md mx-auto">
                    <BioAvatar audit={audit} symptoms={symptoms} onPartClick={(part) => {
                        const data = audit[part];
                        const analysis = PART_ANALYSIS[part];
                        const message = `**${analysis.title}**\n${analysis.intro(data.grade, data.val)}\n\n**Root Cause:** ${analysis.rootCause}\n\n**Immediate Fix:** ${analysis.fix}\n\n**Key Insight:** ${analysis.insight}\n\nCurrent grade: **${data.grade}** (${data.val}%)`;
                        handleChat(message);
                    }} />
                </div>
                <p className="text-center text-cyan-300 mt-8 text-lg font-bold">Tap any region for deep analysis</p>
            </div>

            <div className="mt-8 bg-slate-900/60 rounded-2xl border border-slate-700 overflow-hidden shadow-2xl">
                <AICoach 
                audit={audit} 
                symptoms={symptoms} 
                chatHistory={chatHistory} 
                onSend={handleChat} 
                onAction={handleCoachAction} 
            />
            </div>
        </div>
    </>
)}

{/* BEFORE / AFTER COMPARISON SLIDER */}
{audit && history.length >= 1 && beforeImage && afterImage && (
    <div className="mt-12 animate-popIn">
        <h3 className="text-xl font-black text-cyan-400 uppercase tracking-widest text-center mb-6">
            Your Progress Slider
        </h3>
        <div className="relative w-full h-96 bg-slate-900/50 rounded-2xl overflow-hidden border border-cyan-500/30">
            {/* After Image (top layer) */}
            <img src={afterImage} className="absolute inset-0 w-full h-full object-contain" alt="Latest" />
            {/* Before Image (bottom layer) */}
            <img src={beforeImage} className="absolute inset-0 w-full h-full object-contain" alt="First scan" />
            {/* Slider Handle */}
            <input
                type="range"
                min="0"
                max="100"
                defaultValue="50"
                className="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-10"
                onInput={(e) => {
                    const val = e.target.value;
                    e.target.parentElement.style.clipPath = `inset(0 ${100 - val}% 0 0)`;
                }}
            />
            {/* Visual Handle */}
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div className="w-12 h-12 bg-white rounded-full shadow-2xl flex items-center justify-center">
                    <svg className="w-6 h-6 text-black" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M8 12h8M12 8v8" />
                    </svg>
                </div>
            </div>
            <div className="absolute bottom-4 left-4 bg-black/70 px-3 py-1 rounded text-xs font-bold text-cyan-300">First Scan</div>
            <div className="absolute bottom-4 right-4 bg-black/70 px-3 py-1 rounded text-xs font-bold text-emerald-300">Today</div>
        </div>
        <p className="text-center text-sm text-slate-400 mt-4">Drag to compare your transformation</p>
    </div>
)}


                    {/* ACADEMY LINK (Right Panel Fallback) */}
                    <div className="mt-6 text-center">
                        <button onClick={() => setTab('academy')} className="text-[10px] font-bold text-slate-500 hover:text-cyan-400 uppercase tracking-widest transition-colors flex items-center justify-center gap-1">
                            <Icons.Video className="w-3 h-3" /> View Academy
                        </button>
                    </div>

                    <div className="mt-6 flex gap-4 no-print justify-center items-center flex-wrap">
                        <button
    onClick={() => {
        setTab('dashboard');
        runAnalysis();
    }}
    disabled={status.analyzing}
    className={`px-6 py-3 rounded-xl text-sm font-bold flex items-center gap-3 transition-all shadow-lg ${
        audit && audit.date !== new Date().toLocaleDateString()
            ? 'bg-cyan-600 hover:bg-cyan-500 text-white animate-pulse shadow-cyan-900/50'
            : 'bg-slate-800 hover:bg-slate-700 disabled:opacity-50 text-white'
    }`}
>
    <Icons.Scan className="w-5 h-5" />
    {audit && audit.date !== new Date().toLocaleDateString() ? "UPDATE SCAN" : "RESCAN"}
</button>
                        <div className="px-6 py-3 bg-slate-800 text-slate-400 rounded-xl text-sm font-bold flex items-center gap-3 shadow-lg">
                            <Icons.History className="w-5 h-5" /> {history.length} SCANS
                        </div>
                    </div>


                </div>

            </div>

            
            {activeProgram && <ProgramPlayer program={activeProgram} onClose={() => setActiveProgram(null)} onFeedback={handleFeedback} />}
        </div>
    );
};


    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>

