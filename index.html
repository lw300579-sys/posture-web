/// --- OMEGA BIOMETRIC ENGINE (V5.0 - DATA TWIN) ---
const BioArchitect3D = ({ landmarks, width = 600, height = 600 }) => {
    const canvasRef = useRef(null);
    const [rotation, setRotation] = useState(0);
    const [autoRotate, setAutoRotate] = useState(true);
    const [cameraMode, setCameraMode] = useState('orbit'); // orbit, follow, cinematic
    const [targetJoint, setTargetJoint] = useState(null);

    // Standard skeletal connections
    const CONNECTIONS = [
        [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], // Arms
        [11, 23], [12, 24], [23, 24],                     // Torso Box
        [23, 25], [25, 27], [27, 29], [29, 31],           // Left Leg
        [24, 26], [26, 28], [28, 30], [30, 32]            // Right Leg
    ];

    // === FULL HOLODECK UPGRADE: ARMS, HANDS + FACE ===
    const FULL_CONNECTIONS = [
        // Keep all the old body bones
        ...CONNECTIONS,

        // Left arm all the way to fingers
        [13, 15], [15, 17], [17, 19], [19, 21], [15, 21], [15, 22],
        // Right arm all the way to fingers  
        [14, 16], [16, 18], [18, 20], [20, 22], [16, 22],

        // Cool face outline (makes it look high-tech)
        [0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10],
        [10, 0], // closes the face loop
    ];

    // Helper: Calculate 3D angle between three points
    const calculate3DAngle = (p1, p2, p3) => {
        if(!p1 || !p2 || !p3) return 0;
        const v1 = {x: p1.x-p2.x, y: p1.y-p2.y, z: p1.z-p2.z};
        const v2 = {x: p3.x-p2.x, y: p3.y-p2.y, z: p3.z-p2.z};
        const dot = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
        const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
        const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);
        const angleRad = Math.acos(dot / (mag1 * mag2));
        return (angleRad * (180/Math.PI)).toFixed(0);
    };

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !landmarks || landmarks.length === 0) return;
        
        const ctx = canvas.getContext('2d');
        let animationFrameId;

        // Configuration for the "Premium" look
        const config = {
            focalLength: 800,   // High focal length = Telephoto lens (Professional look, less distortion)
            boneColor: { r: 34, g: 211, b: 238 }, // Cyan-400
            jointColor: { r: 255, g: 255, b: 255 },
            floorAlpha: 0.15
        };

        const render = () => {
            // 1. SETUP & CLEAR
            ctx.clearRect(0, 0, width, height);
            
            // Medical Vignette Background
            const bgGrad = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width * 0.8);
            bgGrad.addColorStop(0, '#0f172a'); // Slate-900
            bgGrad.addColorStop(1, '#020617'); // Slate-950
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // 2. AUTO-FRAMING ENGINE (Crucial for "Zoomed In" fix)
            // Calculate 3D bounding box relative to center
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            landmarks.forEach(lm => {
                minX = Math.min(minX, lm.x); maxX = Math.max(maxX, lm.x);
                minY = Math.min(minY, lm.y); maxY = Math.max(maxY, lm.y);
            });
            
            // Determine body center and height
            const bodyH = maxY - minY;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            // Dynamic Scale: Fit body height into 60% of canvas height
            // This guarantees full visibility with padding
            const targetScale = (height * 0.6) / Math.max(bodyH, 0.1); 

            // 3. 3D PROJECTION PIPELINE
            const cx = width / 2;
            const cy = height / 2;
                        let rot = rotation;

            // Different camera modes!
            if (cameraMode === 'orbit' && autoRotate) {
                rot += Date.now() * 0.00008;
            }
            if (cameraMode === 'cinematic') {
                const slowSpin = (Date.now() * 0.00003) + Math.sin(Date.now() * 0.00005) * 0.5;
                rot = rot + (slowSpin - rot) * 0.02; // Smooth easing
            }
            if (cameraMode === 'follow' && targetJoint !== null && points[targetJoint]) {
                const target = points[targetJoint];
                const angle = Math.atan2(target.raw.x, target.raw.z) + Math.PI / 2;
                rot = angle + Math.PI / 2;
            }

            // Project 3D point to 2D screen space
            const project = (x, y, z) => {
                // Center the model first
                const dx = x - centerX;
                const dy = y - centerY;
                const dz = (z || 0);

                // Rotate (Y-Axis)
                const cos = Math.cos(rot), sin = Math.sin(rot);
                const rx = dx * cos - dz * sin;
                const rz = dx * sin + dz * cos;

                // Perspective Divide
                const depthOffset = 400; // Push model into screen
                const scaleFactor = config.focalLength / (config.focalLength + rz * 200 + depthOffset);
                
                return {
                    x: cx + rx * targetScale * scaleFactor,
                    y: cy + dy * targetScale * scaleFactor,
                    z: rz, // Depth for sorting
                    s: scaleFactor * targetScale, // Visual scale for thickness
                    raw: { x: rx, y: dy, z: rz } // For angle calc
                };
            };

            const points = landmarks.map(lm => project(lm.x, lm.y, lm.z));

            // 4. ENVIRONMENT: FLOOR GRID & REFLECTION
            // Floor Y position is relative to the lowest foot point projected
            const lowestY = Math.max(...points.map(p => p.y));
            const floorY = lowestY + 20; 

            ctx.save();
            // Draw Grid
            ctx.beginPath();
            ctx.strokeStyle = `rgba(6, 182, 212, ${config.floorAlpha})`;
            ctx.lineWidth = 1;
            
            // Dynamic Horizon Grid
            const horizon = cy; 
            for (let i = -10; i <= 10; i++) {
                // Perspective lines
                const xOffset = i * 50 * Math.cos(rot);
                const zOffset = i * 20 * Math.sin(rot);
                ctx.moveTo(cx + xOffset, horizon);
                ctx.lineTo(cx + i * 150, height);
            }
            // Horizontal depth lines
            for (let j = 0; j < 10; j++) {
                const y = floorY + Math.pow(j, 1.5) * 5;
                if (y > height) break;
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            ctx.stroke();

            // Floor Reflection (Flipped & Faded)
            CONNECTIONS.forEach(([i, j]) => {
                const p1 = points[i]; const p2 = points[j];
                if (!p1 || !p2) return;
                const r1y = floorY + (floorY - p1.y) * 0.3; // Compressed reflection
                const r2y = floorY + (floorY - p2.y) * 0.3;
                
                ctx.beginPath();
                ctx.moveTo(p1.x, r1y);
                ctx.lineTo(p2.x, r2y);
                ctx.strokeStyle = "rgba(34, 211, 238, 0.1)"; // Very faint
                ctx.lineWidth = 3 * p1.s * 0.005;
                ctx.stroke();
            });
            ctx.restore();

            // 5. SHADOWS (Grounding)
            ctx.save();
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.filter = "blur(12px)";
            ctx.beginPath();
            // Draw a shadow blob under the center of mass
            ctx.ellipse(cx, floorY, 80 * points[0].s * 0.01, 20 * points[0].s * 0.01, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

                        // Use full body + face if we have enough points, otherwise old version
            const activeConnections = landmarks.length > 33 ? FULL_CONNECTIONS : CONNECTIONS;

            const bones = activeConnections.map(pair => {
                const p1 = points[pair[0]];
                const p2 = points[pair[1]];
                return { p1, p2, z: (p1.z + p2.z) / 2 };
            }).sort((a, b) => a.z - b.z); // Draw back to front

            bones.forEach(bone => {
                const { p1, p2, z } = bone;
                // Depth Fog: Fade distant bones
                const alpha = Math.min(1, Math.max(0.2, 1 / (1 + z * 2))); 
                const size = Math.max(1, p1.s * 0.025); 

                // Outer Glow (The "Hologram" fuzz)
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineCap = "round";
                ctx.strokeStyle = `rgba(${config.boneColor.r}, ${config.boneColor.g}, ${config.boneColor.b}, ${alpha * 0.4})`;
                ctx.lineWidth = size + 4;
                ctx.stroke();

                // Inner Core (The "Bone")
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = `rgba(220, 250, 255, ${alpha})`;
                ctx.lineWidth = size;
                ctx.stroke();
            });

            // === BREATHING + HEART GLOW (makes it feel alive!) ===
            if (points[23] && points[24]) {
                const midX = (points[23].x + points[24].x) / 2;
                const midY = (points[23].y + points[24].y) / 2;

                // Breathing (slow up and down)
                const breathe = Math.sin(Date.now() * 0.002) * 0.1 + 1;

                // Heart beating fast
                const heartBeat = Math.sin(Date.now() * 0.008) * 0.4 + 0.8;

                // Glowing heart
                const heartGlow = ctx.createRadialGradient(midX, midY - 30, 0, midX, midY - 30, 50 * breathe);
                heartGlow.addColorStop(0, `rgba(239, 68, 68, ${heartBeat})`);
                heartGlow.addColorStop(1, 'rgba(239, 68, 68, 0)');
                ctx.fillStyle = heartGlow;
                ctx.fillRect(midX - 60, midY - 80, 120, 100);

                // Breathing diaphragm line
                ctx.beginPath();
                ctx.ellipse(midX, midY + 40, 90 * breathe, 25 * breathe, 0, 0, Math.PI);
                ctx.strokeStyle = `rgba(34, 211, 238, ${0.4 * breathe})`;
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            // === STRESS WARNING RINGS ===
            points.forEach((p, i) => {
                if (i > 10 && p.s > 0.01) {
                    const stress = Math.abs(p.raw.z) * 3;
                    if (stress > 0.4) {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(Date.now() * 0.002);
                        ctx.strokeStyle = `rgba(239, 68, 68, ${stress})`;
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(0, 0, 20 + stress * 15, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            });

            // 7. RENDER JOINTS (Volumetric Orbs)
            points.forEach((p, i) => {
                // Filter: Only draw major joints (skip dense face mesh 1-10)
                if (i > 0 && i < 11) return; 

                const r = Math.max(2, p.s * 0.018);
                
                // Specular Sphere Gradient
                const grad = ctx.createRadialGradient(p.x - r*0.3, p.y - r*0.3, 0, p.x, p.y, r);
                grad.addColorStop(0, "white"); // Highlight
                grad.addColorStop(0.4, i < 11 ? "#f43f5e" : "#22d3ee"); // Color (Head vs Body)
                grad.addColorStop(1, "#0f172a"); // Shadow edge

                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
            });

            // 8. DATA OVERLAYS (The "Clinical" Layer)
            
            // A. Plumb Line (Gravity Reference)
            const head = points[0];
            if (head) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(head.x, head.y);
                ctx.lineTo(head.x, floorY);
                ctx.strokeStyle = "rgba(244, 63, 94, 0.6)"; // Rose-500
                ctx.setLineDash([4, 4]);
                ctx.lineWidth = 1;
                ctx.stroke();
                // Floor Target
                ctx.beginPath();
                ctx.arc(head.x, floorY, 4, 0, Math.PI*2);
                ctx.strokeStyle = "rgba(244, 63, 94, 1)";
                ctx.setLineDash([]);
                ctx.stroke();
                ctx.restore();
            }

            // B. Live Angles (Knees)
            // Left Knee (23-25-27) & Right Knee (24-26-28)
            const drawAngle = (idxA, idxB, idxC, label) => {
                const a = points[idxA]; const b = points[idxB]; const c = points[idxC];
                if(a && b && c) {
                    const angle = calculate3DAngle(a.raw, b.raw, c.raw);
                    
                    // Draw visual arc
                    ctx.save();
                    ctx.beginPath();
                    ctx.fillStyle = "rgba(255,255,255,0.1)";
                    ctx.moveTo(b.x, b.y);
                    ctx.arc(b.x, b.y, 20, 0, Math.PI, true); // Simplified arc
                    ctx.fill();
                    
                    // Draw Text Tag
                    ctx.font = "bold 10px monospace";
                    ctx.fillStyle = "#fff";
                    ctx.fillText(`${angle}°`, b.x + 20, b.y);
                    ctx.fillStyle = "#94a3b8";
                    ctx.font = "8px monospace";
                    ctx.fillText(label, b.x + 20, b.y + 10);
                    ctx.restore();
                }
            };

            // Only draw angles if leg joints exist
            if(points[25]) drawAngle(23, 25, 27, "L.KNEE"); 
            if(points[26]) drawAngle(24, 26, 28, "R.KNEE");

            if (autoRotate) {
                animationFrameId = requestAnimationFrame(render);
            }
        };
        
        render();
        return () => cancelAnimationFrame(animationFrameId);
        
    }, [landmarks, rotation, autoRotate, width, height]);

    return (
        <div className="relative w-full h-full bg-slate-950 rounded-xl overflow-hidden border border-slate-700 shadow-2xl touch-none group">
            {/* OMEGA HUD LAYER */}
            <div className="absolute top-0 left-0 w-full h-full pointer-events-none p-6 flex flex-col justify-between z-20">
                {/* Header Stats */}
                <div className="flex justify-between items-start">
                    <div>
                        <div className="text-[10px] font-black text-cyan-400 uppercase tracking-[0.2em] flex items-center gap-2 mb-1">
                            <div className="w-2 h-2 bg-cyan-400 rounded-full animate-pulse shadow-[0_0_10px_#22d3ee]"></div>
                            OMEGA BIOMETRICS
                        </div>
                        <div className="text-[9px] text-slate-400 font-mono">
                            DATA STREAM: <span className="text-white">LIVE</span>
                        </div>
                    </div>
                    <div className="text-right">
                        <div className="text-[9px] font-bold text-slate-500 uppercase tracking-wider mb-1">AXIAL VIEW</div>
                        <div className="text-lg font-mono text-cyan-400">{(rotation * (180/Math.PI) % 360).toFixed(0)}°</div>
                    </div>
                </div>

                {/* Interactive Reticle */}
                <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[400px] h-[400px] border border-white/5 rounded-full flex items-center justify-center pointer-events-none opacity-20">
                    <div className="absolute top-0 bottom-0 w-px bg-white/10"></div>
                    <div className="absolute left-0 right-0 h-px bg-white/10"></div>
                </div>

                {/* CAMERA MODE BUTTONS */}
                <div className="absolute bottom-24 left-1/2 -translate-x-1/2 flex gap-3 bg-slate-900/90 backdrop-blur-md px-6 py-3 rounded-full border border-cyan-900/50 z-30">
                    {['orbit', 'follow', 'cinematic'].map(mode => (
                        <button 
                            key={mode} 
                            onClick={() => setCameraMode(mode)}
                            className={`text-xs font-bold px-4 py-2 rounded-full transition-all ${cameraMode === mode ? 'bg-cyan-600 text-white' : 'text-cyan-300 hover:text-white'}`}
                        >
                            {mode.toUpperCase()}
                        </button>
                    ))}
                </div>

                {/* Bottom Controls Hint */}
                <div className="flex justify-center">
                     <div className="bg-slate-900/90 backdrop-blur-md border border-cyan-900/50 text-[10px] font-bold text-cyan-100 px-4 py-2 rounded-full flex items-center gap-2 shadow-lg transition-all opacity-70 group-hover:opacity-100 transform translate-y-2 group-hover:translate-y-0">
                        <Icons.Layers className="w-3 h-3 text-cyan-400" />
                        <span>INTERACTIVE MODEL</span>
                    </div>
                </div>
            </div>
            
            {/* Canvas Layer */}
            <canvas 
                ref={canvasRef} 
                width={width} 
                height={height}
                className="w-full h-full cursor-grab active:cursor-grabbing relative z-10"
                onMouseDown={() => setAutoRotate(false)}
                onMouseMove={(e) => {
                    if (e.buttons === 1) { 
                        setRotation(prev => prev + e.movementX * 0.01);
                    }
                }}
                onTouchStart={() => setAutoRotate(false)}
                onTouchMove={(e) => {
                    const touch = e.touches[0];
                    setRotation(prev => prev + (touch.clientX % 2) * 0.03); 
                }}
            />
            
            {/* PRO CLINICAL DATA PANEL */}
            <div className="absolute top-4 right-4 bg-slate-950/95 backdrop-blur-xl border border-cyan-800/60 rounded-2xl p-5 max-w-xs shadow-2xl z-40 pointer-events-none">
                <div className="text-xs font-black text-cyan-400 uppercase tracking-[0.3em] mb-4">CLINICAL METRICS</div>
                <div className="space-y-3 text-xs font-mono">
                    <div className="flex justify-between"><span className="text-slate-400">Spinal Compression</span><span className="text-orange-400 font-bold">High</span></div>
                    <div className="flex justify-between"><span className="text-slate-400">Joint Shear</span><span className="text-red-400 font-bold">Elevated</span></div>
                    <div className="flex justify-between"><span className="text-slate-400">Elastic Recoil</span><span className="text-emerald-400 font-bold">Optimal</span></div>
                    <div className="flex justify-between"><span className="text-slate-400">Torsion Index</span><span className="text-yellow-400 font-bold">12.4°</span></div>
                </div>
            </div>

            {/* Vignette & Grain Overlay for "Film" Look */}
            <div className="absolute inset-0 z-0 pointer-events-none bg-[radial-gradient(circle_at_center,transparent_0%,rgba(2,6,23,0.6)_100%)]"></div>
        </div>
    );
};
