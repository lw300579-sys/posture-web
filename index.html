<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Posture Analysis & Personalized Biomechanics Protocol</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">


    
<!-- React & Dependencies (2025 Immortal CDN) -->
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<!-- TensorFlow.js Core Stack (Fixed CDN Paths) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
<script type="module">
    // 1. Import the specific classes we need from the CDN
    import {
        PoseLandmarker,
        FilesetResolver,
        DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

    // 2. Attach them to the global window object so the React app can see them
    window.mpVision = {
        PoseLandmarker,
        FilesetResolver,
        DrawingUtils
    };

    // 3. Signal that the bridge is complete
    window.mpReady = true;
    console.log("✅ MediaPipe Bridge Established: Neural Core Ready for Linkage");
</script>
<!-- TensorFlow (Lazy Loaded) -->
<script type="importmap">
  {
    "imports": {
      "@google/generative-ai": "https://esm.run/@google/generative-ai"
    }
  }
</script>
<script type="module">
  import { GoogleGenerativeAI } from "@google/generative-ai";
  // We attach it to 'window' so your React code can see it
  window.GoogleGenerativeAI = GoogleGenerativeAI;
</script>

<style>
    body { background-color: #020617; color: #e2e8f0; font-family: 'Inter', system-ui, sans-serif; overflow: hidden; font-size: 16px; }
    .workspace { 
    display: grid; 
    grid-template-columns: 1fr 350px; 
    height: 100vh; 
    transition: grid-template-columns 0.6s ease-out cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.workspace.post-analysis {
    grid-template-columns: 480px 1fr;
}
    .viewport { 
    position: relative; 
    display: flex; 
    flex-direction: column; 
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(4px);
    isolation: isolate;  /* Safe layer promotion—no clip */
    transition: opacity 0.4s ease, transform 0.4s ease;
    border-right: 1px solid rgba(148, 163, 184, 0.1); 
    overflow-y: auto; 
    padding: 3rem; 
    transition: all 0.8s ease;
    /* Remove contain during scroll-heavy states if needed: contain: none; */
}
.glass-panel { 
    background: linear-gradient(135deg, rgba(15, 23, 42, 0.8), rgba(2, 6, 23, 0.9));  
    backdrop-filter: blur(4px);
    isolation: isolate;
    transition: transform 0.5s ease-out, opacity 0.5s ease-out;
    border-left: 1px solid rgba(148, 163, 184, 0.2);
    height: 100vh; 
    z-index: 40; 
    display: flex;
    flex-direction: column;
    overflow-y: hidden;
    box-shadow: -20px 0 40px rgba(0,0,0,0.5);
    transition: all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.glass-panel.expanded {
    background: linear-gradient(to left, rgba(15,23,42,0.95), rgba(2,6,23,1));
}
    
    .upload-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2rem;
    height: 100%;
    padding: 1rem 0;
    
}

@media (max-width: 1400px) {
    .upload-grid {
        gap: 1.5rem;
    }
}
@media (max-width: 1280px) {
    .upload-grid {
        grid-template-columns: 1fr 1fr;
    }
}
@media (max-width: 768px) {
    .upload-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
}
    .upload-slot { 
    border: 3px dashed rgba(103, 116, 139, 0.6); 
    border-radius: 32px; 
    background: rgba(30, 41, 59, 0.5); 
    backdrop-filter: blur(4px);
    isolation: isolate;
    min-height: 540px;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    position: relative;
    overflow: hidden;
}
    .upload-slot:hover { border-color: #22d3ee; background: #1e293b/50; }
    .upload-slot.active { border-style: solid; border-color: #22d3ee; }
    .upload-slot img { width: 100%; height: 100%; object-fit: contain; opacity: 0.6; }

/* FIXED: Scanning Animation - Now shows during analysis! */
    .upload-slot.scanning .scanner-line {
        display: block !important;
        opacity: 1 !important;
        animation: scanDown 5s ease-in-out infinite; /* Faster loop for premium feel */
    }
.analyzing .upload-slot.active .scanner-line {
    display: block !important;
    opacity: 1 !important;
    animation: scanDown 5s ease-in-out infinite !important; /* A bit faster for premium feel */
    box-shadow: 0 0 60px #22d3ee, 0 0 120px rgba(34, 211, 238, 0.9) !important; /* Extra glow! */
}
    
    .btn-primary { 
        background: linear-gradient(135deg, #06b6d4 0%, #0ea5e9 100%); 
        box-shadow: 0 10px 30px rgba(6, 182, 212, 0.4);
        font-size: 1.2rem;
        padding: 1.5rem 3rem;
        border-radius: 1.5rem;
    }
    .btn-primary:hover { 
        transform: translateY(-4px) scale(1.02); 
        box-shadow: 0 20px 40px rgba(6, 182, 212, 0.5); 
    }
    .btn-primary:active { 
        transform: translateY(1px); box-shadow: 0 2px 8px rgba(6, 182, 212, 0.2); filter: brightness(0.95); }
    .btn-primary:disabled { opacity: 0.7; cursor: wait; transform: none; }

    .btn-secondary { background: #1e293b; border: 1px solid #334155; color: #94a3b8; font-weight: bold; padding: 16px 24px; border-radius: 8px; transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; font-size: 12px; cursor: pointer; }
    .btn-secondary:hover { border-color: #64748b; color: white; }

    .protocol-badge { font-size: 9px; padding: 2px 6px; border-radius: 4px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.5px; background: #0f172a; border: 1px solid #334155; color: #94a3b8; cursor: pointer; transition: all 0.2s; }
    .protocol-badge:hover { border-color: #22d3ee; color: #22d3ee; }

    .fascia-tag { font-size: 10px; font-weight: bold; padding: 4px 8px; background: #0f172a; border: 1px solid #334155; border-radius: 4px; color: #94a3b8; display: flex; justify-content: space-between; }
    .symptom-tag { background: #450a0a; border-color: #ef4444; color: #fca5a5; }
    
    .symptom-chip {
        padding: 6px 12px; border-radius: 20px; border: 1px solid #334155; background: #1e293b; color: #94a3b8; 
        font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px;
    }
    .symptom-chip:hover { border-color: #64748b; }
    .symptom-chip.selected { background: #f43f5e; border-color: #e11d48; color: white; box-shadow: 0 2px 8px rgba(244, 63, 94, 0.4); }
    
    .tab-btn { padding: 8px 16px; font-size: 11px; font-weight: 700; text-transform: uppercase; color: #64748b; cursor: pointer; transition: all 0.2s; border-bottom: 2px solid transparent; }
    .tab-btn.active { color: #22d3ee; border-bottom-color: #22d3ee; }

    .task-card { background: #1e293b/40; border: 1px solid #334155; border-radius: 8px; padding: 12px; transition: all 0.2s; display: flex; align-items: center; gap: 12px; cursor: pointer; }
    .task-card:hover { border-color: #22d3ee; background: #1e293b/60; }
    .task-card.completed { border-color: #10b981; background: #064e3b/20; }
    .task-check { width: 18px; height: 18px; border-radius: 50%; border: 2px solid #475569; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
    .task-card.completed .task-check { background: #10b981; border-color: #10b981; }

    /* Chat Styles */
    .chat-bubble { padding: 10px 14px; border-radius: 12px; font-size: 12px; line-height: 1.5; max-width: 90%; margin-bottom: 8px; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .chat-user { background: #0891b2; color: white; align-self: flex-end; border-bottom-right-radius: 2px; margin-left: auto; }
    .chat-ai { background: #1e293b; color: #e2e8f0; align-self: flex-start; border-bottom-left-radius: 2px; border: 1px solid #334155; }
    @keyframes popIn { from { opacity: 0; transform: scale(0.9) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
    
    .animate-popIn { animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

    /* Enhanced Premium Scanner */
.scanner-line { 
    position: absolute; 
    left: 0; right: 0; 
    height: 12px; 
    background: linear-gradient(90deg, transparent, #22d3ee, #fff, #22d3ee, transparent);
    box-shadow: 
        0 0 40px #22d3ee,
        0 0 100px rgba(34, 211, 238, 0.8);
    animation: scanDown 10s ease-in-out infinite;
    z-index: 25; 
    display: none;
    opacity: 0;
    pointer-events: none;
}

@keyframes scanDown { 
    0% { top: 0%; opacity: 0; transform: scaleX(0.5); }
    10% { opacity: 1; transform: scaleX(1); }
    90% { opacity: 1; transform: scaleX(1); }
    100% { top: 100%; opacity: 0; transform: scaleX(0.5); }
}

    /* Avatar Breathing Animation */
    .body-part { 
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    cursor: pointer; 
}
.body-part:hover { 
    filter: brightness(1.8) drop-shadow(0 0 30px #22d3ee); 
    transform: scale(1.12); 
}
.body-part:active {
    transform: scale(1.05);
    filter: brightness(2) drop-shadow(0 0 40px #22d3ee);
}
/* Enhanced tap feedback for avatar parts */
.body-part.tapped {
    animation: tapPulse 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    filter: brightness(2.5) drop-shadow(0 0 50px #22d3ee) drop-shadow(0 0 100px #06b6d4);
    transform: scale(1.25) !important;
    z-index: 50;
}

.body-part.tapped::after {
    content: '';
    position: absolute;
    inset: -20px;
    border: 4px solid #22d3ee;
    border-radius: 50%;
    opacity: 0;
    animation: ripple 1.2s ease-out forwards;
    pointer-events: none;
}

@keyframes tapPulse {
    0% { transform: scale(1); filter: brightness(1) drop-shadow(0 0 30px #22d3ee); }
    50% { transform: scale(1.4); filter: brightness(3) drop-shadow(0 0 80px #22d3ee); }
    100% { transform: scale(1.15); filter: brightness(2) drop-shadow(0 0 60px #22d3ee); }
}

@keyframes ripple {
    0% { transform: scale(0.8); opacity: 1; border-width: 8px; }
    100% { transform: scale(2.5); opacity: 0; border-width: 2px; }
}

/* Tooltip on tap */
.part-tooltip {
    position: fixed;  /* CHANGE: absolute → fixed */
    background: rgba(2, 6, 23, 0.95);
    backdrop-filter: blur(12px);
    border: 1px solid #22d3ee;
    border-radius: 16px;
    padding: 12px 16px;
    font-size: 12px;
    font-weight: bold;
    color: white;
    box-shadow: 0 10px 40px rgba(34, 211, 238, 0.4);
    z-index: 1000;
    pointer-events: none;
    animation: fadeInUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    max-width: 220px;
    text-align: center;
    left: 50% !important;     /* ADD THIS LINE */
    transform: translate(-50%, -100%);  /* CHANGE: -120% → -100% */
    top: auto !important;
    bottom: 100px;  /* Optional: pushes it up a bit from bottom on small screens */
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
    
    /* Confetti CSS */
    .confetti { position: absolute; width: 8px; height: 8px; background: #22d3ee; animation: confetti-fall 3s linear infinite; opacity: 0; }
    @keyframes confetti-fall {
        0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
        100% { transform: translateY(500px) rotate(720deg); opacity: 0; }
    }

    /* NEW: Progress Streak Styles */
    .streak-flame { animation: flicker 2s infinite alternate; }
    @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

    /* NEW: Goal Tracker Styles */
    .goal-progress { background: linear-gradient(to right, #10b981, #059669); height: 4px; border-radius: 2px; transition: width 0.3s ease; }

    @media print {
        body { background: white; color: black; overflow: visible; }
        .workspace { display: flex; height: auto; }
        .viewport, .glass-panel { width: 100%; height: auto; border: none; overflow: visible; }
        .upload-grid { display: grid; grid-template-columns: repeat(3, 1fr); height: 200px; margin-bottom: 2rem; }
        .upload-slot { border: 1px solid #ccc; background: white; }
        .upload-slot img { opacity: 1; }
        .no-print { display: none !important; }
        .text-white { color: black !important; }
        .text-slate-500 { color: #666 !important; }
        .bg-slate-900\/50 { background: none !important; border: 1px solid #eee; }
        .protocol-badge { border: 1px solid #000; color: #000; }
/* Add this inside your <style> tag */
.animate-popIn { 
    animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; 
}
@keyframes popIn { 
    from { opacity: 0; transform: scale(0.95) translateY(20px); } 
    to { opacity: 1; transform: scale(1) translateY(0); } 
}
    } @media (max-width: 1400px) {
    .workspace { grid-template-columns: 1fr 400px; }
}
@media (max-width: 1200px) {
    .upload-grid { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width: 768px) {
    .workspace { grid-template-columns: 1fr; }
    /* DEFAULT HIDDEN, BUT VISIBLE WHEN EXPANDED (Analyzing/Results) */
    .glass-panel { display: none; } 
    .glass-panel.expanded { 
        display: flex !important; 
        position: fixed; 
        inset: 0; 
        width: 100%; 
        height: 100%; 
        z-index: 100;
        background: #020617; /* Solid background for mobile legibility */
    }
    .upload-grid { grid-template-columns: 1fr; }
}
@keyframes pulse-slow {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.03); opacity: 0.95; }
}
.animate-pulse-slow { 
    animation: pulse-slow 8s infinite ease-in-out; 
}
.living-avatar { 
    filter: drop-shadow(0 0 30px rgba(34,211,238,0.3)); 
}
.bg-size-200 { background-size: 200% 200%; }
.bg-pos-0 { background-position: 0% 50%; }
.bg-pos-100 { background-position: 100% 50%; }
.hover\\:bg-pos-100:hover { background-position: 100% 50%; }
.body-part, .upload-slot, .btn-primary, .glass-panel, .workspace {
    will-change: transform, opacity, filter;
    transform: translateZ(0); /* or translate3d(0,0,0) - forces GPU layer */
    backface-visibility: hidden; /* optional, reduces repaint */
    contain: layout style paint;

}

.chat-bubble, .animate-popIn, .task-card {
    will-change: transform, opacity;
}
/* Optimized GPU Acceleration */
.viewport, .glass-panel, .upload-slot, .body-part, canvas {
    backface-visibility: hidden;
    transform: translate3d(0,0,0);
}

/* Limit will-change to only what moves frequently */
.workspace {
    will-change: grid-template-columns;
}

.scanner-line {
    will-change: top;
}

/* Smooth Scrolling */
.viewport, .glass-panel {
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
    scroll-behavior: smooth;
    overscroll-behavior: contain;
    contain: layout style; /* Keeps it fast */
    backdrop-filter: none !important; /* Turns off blurry background - big speed win! */
    background-attachment: scroll; /* Helps with lag */
}


/* FIXED: Pause animations during analysis to kill lag */
.analyzing .animate-pulse-slow,
.analyzing .living-avatar {
    animation-play-state: paused !important;
}
/* EASY MODE: Shrink everything on small screens */
@media (max-width: 1024px) {
    .viewport { padding: 0.5rem 1rem !important; } /* Less padding everywhere */
    .upload-slot { min-height: 250px !important; } /* Smaller slots but still roomy */
}
@media (max-width: 768px) {
    .viewport { padding: 0.25rem 0.5rem !important; } /* Tiny padding on phone */
    .upload-grid { gap: 0.5rem !important; padding: 0 !important; } /* No gaps waste */
    h1 { font-size: 2rem !important; line-height: 1 !important; } /* Tiny title */
    .btn-primary { py: 2 !important; text-2xl !important; } /* Small button */
}
</style></head>
<body>
    <div id="root"></div>
    <script type="text/babel">

const { useState, useEffect, useRef, useMemo, useCallback } = React;

const calculateAngle = (p1, p2, p3) => {
  if (!p1 || !p2 || !p3) return 0;
  const v1 = [p1.x - p2.x, p1.y - p2.y];
  const v2 = [p3.x - p2.x, p3.y - p2.y];
  const dot = v1[0] * v2[0] + v1[1] * v2[1];
  const mag1 = Math.sqrt(v1[0]**2 + v1[1]**2);
  const mag2 = Math.sqrt(v2[0]**2 + v2[1]**2);
  return Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
};

const calculateLivePostureScore = (keypoints) => {
  if (!keypoints) return 0;

  let total = 0;
  let count = 0;

  // Forward Head (ear to shoulder alignment) - using nose (0) and mid-shoulder
  const nose = keypoints[0];
  const leftShoulder = keypoints[11];
  const rightShoulder = keypoints[12];
  if (nose && leftShoulder && rightShoulder) {
    const midShoulderX = (leftShoulder.x + rightShoulder.x) / 2;
    const headDeviation = Math.abs(nose.x - midShoulderX);
    total += 100 - (headDeviation * 800); // higher deviation = worse
    count++;
  }

  // Shoulder levelness
  if (leftShoulder && rightShoulder) {
    const shoulderDiff = Math.abs(leftShoulder.y - rightShoulder.y);
    total += 100 - (shoulderDiff * 1000);
    count++;
  }

  // Hip levelness
  const leftHip = keypoints[23];
  const rightHip = keypoints[24];
  if (leftHip && rightHip) {
    const hipDiff = Math.abs(leftHip.y - rightHip.y);
    total += 100 - (hipDiff * 1000);
    count++;
  }

  // Knee alignment (valgus/varus proxy)
  const leftKnee = keypoints[25];
  const rightKnee = keypoints[26];
  if (leftKnee && rightKnee && leftHip && rightHip) {
    const midHipX = (leftHip.x + rightHip.x) / 2;
    const midKneeX = (leftKnee.x + rightKnee.x) / 2;
    const kneeDeviation = Math.abs(midKneeX - midHipX);
    total += 100 - (kneeDeviation * 1200);
    count++;
  }

  return count > 0 ? Math.round(total / count) : 50;
};

const SFX = {
    play: (freq, type, dur) => {
        try {
            // Only create context if allowed. 
            // We'll manage the context globally or just catch the error and do nothing.
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;

            const ctx = new AudioContext();
            if (ctx.state === 'suspended') {
                // Try to resume, but catch if it fails (user interaction needed)
                ctx.resume().catch(() => { });
            }
            if (ctx.state !== 'running') return; // Silent fail if still suspended

            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, ctx.currentTime);
            g.gain.setValueAtTime(0.1, ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
            osc.connect(g);
            g.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + dur);
        } catch (e) { console.log("Audio blocked"); }
    },
    scan: () => SFX.play(150, 'sawtooth', 0.8),
    success: () => {
        SFX.play(440, 'sine', 0.2);
        setTimeout(() => SFX.play(880, 'sine', 0.4), 100);
    }
};

// --- ICONS ---
const Icons = {
    Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12h14" /><path d="M12 5v14" /></svg>,
    Check: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 6 9 17l-5-5" /></svg>,
    Scan: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2" /><path d="M17 3h2a2 2 0 0 1 2 2v2" /><path d="M21 17v2a2 2 0 0 1-2 2h-2" /><path d="M7 21H5a2 2 0 0 1-2-2v-2" /><circle cx="12" cy="12" r="1" /><path d="M5 12h2" /><path d="M17 12h2" /><path d="M12 5v2" /><path d="M12 17v2" /></svg>,
    Video: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 7l-7 5 7 5V7z" /><rect x="1" y="5" width="15" height="14" rx="2" ry="2" /></svg>,
    Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3" /></svg>,
    Pause: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
    List: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="8" y1="6" x2="21" y2="6" /><line x1="8" y1="12" x2="21" y2="12" /><line x1="8" y1="18" x2="21" y2="18" /><line x1="3" y1="6" x2="3.01" y2="6" /><line x1="3" y1="12" x2="3.01" y2="12" /><line x1="3" y1="18" x2="3.01" y2="18" /></svg>,
    Close: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18" /><path d="M6 6 18 18" /></svg>,
    Print: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 6 2 18 2 18 9" /><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" /><rect x="6" y="14" width="12" height="8" /></svg>,
    History: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></svg>,
    Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /></svg>,
    Speaker: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" /></svg>,
    Info: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><line x1="12" y1="16" x2="12" y2="12" /><line x1="12" y1="8" x2="12.01" y2="8" /></svg>,
    Book: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20" /><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z" /></svg>,
    Sun: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="4" /><path d="M12 2v2" /><path d="M12 20v2" /><path d="m4.93 4.93 1.41 1.41" /><path d="m17.66 17.66 1.41 1.41" /><path d="M2 12h2" /><path d="M20 12h2" /><path d="m6.34 17.66-1.41 1.41" /><path d="m19.07 4.93-1.41 1.41" /></svg>,
    Moon: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" /></svg>,
    Award: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="8" r="7" /><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88" /></svg>,
    Send: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13" /><polygon points="22 2 15 22 11 13 2 9 22 2" /></svg>,
    Layers: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2" /><polyline points="2 17 12 22 22 17" /><polyline points="2 12 12 17 22 12" /></svg>,
    ArrowUp: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="19" x2="12" y2="5" /><polyline points="5 12 12 5 19 12" /></svg>,
    ArrowDown: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19" /><polyline points="19 12 12 19 5 12" /></svg>,
    Share: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3" /><circle cx="6" cy="12" r="3" /><circle cx="18" cy="19" r="3" /><line x1="8.59" y1="13.51" x2="15.42" y2="17.49" /><line x1="15.41" y1="6.51" x2="8.59" y2="10.49" /></svg>,
    Music: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18V5l12-2v13" /><circle cx="6" cy="18" r="3" /><circle cx="18" cy="16" r="3" /></svg>,
    Target: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></svg>,
    Flame: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" /></svg>,
    Camera: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" /><circle cx="12" cy="13" r="4" /></svg>,
};

const ACADEMY = [
    {
        title: "Biotensegrity",
        subtitle: "The True Architecture of the Body",
        author: "Tensegrity Collective",
        desc: "You've been lied to. You're not a stack of bones held up by gravity. You're a 'Bio-Tensegrity' structure: a continuous web of tension (fascia) compressing isolated islands of compression (bones). This shift in understanding changes everything about how you treat pain and train power.",
        sections: [
            { head: "The Skyscraper vs. The Tent", body: "Classical biomechanics views the body like a skyscraper: bones stacked on bones, compressing down. This implies that heavy loads crush joints. The reality? You are a tent. The poles (bones) don't touch; they're suspended by the ropes (fascia). If the tent sags, you don't blame the pole, you tighten the guy-wires." },
            { head: "Floating Compression", body: "In a healthy body, bones never actually touch. They float in the fascial matrix. Articular cartilage in't there to absorb shock from bone-on-bone impact; it's there to facilitate hydraulic gliding. When you lose global tension (slack slings), gravity wins, bones touch, and arthritis begins." },
            { head: "The Omni-Directional Web", body: "Unlike a machine with distinct parts, your body is one continuous unit. A pull on the plantar fascia affects the sub-occipital muscles at the base of the skull instantly. This is why treating 'local' pain fails. The 'tightness' in your neck is usually a compensation for a collapsed arch or a twisted pelvis." },
            { head: "Pre-Stress & Readiness", body: "Tensegrity structures are 'pre-stressed.' They carry tension even at rest. This allows them to react instantly to external forces without collapsing. If your fascia is slack (sedentary lifestyle), your system has to generate muscle tension from scratch to move, which is slow and metabolically expensive. A tensegrity body moves for 'free'." },
            { head: "Evolutionary Resilience", body: "Why can a cat fall from a tree and survive, but a robot shatters? Tensegrity distributes impact force globally across the entire web instantly. A rigid structure shatters at the point of impact. To become unbreakable, you must stop training rigidity and start training elastic connectivity." }
        ],
        key_terms: ["Biotensegrity", "Continuous Tension", "Floating Compression", "Global Distribution", "Pre-Stress State"],
        color: "from-indigo-600 to-purple-600"
    },
    {
        title: "The Fascial Ocean",
        subtitle: "Nonlinear Mechanics of the Living Web",
        author: "Soft-Matter",
        desc: "Fascia isn't just 'packing material' or passive wrapping. It's your largest sensory organ, your second nervous system, and the medium through which all movement happens. It behaves like a liquid crystal—changing states from solid to gel based on movement, hydration, and temperature.",
        sections: [
            { head: "Beyond Newtonian Physics", body: "Classical physics explains levers and pulleys, but it fails to explain humans. Living tissue is viscoelastic (it acts like a fluid and a solid), thixotropic (it becomes more fluid when shaken/moved), and piezoelectric (it generates electricity under pressure). You can't model a human using robot math." },
            { head: "The Sixth Sense (Interoception)", body: "Fascia is 10x more innervated with sensory receptors than muscle. It tells your brain where your body is in space. Chronic pain is often 'sensory amnesia'—the brain has lost the signal from a specific area of fascia because it has become dehydrated and glued down." },
            { head: "Active Contractility", body: "We used to think only muscles contracted, but we now know fascia has myofibroblasts—cells that can contract the web independently of muscles. This creates a background stiffness that stabilizes you. Chronic stress locks these cells in 'on' mode, creating the 'body armor' of stiffness." },
            { head: "Hydration Through Movement", body: "Fascia is 70% water bound to glycosaminoglycans. When you don't move, this water becomes stagnant and glue-like (fuzz). Drinking water isn't enough. You have to move to create the 'sponge effect'—squeezing dirty water out and allowing fresh plasma to soak in. Stretching doesn't hydrate; rhythmic movement hydrates." },
            { head: "Force Transmission", body: "Muscles do not pull on bones directly. They pull on fascia, which transmits the force to the bone. Up to 40% of the force generated by a muscle is transmitted laterally to neighboring muscles, not just to the tendon. Your quads help your hamstrings; your lats help your glutes. Isolation is a myth." }
        ],
        key_terms: ["Viscoelasticity", "Thixotropy", "Piezoelectricity", "Sensory Amnesia", "Force Transmission"],
        color: "from-teal-600 to-cyan-600"
    },
    {
        title: "The Forgotten Plane",
        subtitle: "Why Rotation Is The Master Key",
        author: "Biomechanics 101",
        desc: "Modern fitness is obsessed with the Sagittal Plane (forward/backward movement) because it's easy to measure. But human athleticism lives in the Transverse Plane (rotation). We are walking spirals. If you can't control rotation, you're not strong, you're just stiff.",
        sections: [
            { head: "The Three Realities", body: "Sagittal (Squat/Run) is for survival. Frontal (Side Lunge) is for stability. Transverse (Twist/Throw) is for POWER. Every elite athlete—from boxers to golfers to sprinters—dominates the transverse plane. Force leaks through a stiff spine that can't rotate." },
            { head: "The Core Lie", body: "Your core wasn't designed to do crunches (flexion). It was designed to resist unwanted rotation (anti-rotation) and transfer explosive rotation. The 'six-pack' rectus abdominis is the least important muscle for function. The obliques and transverse abdominis are the real engines." },
            { head: "Lumbar vs. Thoracic", body: "This is critical: The Lumbar spine (lower back) is built for stability (only 5° of safe rotation). The Thoracic spine (mid-back) and Hips are built for mobility. Pain happens when the Thoracic spine gets stiff (from phones/sitting) and the Lumbar spine is forced to twist to compensate. Fix the T-Spine, save the Low Back." },
            { head: "The Spiral Engine", body: "Walking is a rotational event. Left leg forward → Right arm forward. This counter-rotation loads the fascial slings across the torso, storing energy. If you walk with a stiff torso, you turn off your natural engine and have to drag your bodyweight with your hip flexors." },
            { head: "Training the X", body: "You must train diagonally. Chops, lifts, and rotational throws reflect reality. Bilateral symmetrical lifts (standard squats/deadlifts) are great for raw force, but they do not teach the body how to manage torque." }
        ],
        key_terms: ["Transverse Plane", "Thoracic Mobility", "Lumbar Stability", "Spiral Engine", "Counter-Rotation"],
        color: "from-purple-600 to-pink-600"
    },
    {
        title: "Elastic Recoil",
        subtitle: "The Secret of Effortless Speed",
        author: "Plyometric Underground",
        desc: "Muscles are expensive engines; they consume huge amounts of oxygen and glucose. Tendons and fascia are free springs; they return energy without metabolic cost. The difference between a grinder and an elite mover is the ratio of muscle work to elastic recoil.",
        sections: [
            { head: "The Kangeroo Effect", body: "A kangaroo bounces across the outback at 40mph burning less energy than a human walking. How? It lands, stretches its massive tendons, and uses that stored elastic energy to launch the next hop. Humans have this capacity (Achilles, Arch, Fascia), but we atrophy it with cushioned shoes and slow heavy lifting." },
            { head: "Stretch-Shortening Cycle (SSC)", body: "This is the holy grail. An eccentric stretch followed immediately by a concentric contraction. The faster the transition (amortization phase), the more power you generate. If you spend too long on the ground, the energy dissipates as heat. You must train 'stiffness' to be fast." },
            { head: "Stiffness = Speed", body: "Don't confuse 'stiff' with 'immobile'. In plyometrics, stiffness is good. A soft spring (loose tendon) absorbs energy but doesn't return it. A stiff spring (trained tendon) snaps back instantly. We train to make the tendons like steel springs, not rubber bands." },
            { head: "The Cost of Muscle", body: "Trying to sprint or jump using only voluntary muscle contraction is too slow. The nervous system can't fire that fast. You need to pre-load the tissue and let the recoil do the work. This is why 'trying harder' often makes you slower. You muscle through a movement meant to be elastic." },
            { head: "Rhythm Training", body: "Elasticity requires rhythm. Skipping, bounding, and hopping train the timing of the recoil. The gym treats the body like a forklift; the playground treats it like a pogo stick. You need both." }
        ],
        key_terms: ["Stretch-Shortening Cycle", "Tendon Stiffness", "Metabolic Cost", "Amortization Phase", "Reactive Power"],
        color: "from-orange-600 to-red-600"
    },
    {
        title: "Coiling the Spring",
        subtitle: "The Lost Art of Loading the Body",
        author: "Weck + Rethinking Rotation",
        desc: "Look at a statue of a Greek athlete vs. a modern bodybuilder. The athlete is spiraled, twisted, coiled. The bodybuilder is stacked and rigid. Coiling is the ability to use the spiral structure of the bones and fascia to load potential energy before unleashing it.",
        sections: [
            { head: "Bracing vs. Coiling", body: "Standard advice says 'brace your core' (neutral spine). This is great for a heavy deadlift, but terrible for throwing a punch or running. Coiling involves side-bending and rotating the torso to shorten one side of the body while lengthening the other (the Serape Effect). This winds up the system." },
            { head: "Head Over Foot", body: "This is the golden rule of balance. To coil effectively, your head must align directly over your load-bearing foot. When this alignment hits, the glute and lat on that side instantly connect. If your head stays in the middle while you step, you are structurally weak." },
            { head: "The Royal Coil", body: "David Weck's concept. The down-and-in rotation of the elbow towards the opposite hip creates a 'super-connection' through the core. It locks the ribcage to the pelvis on one side, allowing the other side to swing freely. This is the master pattern of human locomotion." },
            { head: "Torsion is Torque", body: "Bones are not straight; they are spiraled. The femur and tibia have a natural twist. When you coil, you wring the towel of your fascia, storing massive torque. Uncoiling releases this torque. Without the coil, you are just pushing weight." },
            { head: "Reclaiming the Curve", body: "We are told to flatten our backs. But the spine is a double-S curve. Coiling leans into these curves, using side-bending to create stability. Don't be afraid of the curve; learn to load it." }
        ],
        key_terms: ["Coiling Core", "Head Over Foot", "Serape Effect", "Torsion Loading", "Spiral Dynamics"],
        color: "from-red-600 to-orange-600"
    },
    {
        title: "The Slings Are Everything",
        subtitle: "Anatomy Trains & Kinetic Chains",
        author: "Decentralized Movement Collective",
        desc: "Forget 'quads,' 'pecs,' and 'biceps.' The brain doesn't know individual muscles; it knows movement patterns. These patterns follow specific fascial highways called Slings. When the slings fire, you're unbreakable. When they disconnect, you break.",
        sections: [
            { head: "Posterior Oblique Sling (POS)", body: "The Powerhouse. Latissimus Dorsi → Thoracolumbar Fascia → Opposite Glute Max. This is the engine of walking, running, and throwing. If your right glute is weak, your left shoulder will often hurt because the sling is broken." },
            { head: "Anterior Oblique Sling (AOS)", body: "The Stabilizer. External Oblique → Anterior Abdominal Fascia → Opposite Adductor. This sling decelerates the body and rotates the pelvis. It stabilizes the pubic symphysis. Weak AOS = groin strains and sports hernias." },
            { head: "Deep Longitudinal Sling (DLS)", body: "The Shock Absorber. Erector Spinae → Sacrotuberous Ligament → Bicep Femoris → Peroneals. This line runs from head to foot. It absorbs the impact of the heel strike and helps the foot recoil. Tight hamstrings are often a DLS issue." },
            { head: "Lateral Sling (LS)", body: "The Balancer. Glute Medius/Minimus → TFL → Opposite QL. This keeps you upright when you stand on one leg (which is 80% of walking). If your hip drops when you step (Trendelenburg gait), this sling is offline, destroying your knee and back." },
            { head: "Force Closure vs. Form Closure", body: "Bones fitting together is 'Form Closure'. Fascia and muscles squeezing the joint tight is 'Force Closure'. The slings provide force closure to the Sacroiliac (SI) joint. SI pain is almost always a failure of the slings to compress the joint during load." }
        ],
        key_terms: ["Posterior Oblique Sling", "Anterior Oblique Sling", "Deep Longitudinal Sling", "Lateral Sling", "Force Closure"],
        color: "from-blue-600 to-cyan-500"
    },
    {
        title: "The Foot Is the Battery",
        subtitle: "Hyperarch & The Real Kinetic Chain",
        author: "Chong Xie + Barefoot Supremacy",
        desc: "Everything starts at the ground. Your foot has 26 bones, 33 joints, and over 100 muscles/ligaments. It is designed to be a complex, sensory-rich adapter. Modern shoes turn it into a dead hoof. Reclaiming foot function is the single highest ROI activity for your body.",
        sections: [
            { head: "The Windlass Mechanism", body: "When you extend your big toe (dorsiflexion), it pulls the plantar fascia tight around the head of the metatarsal. This raises the arch and turns the foot into a rigid lever for propulsion. Stiff shoes prevent this toe bend, killing your natural lever." },
            { head: "The Hyperarch Mechanism", body: "Advanced movers don't just use the Windlass; they actively contract the intrinsic foot muscles to maintain a high arch under massive load. This connects the foot sensorily to the glute. A flat foot is a neurological dead end; the brain receives 'unstable' signals and throttles down power output." },
            { head: "Sensory Gateway", body: "The sole of the foot has the same receptor density as the palm of the hand. It needs texture and data. Thick foam insoles blind your feet. If your brain can't feel the ground, it defaults to a protective, stiff movement pattern." },
            { head: "Heel Suspension", body: "In nature, the heel is a secondary contact point. It hovers or kisses the ground to allow the Achilles tendon to stretch and recoil. Heavy heel-striking sends shockwaves up the bone (shinsplints/knee pain) instead of absorbing force in the muscle/tendon." },
            { head: "Toe Splay is Stability", body: "Your toes are meant to spread wide to create a triangular base of support. Narrow toe-box shoes crush the toes together, ruining balance and creating bunions. Correct toes play a massive role in proprioception." }
        ],
        key_terms: ["Windlass Mechanism", "Hyperarch", "Sensory Density", "Heel Suspension", "Toe Splay"],
        color: "from-emerald-600 to-green-500"
    },
    {
        title: "Breath Is the Master Switch",
        subtitle: "The Diaphragm Controls Stability & State",
        author: "Breath Work",
        desc: "You take 25,000 breaths a day. If you do it wrong, you're reinforcing a dysfunction 25,000 times a day. Breath is not just oxygen delivery; it's the fundamental stabilization mechanism of the human spine and the remote control for your nervous system.",
        sections: [
            { head: "Intra-Abdominal Pressure (IAP)", body: "Think of your core like a soda can. The diaphragm is the top, the pelvic floor is the bottom. When you inhale correctly, the diaphragm pushes down, creating massive internal pressure. This hydraulic pressure braces the spine from the inside out. No belt needed." },
            { head: "The 360° Expansion", body: "Most people breathe vertically (chest rises/shoulders shrug). This is stress breathing. Efficient breathing is horizontal—the belly, obliques, and lower back expand outward. This expansion pre-tensions the fascial slings before you even move." },
            { head: "The Chemical Axis", body: "It's not just mechanics; it's chemistry. Over-breathing (mouth breathing) dumps too much CO2. You need CO2 to release oxygen from hemoglobin (The Bohr Effect). Paradoxically, breathing LESS allows you to oxygenate MORE. Train nasal breathing to boost CO2 tolerance and endurance." },
            { head: "The Nervous System Toggle", body: "Chest breathing triggers the Sympathetic (Fight/Flight) state. Diaphragmatic breathing triggers the Parasympathetic (Rest/Digest) state. If you are stuck in chest breathing, you are physically unable to relax or recover. You are chronically inflamed." },
            { head: "The Pelvic Floor Connection", body: "The diaphragm and pelvic floor work like a piston. As you inhale, both descend. As you exhale, both ascend. If you suck in your stomach constantly (vanity), you disrupt this piston, leading to pelvic floor dysfunction and spinal instability." }
        ],
        key_terms: ["Intra-Abdominal Pressure", "Horizontal Breathing", "Bohr Effect", "Parasympathetic Tone", "Diaphragm-Pelvic Piston"],
        color: "from-cyan-600 to-blue-500"
    },
    {
        title: "Knees Over Toes Revolution",
        subtitle: "Reclaiming Lost Range & Tissue Tolerance",
        author: "Ben Patrick + Decentralized Synthesis",
        desc: "For 50 years, trainers said 'don't let your knees go past your toes.' This advice created a generation of fragile knees. The knee is designed to flex fully, and avoiding this range creates weakness in the VMO (teardrop muscle) and patellar tendon. To heal, you have to go where the pain is—carefully.",
        sections: [
            { head: "The VMO is the Protector", body: "The Vastus Medialis Oblique (VMO) is the first muscle to atrophy with knee pain and the last to wake up. It is primarily responsible for knee stability and kneecap tracking. It ONLY fully engages in deep knee flexion (knees over toes)." },
            { head: "Pressure Proves the Pipe", body: "Tendons and cartilage do not have good blood supply. They feed through 'imbibition'—the pumping of fluid caused by compression and release. Deep squats pump nutrients into the deep knee cartilage. Shallow movements starve the joint." },
            { head: "Tibialis Anterior: The First Line", body: "The muscle on the front of your shin acts as the shock absorber for the foot and knee. If it is weak, every step sends force directly into the knee joint. Strengthening the tibialis is the quickest way to reduce knee impact forces." },
            { head: "Regression is Progress", body: "You don't start with a heavy deep squat. You start with a high split squat, assisted, pain-free. You earn depth by millimeter. Pain is the signal to regress, not to stop. 'Motion is lotion,' but only if the dose is right." },
            { head: "Reverse Out", body: "Walking backwards (sled pull or treadmill off) reverses the shear forces on the knee. It actively pumps the knee full of blood while strengthening the VMO in a concentric-only range (safe). It is the ultimate knee rehab tool." }
        ],
        key_terms: ["Knees Over Toes", "VMO Activation", "Tibialis Strength", "Imbibition", "Reverse Walking"],
        color: "from-amber-500 to-orange-500"
    },
    {
        title: "Marv's Wave",
        subtitle: "The Spine as Living Antenna",
        author: "Marv Marinovich Legacy",
        desc: "Marv Marinovich saw the athlete not as a machine, but as a nervous system antenna. He prioritized the 'Spinal Wave'—the ability to undulate the spine segmentally. A rigid spine blocks neural signals; a fluid spine amplifies them. This is the frontier of speed and reaction.",
        sections: [
            { head: "The Central Pattern Generator", body: "Movement isn't just top-down (brain to muscle). The spine itself has neural circuits that generate rhythmic patterns (like walking). A stiff spine dampens these signals. A wavy spine facilitates the natural rhythms of locomotion." },
            { head: "Disassociation", body: "Athleticism is the ability to move body parts independently. You must be able to rotate your hips while keeping your shoulders still, or flex your lumbar while extending your thoracic. The Spinal Wave trains this granular control, breaking up the 'blocky' movement of amateurs." },
            { head: "Micro-Trauma and Rigiditity", body: "Heavy compressive lifting (max deadlifts/squats) creates micro-trauma that heals as scar tissue/calcification. Over time, the spine fuses into a rod. The Wave undoes this. It breaks up micro-adhesions and restores the 'suppleness' of youth." },
            { head: "The Nervous System Flush", body: "The spinal cord floats in cerebrospinal fluid (CSF). Undulating the spine acts as a pump, circulating this fluid to the brain. This clears metabolic waste and keeps the nervous system conducting signals at high speed. It wakes you up." },
            { head: "Integration", body: "The wave connects the feet to the hands. A punch doesn't start in the shoulder; it starts in the foot, ripples through a fluid spine, and snaps at the fist. If the spine is a rod, the energy is blocked. If it's a wave, the energy is amplified." }
        ],
        key_terms: ["Spinal Wave", "Segmental Motion", "Neural Conductivity", "Disassociation", "Cerebrospinal Pump"],
        color: "from-purple-600 to-indigo-600"
    }
];

const PRESET_PROTOCOLS = {
    "Tech Neck": ["head_loading", "chest_opener", "trap_release", "standing_pull"],
    "Rounded Shoulders": ["chest_opener", "arm_raise", "standing_pull", "body_wave"],
    "Sedentary Reset": ["body_bounce", "split_squat", "trunk_twist", "plantar_release"],
    "Hyperarch Fascia": ["plantar_release", "towel_curl", "hyperarch"],
    "Head-Loading": ["head_loading_level1", "head_loading_level2", "head_loading_level3"]


};

// --- HYPER-PERSONALIZED DATABASE (V85.0 APEX ARCHITECT) ---
const EXERCISE_DB = [
    // PHASE 1: STRUCTURAL REPAIR
    {
        id: "head_loading", title: "Cervical Alignment", target_grade: "head", pattern: "posture_reset", tissues: "Deep Spine / Multifidus", phase: 1, synergies: ["Neck Pain", "Back Pain"], equipment: "none", levels: [
            { level: 1, name: "Weighted Head Loading (Standing)", demoType: "head_loading_basic", duration: 90, desc: "Axial decompression standing tall with light weight on head.", steps: ["Balance light weight on head", "Reach arms up", "Breathe deep", "Lengthen spine"], videoSearch: "medicine ball balanced on head posture" },
            { level: 2, name: "Head-Loaded Standing Hip Hinge", demoType: "head_hinge", duration: 90, desc: "Basic axial loading with hip hinge to teach posterior chain under head load.", steps: ["Balance 5-10lb on head", "Hinge at hips, push butt back", "Keep spine neutral", "Return to stand"], videoSearch: "good morning exercise with medicine ball overhead" },
            { level: 3, name: "Head Loaded March", demoType: "head_march", duration: 60, desc: "Dynamic stability marching under axial load.", steps: ["Balance weight on head", "March slowly in place", "No wobble", "Maintain tall posture"], videoSearch: "posture head weighting marching" }
        ]
    },
    {
        id: "head_loading_level1",
        title: "Head-Loading Step 1",
        target_grade: "head",
        pattern: "posture_reset",
        tissues: "Deep Cervical Stabilizers",
        phase: 2,
        synergies: ["Neck Pain", "Forward Head"],
        equipment: "required",
        levels: [{ level: 1, name: "Standing Head Loading", demoType: "head_loading_basic", duration: 90, desc: "Basic axial loading to establish perfect spinal alignment.", steps: ["Place light weight on head", "Stand tall, arms reaching up", "Lengthen from tailbone to crown", "Deep breathing"], videoSearch: "medicine ball balanced on head posture" }]
    },
    {
        id: "head_loading_level2",
        title: "Head-Loading Step 2",
        target_grade: "head",
        pattern: "posture_reset",
        tissues: "Deep Cervical / Posterior Chain",
        phase: 2,
        synergies: ["Neck Pain", "Posture"],
        equipment: "required",
        levels: [{ level: 1, name: "Head-Loaded Hip Hinge", demoType: "head_hinge", duration: 90, desc: "Add posterior chain movement while maintaining cervical load.", steps: ["Keep weight balanced", "Hinge at hips", "Neutral spine", "Drive through heels"], videoSearch: "good morning with weight on head" }]
    },
    {
        id: "head_loading_level3",
        title: "Head-Loading Step 3",
        target_grade: "head",
        pattern: "posture_reset",
        tissues: "Full Axial Chain / VMO",
        phase: 2,
        synergies: ["Neck Pain", "Knee Pain", "Posture"],
        equipment: "required",
        levels: [{ level: 1, name: "Head-Loaded ATG Split Squat", demoType: "head_split", duration: 120, desc: "Deep unilateral range with axial loading — the ultimate posture challenge.", steps: ["Weight balanced on head", "Long stride, deep drop", "Front knee over toe", "Torso upright"], videoSearch: "head loaded atg split squat" }]
    },
    { id: "plantar_release", title: "Plantar Release", target_grade: "gait", pattern: "foot_release", tissues: "Plantar Fascia", phase: 1, synergies: ["Foot Pain", "Knee Pain", "Back Pain"], equipment: "required", levels: [{ level: 1, name: "Standing Foot Roll", demoType: "foot_roll", duration: 90, desc: "Break up fascial adhesions while loaded.", steps: ["Stand on ball", "Apply bodyweight", "Find hot spots"], videoSearch: "standing plantar fascia release golf ball" }, { level: 2, name: "Plantar Fascia Release", demoType: "foot_roll", duration: 90, desc: "Shift weight dynamically across the arch.", steps: ["Ball under arch", "Shift weight front/back", "Breathe"], videoSearch: "standing plantar fascia release technique" }, { level: 3, name: "Active Toe Splay", demoType: "foot_roll", duration: 60, desc: "Neurological reactivation.", steps: ["Stand tall", "Splay toes", "Drive big toe down", "Lift others"], videoSearch: "toe splay foot exercise" }] },
    {
        id: "meta_release", title: "Metatarsal Splay", target_grade: "gait", pattern: "foot_release", tissues: "Interosseous / Metatarsals", phase: 1, synergies: ["Foot Pain", "Narrow Toe Box"], equipment: "none", levels: [
            { level: 1, name: "Seated Metatarsal Smash", demoType: "meta_release", duration: 90, desc: "Manual release between the 1st and 2nd metatarsal bones.", steps: ["Sit down, cross leg", "Press thumb between big toe and second toe bones", "Flex and extend toes while pressing"], videoSearch: "foot mobilization metatarsal massage" },
            { level: 2, name: "Active Splay Release", demoType: "meta_release", duration: 60, desc: "Adding active splay neurological drive.", steps: ["Pin the tissue", "Actively spread toes wide", "Relax and repeat"], videoSearch: "active foot splay exercise" }
        ]
    },
    { id: "split_squat", title: "Knee Restoration", target_grade: "hip", pattern: "knee_flexion", tissues: "VMO / Hip Flexor", phase: 1, synergies: ["Knee Pain", "Back Pain", "Foot Pain"], equipment: "none", levels: [{ level: 1, name: "Assisted Split Squat", demoType: "split_squat", duration: 60, desc: "Use support to unload bodyweight.", steps: ["Hold support", "Front foot flat", "Knee over toe"], videoSearch: "atg split squat assisted form" }, { level: 2, name: "ATG Split Squat", demoType: "split_squat", duration: 60, desc: "Full range bodyweight split squat.", steps: ["Long stride", "Back leg straight", "Cover hamstring with calf"], videoSearch: "atg split squat knees over toes" }, { level: 3, name: "Headloaded Split Squat", demoType: "split_squat", duration: 60, desc: "Advanced: Axial load forces perfect spinal alignment.", steps: ["Balance up to 10lb on head", "Perform split squat and exaggerate your knees over toes", "Absolute control"], videoSearch: "ATG loaded split squat" }, { level: 4, name: "Head-Loaded ATG Split Squat", demoType: "head_split", duration: 90, desc: "Head load forces perfect alignment in deep split squat.", steps: ["Balance 5-10lb on head", "Long stride", "Deep drop, knee over toe", "Slow reps"], videoSearch: "overhead medicine ball lunge deep" }] },
    { id: "trap_release", title: "Shoulder Release", target_grade: "shoulders", pattern: "tissue_release", tissues: "Upper Traps", phase: 1, synergies: ["Neck Pain", "Headache"], equipment: "required", levels: [{ level: 1, name: "Upper Trap Smash", demoType: "shoulder_release", duration: 90, desc: "Basic release.", steps: ["Ball on wall", "Lean in", "Breathe"], videoSearch: "upper trap release lacrosse ball wall" }, { level: 2, name: "Active Trap Pin", demoType: "shoulder_release", duration: 90, desc: "Release with arm movement.", steps: ["Pin tissue", "Raise arm", "Lower arm"], videoSearch: "upper trap active release technique" }] },
    { id: "standing_pull", title: "Scapular Stability", target_grade: "shoulders", pattern: "upper_pull", priority: "secondary", tissues: "Lower Traps / Rhomboids", phase: 1, synergies: ["Neck Pain", "Posture"], equipment: "required", levels: [{ level: 1, name: "Band Pull Aparts", demoType: "standing_pull", duration: 60, desc: "Scapular retraction.", steps: ["Hold band", "Pull apart", "Squeeze blades"], videoSearch: "resistance band pull aparts form" }, { level: 2, name: "Cable Face Pulls", demoType: "standing_pull", duration: 60, desc: "External rotation and retraction.", steps: ["Pull to face", "Rotate hands up", "Squeeze"], videoSearch: "cable face pull proper form" }] },
    { id: "diaphragm_breath", title: "Diaphragmatic Integration", target_grade: "spine", pattern: "breath_flow", tissues: "Deep Front Line / Diaphragm", phase: 1, synergies: ["Back Pain", "Neck Pain", "Stiffness"], equipment: "none", levels: [{ level: 1, name: "Supine Breath Hold", demoType: "diaphragm_breath", duration: 60, desc: "Basic diaphragm activation.", steps: ["Lie flat", "Hand on belly", "Inhale deep, hold 5s"], videoSearch: "supine diaphragmatic breathing" }, { level: 2, name: "Crocodile Breath", demoType: "diaphragm_breath", duration: 90, desc: "Prone for back line integration.", steps: ["Face down", "Forehead on hands", "Belly breathe against floor"], videoSearch: "crocodile breathing exercise" }, { level: 3, name: "Integrated Breath Flow", demoType: "diaphragm_breath", duration: 120, desc: "Pair with movement.", steps: ["Inhale during elongation", "Exhale on coil", "Sync with wave"], videoSearch: "integrated diaphragmatic breathing in movement" }] },

    // PHASE 2: FASCIAL ELASTICITY
    { id: "body_bounce", title: "Fascial Bounce", target_grade: "hip", pattern: "rhythmic_loading", tissues: "Lateral Line / Glute Med", phase: 2, synergies: ["Hip Impingement", "Stiffness"], equipment: "none", levels: [{ level: 1, name: "Body Bounce w/ Hip Shift", demoType: "body_bounce", duration: 60, desc: "Rhythmic bouncing with lateral hip shifts to engage fascia.", steps: ["Bounce on balls of feet", "Shift hips left and right", "Keep rhythm"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },
    { id: "hyperarch", title: "Fascial Elasticity", target_grade: "gait", pattern: "elasticity", tissues: "Achilles / Fascia", phase: 2, synergies: ["Foot Pain", "Knee Pain"], equipment: "none", levels: [{ level: 1, name: "Pogo Hops", demoType: "hyperarch_hop", duration: 30, desc: "Build stiffness.", steps: ["Small bounces", "Legs straight", "Balls of feet"], videoSearch: "pogo hops plyometrics" }, { level: 2, name: "Hyperarch Hops", demoType: "hyperarch_hop", duration: 45, desc: "Maximal fascial loading.", steps: ["Suspend heel", "Rapid recoil", "Glute driven"], videoSearch: "hyperarch fascia training glute hops" }] },
    { id: "towel_curl", title: "HFT Towel Curls", target_grade: "gait", pattern: "foot_release", tissues: "Plantar Fascia / Intrinsic Foot", phase: 2, synergies: ["Foot Pain", "Knee Pain", "Back Pain"], equipment: "required", levels: [{ level: 1, name: "Seated Towel Curl", demoType: "towel_curl", duration: 60, desc: "Basic toe scrunch seated.", steps: ["Sit", "Towel under foot", "Scrunch toes"], videoSearch: "seated towel curl exercise" }, { level: 2, name: "Standing Towel Curl", demoType: "towel_curl", duration: 90, desc: "Add weight bearing.", steps: ["Stand", "Scrunch with full weight"], videoSearch: "standing towel curl" }, { level: 3, name: "Dynamic Towel Pull", demoType: "towel_curl", duration: 60, desc: "Pull towel towards you.", steps: ["Pull towel with toes", "Repeat"], videoSearch: "dynamic towel scrunch" }] },
    { id: "chest_opener", title: "Chest Opener", target_grade: "shoulders", pattern: "anterior_stretch", tissues: "Pectorals / Biceps", phase: 2, synergies: ["Posture", "Neck Pain"], equipment: "none", levels: [{ level: 1, name: "Dynamic Chest Opener", demoType: "chest_opener", duration: 60, desc: "Opening the front line of the body.", steps: ["Cross arms in front", "Open wide & squeeze", "Use momentum"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },
    { id: "alt_arm_raise", title: "Reciprocal Arms", target_grade: "shoulders", pattern: "coordination", tissues: "Latissimus Dorsi", phase: 2, synergies: ["Gait Efficiency", "Shoulder Pain"], equipment: "none", levels: [{ level: 1, name: "Alternate Arm Raise", demoType: "alt_arm_raise", duration: 60, desc: "Disassociating shoulder movements.", steps: ["One arm up", "One arm down", "Switch rhythmically"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },

    // PHASE 3: ROTATIONAL POWER
    { id: "pallof", title: "Core Stability", target_grade: "spine", pattern: "anti_rotation", tissues: "Oblique Sling", phase: 3, synergies: ["Back Pain", "Knee Pain"], equipment: "required", levels: [{ level: 1, name: "Pallof Hold", demoType: "pallof_press", duration: 45, desc: "Static anti-rotation hold.", steps: ["Hold band", "Arms extended", "Resist twist"], videoSearch: "pallof press hold form" }, { level: 2, name: "Pallof Press", demoType: "pallof_press", duration: 60, desc: "Dynamic press resisting rotation.", steps: ["Press out", "Return slow", "Hips square"], videoSearch: "standing pallof press tutorial" }, { level: 3, name: "Chopping Pallof", demoType: "pallof_press", duration: 60, desc: "Dynamic chopping motion.", steps: ["Rotational chop", "Explosive return", "Core brace"], videoSearch: "cable woodchopper exercise" }] },
    { id: "landmine_rotation", title: "Rotational Strength", target_grade: "spine", pattern: "anti_rotation", tissues: "Anterior Oblique Sling", phase: 3, synergies: ["Back Pain", "Gait Efficiency"], equipment: "required", levels: [{ level: 1, name: "Landmine Anti-Rotation", demoType: "landmine_rotation", duration: 45, desc: "Resisting torque.", steps: ["Bar in front", "Move arc side to side", "Hips still"], videoSearch: "landmine anti rotation rainbow" }, { level: 2, name: "Landmine Twist", demoType: "landmine_twist", duration: 60, desc: "Integrated hip and spine rotation.", steps: ["Pivot feet", "Rotate hips", "Press bar across body"], videoSearch: "full contact twist landmine" }] },
    {
        id: "ql_straddle", title: "QL Straddle Hinge", target_grade: "spine", pattern: "anti_lateral_flexion", tissues: "Quadratus Lumborum / SI Joint", phase: 3, synergies: ["Back Pain", "SI Joint Pain", "Hip Hike"], equipment: "required", levels: [
            { level: 1, name: "Suitcase Deadlift Iso", demoType: "ql_straddle", duration: 45, desc: "Isometric hold to wake up the QL.", steps: ["Wide stance", "Hold heavy weight in one hand", "Do not let torso twist or dip", "Hold tall"], videoSearch: "suitcase deadlift isometric hold" },
            { level: 2, name: "QL Straddle Hinge", demoType: "ql_straddle", duration: 60, desc: "The SI Joint fixer. Hinging while resisting rotation.", steps: ["Wide straddle stance", "Kettlebell in one hand", "Hinge hips back", "Tap weight inside leg", "Power up without twisting"], videoSearch: "single arm straddle deadlift ql" }
        ]
    },
    { id: "band_twist", title: "Band Twist", target_grade: "spine", pattern: "power_rotation", tissues: "Obliques / Transverse Plane", phase: 3, synergies: ["Back Pain", "Hip Hike"], equipment: "required", levels: [{ level: 1, name: "Standing Band Twist", demoType: "band_twist", duration: 60, desc: "Controlled rotational torque.", steps: ["Hold band", "Pivot feet", "Rotate 180 degrees"], videoSearch: "standing resistance band trunk twist" }, { level: 2, name: "Explosive Band Twist", demoType: "band_twist", duration: 60, desc: "Power development.", steps: ["Load back", "Snap hips", "Rotate hard"], videoSearch: "explosive band rotation exercise" }] },
    { id: "coiling", title: "Rotational Power", target_grade: "spine", pattern: "core_flow", tissues: "Spiral Line", phase: 3, synergies: ["Back Pain", "Gait Efficiency"], equipment: "none", levels: [{ level: 1, name: "Static Coiling Hold", demoType: "coiling_lunge", duration: 45, desc: "Learn the position.", steps: ["Lunge", "Side bend", "Align Head Over Foot"], videoSearch: "weckmethod coiling core isometric" }, { level: 2, name: "Pulsing Coiling Lunge", demoType: "weck_pulse", duration: 60, desc: "WeckMethod Rhythmic Pulse.", steps: ["Double down pulse", "Fascial elasticity", "Head over foot"], videoSearch: "weckmethod pulsing lunge tutorial" }, { level: 3, name: "Loaded Coiling", demoType: "coiling_lunge", duration: 60, desc: "Add hand weights.", steps: ["Hold DBs", "Enhance torsion", "Power return"], videoSearch: "weckmethod loaded coiling lunge" }, { level: 4, name: "Head-Loaded Coiling Lunge", demoType: "head_coiling", duration: 90, desc: "Head load amplifies coil and Head-Over-Foot.", steps: ["Balance 5-10lb on head", "Lunge + side bend/rotate", "Pulse the coil"], videoSearch: "weckmethod coiling lunge overhead" }] },
    { id: "trunk_twist", title: "Trunk Twist", target_grade: "spine", pattern: "rotation", tissues: "Spiral Line", phase: 3, synergies: ["Back Pain", "Core Stability"], equipment: "none", levels: [{ level: 1, name: "Dynamic Trunk Twist", demoType: "trunk_twist", duration: 60, desc: "Loosening the thoracic spine with rhythmic rotation.", steps: ["Feet wide", "Rotate torso", "Let arms swing loosely"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },

    // PHASE 4: INTEGRATED FLOW
    { id: "spinal_wave", title: "Integrated Spine", target_grade: "spine", pattern: "core_flow", tissues: "Full Body Fascia", phase: 4, requires_mastery: ["body_wave", "coiling"], synergies: ["Back Pain", "Neck Pain"], equipment: "none", levels: [{ level: 1, name: "Standing Spinal Roll", demoType: "spinal_wave", duration: 60, desc: "Segmental flexion/extension.", steps: ["Chin to chest", "Roll down spine", "Roll up"], videoSearch: "standing spinal roll down pilates" }, { level: 2, name: "Marinovich Spinal Wave", demoType: "spinal_wave", duration: 60, desc: "Segmental activation of the spine.", steps: ["Sit or lie over the ball so your back is supported.", "Initiate a wave from the tailbone through the spine up to the head.", "Arms can move overhead, side-to-side, or reach forward to integrate upper body."], videoSearch: "https://www.youtube.com/watch?v=H9Ai26Au5Kc&list=PLkJzahJiwLT4Qu2fl_877pWJtCJo39HI-" }] },
    { id: "body_wave", title: "Body Wave", target_grade: "spine", pattern: "spinal_flow", tissues: "Superficial Back Line", phase: 4, synergies: ["Back Pain", "Stiffness"], equipment: "none", levels: [{ level: 1, name: "Standing Body Wave", demoType: "body_wave", duration: 60, desc: "Rhythmic arm swings driving body extension.", steps: ["Swing arms back & bend knees", "Swing arms overhead & extend", "Keep rhythm"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] },
    { id: "med_ball_power", title: "Explosive Power", target_grade: "spine", pattern: "power_rotation", tissues: "Full Body Fascia", phase: 4, synergies: ["Athletic Performance", "Stiffness"], equipment: "required", levels: [{ level: 1, name: "Standing Overhead Slam", demoType: "med_ball_slam", duration: 30, desc: "Full body flexion power.", steps: ["Stand tall", "Lift ball", "Slam hard"], videoSearch: "medicine ball overhead slam form" }] },
    { id: "contra_pull", title: "Contralateral Pull", target_grade: "shoulders", pattern: "reciprocal_pull", tissues: "Posterior Oblique Sling", phase: 4, synergies: ["Back Pain", "Gait Efficiency", "Shoulder Impingement"], equipment: "required", levels: [{ level: 1, name: "Static Contra Hold", demoType: "contra_pull", duration: 45, desc: "Isometric sling fire.", steps: ["Band in right hand", "Left foot steps back", "Pull & resist"], videoSearch: "contralateral band pull hold" }, { level: 2, name: "Dynamic Contra Pull", demoType: "contra_pull", duration: 60, desc: "Add movement.", steps: ["Pull band while stepping", "Alternate sides", "Keep tension"], videoSearch: "contralateral resistance band pull" }, { level: 3, name: "Explosive Contra Snap", demoType: "contra_pull", duration: 45, desc: "Power version.", steps: ["Quick pull & release", "Hip drive", "Full recoil"], videoSearch: "explosive contralateral band snap" }] },
    { id: "inversion_hang", title: "Inversion Decompression", target_grade: "hip", pattern: "inversion_flow", tissues: "Superficial Back Line", phase: 4, synergies: ["Back Pain", "Hip Impingement", "Stiffness"], equipment: "none", levels: [{ level: 1, name: "Supported Inversion Hold", demoType: "inversion_hang", duration: 30, desc: "Gentle hang.", steps: ["Hang from bar/wall", "Relax shoulders", "Breathe deep"], videoSearch: "supported inversion hang" }, { level: 2, name: "Active Inversion Twist", demoType: "inversion_hang", duration: 45, desc: "Add rotation.", steps: ["Hang & twist hips", "Alternate sides", "Control descent"], videoSearch: "inversion hang with twist" }, { level: 3, name: "Dynamic Inversion Flow", demoType: "inversion_hang", duration: 60, desc: "Full integration.", steps: ["Hang to pull-up", "Add leg swings", "Fascia release"], videoSearch: "dynamic inversion flow exercise" }] },
    { id: "arm_raise", title: "Arm Raises", target_grade: "shoulders", pattern: "shoulder_mobility", tissues: "Deep Front Arm Line", phase: 4, synergies: ["Neck Pain", "Shoulder Impingement"], equipment: "none", levels: [{ level: 1, name: "Thumbs Up Arm Raise", demoType: "arm_raise", duration: 60, desc: "Overhead range of motion with external rotation cue.", steps: ["Thumbs up", "Raise arms straight front", "Keep ribs down"], videoSearch: "standing lymphatic bounce exercise with hip shift" }] }
    ,
// ELITE PHASE 5: UNBREAKABLE FLOWS (Premium/Score Unlock)
    {
        id: "med_ball_rotational_throw",
        title: "Rotational Power Throw",
        target_grade: "spine",
        pattern: "power_rotation",
        tissues: "Posterior Oblique Sling",
        phase: 5,
        synergies: ["Athletic Performance", "Back Pain"],
        equipment: "required",
        levels: [{
            level: 1,
            name: "Medicine Ball Rotational Wall Throw",
            demoType: "wall_throw",
            duration: 45,
            desc: "Explosive spiral line activation with full hip drive.",
            steps: ["Load coil", "Snap hips", "Release through opposite shoulder", "Catch and reset"],
            videoSearch: "medicine ball rotational wall throw"
        }]
    },
    {
        id: "inversion_twist_flow",
        title: "Inversion Spiral Flow",
        target_grade: "spine",
        pattern: "inversion_flow",
        tissues: "Deep Front Line",
        phase: 5,
        synergies: ["Back Pain", "Stiffness"],
        equipment: "required",
        levels: [{
            level: 1,
            name: "Inversion Hang + Active Twist",
            demoType: "inversion_hang",
            duration: 60,
            desc: "Advanced decompression with controlled rotation.",
            steps: ["Hang relaxed", "Initiate twist from hips", "Counter-rotate head", "Breathe deep"],
            videoSearch: "inversion hang with twist"
        }]
    },
    {
        id: "coiling_med_ball",
        title: "Coiled Medicine Ball Slam",
        target_grade: "spine",
        pattern: "power_rotation",
        tissues: "Full Body Spiral",
        phase: 5,
        synergies: ["Athletic Performance"],
        equipment: "required",
        levels: [{
            level: 1,
            name: "Coiled Overhead Slam",
            demoType: "med_ball_slam",
            duration: 40,
            desc: "Maximize torsion before explosive release.",
            steps: ["Coil torso", "Reach high", "Uncoil violently", "Drive through floor"],
            videoSearch: "medicine ball rotational slam"
        }]
    }


];

// --- NEW: GOAL PRESETS (For Retention) ---
const GOAL_PRESETS = [
    { id: "beginner", title: "Starter Build", target: 70, desc: "Build foundational posture in 30 days.", exercises: 4 },
    { id: "athlete", title: "Elite Power", target: 90, desc: "Unlock rotational power in 60 days.", exercises: 6 },
    { id: "recovery", title: "Pain Free", target: 85, desc: "Eliminate chronic pain in 45 days.", exercises: 5 }
];

// --- MISSING PART_ANALYSIS DATABASE ---
const PART_ANALYSIS = {
    head: {
        title: "Cervical Alignment",
        intro: (g, v) => `Your head score is **${g}** (${v}%). This measures Forward Head Posture (Tech Neck).`,
        rootCause: "Weak deep cervical flexors and tight sub-occipitals from screen usage.",
        fix: "Axial Decompression (Head Loading) to reflexively fire the deep neck stabilizers.",
        insight: "For every inch your head moves forward, it adds 10lbs of leverage load to your spine."
    },
    shoulders: {
        title: "Scapular Stability",
        intro: (g, v) => `Your shoulder integrity is **${g}** (${v}%). This checks for rounding and asymmetry.`,
        rootCause: "Tight pectorals pulling shoulders forward + weak lower traps/rhomboids.",
        fix: "Chest Openers + Band Pull Aparts to re-set the scapula back and down.",
        insight: "Your shoulders are not ear-muffs. Depression (dropping them) is as important as Retraction."
    },
    spine: {
        title: "Spinal Column",
        intro: (g, v) => `Your spinal metric is **${g}** (${v}%). This analyzes curvature and compression.`,
        rootCause: "Thoracic rigidity. You have lost the ability to extend and rotate the mid-back.",
        fix: "Spinal Waves + Hanging Decompression to re-hydrate vertebral discs.",
        insight: "A stiff spine blocks neural signals. A fluid spine amplifies power."
    },
    hip: {
        title: "Pelvic Girdle",
        intro: (g, v) => `Your pelvic score is **${g}** (${v}%). This looks for Anterior Tilt or Hip Hike.`,
        rootCause: "Sedentary lifestyle shortening the hip flexors and putting glutes to sleep (Glute Amnesia).",
        fix: "Deep Split Squats (ATG) to lengthen hip flexors under load.",
        insight: "The pelvis is the transmission of the body. If it's tilted, you leak power."
    },
    gait: {
        title: "Gait & Feet",
        intro: (g, v) => `Your recoil capacity is **${g}** (${v}%). This measures ankle stiffness and foot function.`,
        rootCause: "Weak foot arches and reliance on cushioned shoes (sensory deprivation).",
        fix: "Barefoot Pogo Hops + Towel Curls to wake up the plantar fascia.",
        insight: "You should bounce, not thud. Elasticity is free energy; muscle contraction is expensive."
    }
};
// --- COMPONENTS ---

const BioAvatar = ({ audit, symptoms = [], onPartClick }) => {
    const [tappedPart, setTappedPart] = useState(null);
    const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
    const avatarRef = useRef(null);

    const handlePartClick = (e, part) => {
        if (navigator.vibrate) navigator.vibrate(50);
        SFX.play(800, 'sine', 0.1);
        setTappedPart(part);
        const rect = avatarRef.current.getBoundingClientRect();
        const clickX = e.clientX || e.touches?.[0]?.clientX || rect.left + rect.width / 2;
        const clickY = e.clientY || e.touches?.[0]?.clientY || rect.top + rect.height / 2;
        setTooltipPos({ x: clickX, y: clickY });
        if (onPartClick) onPartClick(part);
        setTimeout(() => setTappedPart(null), 800);
    };

    const getColor = (grade) => {
        switch (grade) {
            case 'A': return "fill-emerald-500/20 stroke-emerald-500 hover:fill-emerald-500/40";
            case 'B': return "fill-blue-500/20 stroke-blue-500 hover:fill-blue-500/40";
            case 'C': return "fill-yellow-500/20 stroke-yellow-500 hover:fill-yellow-500/40";
            case 'D': return "fill-orange-500/20 stroke-orange-500 hover:fill-orange-500/40";
            case 'F': return "fill-red-600/40 stroke-red-600 hover:fill-red-600/60 animate-pulse shadow-2xl shadow-red-900/70";
            default: return "fill-slate-700 stroke-slate-600";
        }
    };

    const getFill = (part, gradeObj) => {
        const grade = gradeObj?.grade || 'F';
        const isBad = grade === 'F' || grade === 'D';
        const isPain =
            (part === 'head' && symptoms.includes('Neck Pain')) ||
            (part === 'spine' && symptoms.includes('Back Pain')) ||
            (part === 'hip' && (symptoms.includes('Back Pain') || symptoms.includes('Knee Pain'))) ||
            (part === 'gait' && (symptoms.includes('Knee Pain') || symptoms.includes('Foot Pain')));

        if (isPain || isBad) {
            return "fill-red-600/50 stroke-red-500 animate-pulse shadow-2xl shadow-red-900/70 hover:fill-red-600/80 hover:scale-110 cursor-pointer transition-all duration-300";
        }
        const baseColor = getColor(grade);
        return `${baseColor} hover:brightness-150 hover:scale-108 cursor-pointer transition-all duration-300`;
    };

    const headC = getFill('head', audit ? audit.head : { grade: 'F' });
    const shC = getFill('shoulders', audit ? audit.shoulders : { grade: 'F' });
    const spineC = getFill('spine', audit ? audit.spine : { grade: 'F' });
    const hipC = getFill('hip', audit ? audit.hip : { grade: 'F' });
    const legC = getFill('gait', audit ? audit.gait : { grade: 'F' });

    return (
        <div ref={avatarRef} className="relative w-full h-auto mx-auto">
            <svg viewBox="0 0 200 480" className="w-full h-auto mx-auto drop-shadow-2xl animate-pulse-slow living-avatar">
                <g onClick={(e) => handlePartClick(e, 'gait')} onTouchStart={(e) => handlePartClick(e, 'gait')} className={`body-part ${legC} ${tappedPart === 'gait' ? 'tapped' : ''}`}>
                    <path strokeWidth="2" d="M70,220 Q60,300 65,380 L85,380 Q90,300 95,220 Z" />
                    <path strokeWidth="2" d="M130,220 Q140,300 135,380 L115,380 Q110,300 105,220 Z" />
                </g>
                <g onClick={(e) => handlePartClick(e, 'hip')} onTouchStart={(e) => handlePartClick(e, 'hip')} className={`body-part ${hipC} ${tappedPart === 'hip' ? 'tapped' : ''}`}>
                    <path strokeWidth="2" d="M60,180 Q50,200 60,220 L140,220 Q150,200 140,180 Z" />
                </g>
                <g onClick={(e) => handlePartClick(e, 'spine')} onTouchStart={(e) => handlePartClick(e, 'spine')} className={`body-part ${spineC} ${tappedPart === 'spine' ? 'tapped' : ''}`}>
                    <path strokeWidth="2" d="M65,100 L135,100 L140,180 L60,180 Z" />
                </g>
                <g onClick={(e) => handlePartClick(e, 'shoulders')} onTouchStart={(e) => handlePartClick(e, 'shoulders')} className={`body-part ${shC} ${tappedPart === 'shoulders' ? 'tapped' : ''}`}>
                    <path strokeWidth="2" d="M40,100 Q30,150 25,200 L45,200 Q50,150 65,110 Z" />
                    <path strokeWidth="2" d="M160,100 Q170,150 175,200 L155,200 Q150,150 135,110 Z" />
                    <ellipse cx="100" cy="100" rx="40" ry="10" />
                </g>
                <g onClick={(e) => handlePartClick(e, 'head')} onTouchStart={(e) => handlePartClick(e, 'head')} className={`body-part ${headC} ${tappedPart === 'head' ? 'tapped' : ''}`}>
                    <circle cx="100" cy="60" r="25" strokeWidth="2" />
                </g>
                <line x1="0" y1="380" x2="200" y2="380" stroke="#22d3ee" strokeWidth="1" strokeOpacity="0.3" strokeDasharray="4 4" />
                <line x1="100" y1="0" x2="100" y2="400" stroke="#22d3ee" strokeWidth="1" strokeOpacity="0.2" strokeDasharray="4 4" />
            </svg>

            {tappedPart && (
                <div className="part-tooltip fixed" style={{ left: `${tooltipPos.x}px`, top: `${tooltipPos.y}px`, transform: 'translate(-50%, -120%)' }}>
                    <div className="text-cyan-400 text-xs uppercase tracking-wider mb-1">{tappedPart.toUpperCase()}</div>
                    <div className="text-2xl font-black text-white">{audit?.[tappedPart]?.grade || '?'}</div>
                    <div className="text-xs text-cyan-300">{audit?.[tappedPart]?.val || '--'}% Integrity</div>
                </div>
            )}
        </div>
    );
};

const ExerciseGifOverlay = ({ demoType }) => {
    const gifs = {
        split_squat: 'https://i.pinimg.com/originals/4e/1b/3b/4e1b3b8e6d0f3b0e8d8f0b0e8d8f0b0e.gif', // Real ATG knees-over-toes demo
        pallof_press: 'https://gymvisual.com/wp-content/uploads/2451-band-horizontal-pallof-press.gif', // Perfect anti-rotation pallof
        foot_roll: 'https://example.com/plantar-golf-ball-roll.gif', // Placeholder - we'll fix later if needed
        plantar_release: 'https://example.com/plantar-golf-ball-roll.gif',
    };

    const src = gifs[demoType];
    if (!src || src.includes('example.com')) return null;

    return (
        <img 
            src={src} 
            alt="Exercise demonstration" 
            className="absolute inset-0 w-full h-full object-contain pointer-events-none rounded-lg"
            style={{ mixBlendMode: 'screen', opacity: 0.9 }}
        />
    );
};

const AICoach = ({ audit, symptoms, chatHistory, onSend, onAction }) => {
    const [input, setInput] = useState("");
    const [isThinking, setIsThinking] = useState(false); // NEW: Visual Thought Process
    const messagesEndRef = useRef(null);

    // Auto-scroll to bottom
    useEffect(() => { 
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }, [chatHistory, isThinking]);

    const handleSend = async (txt) => {
        const msg = txt || input;
        if (!msg.trim()) return;
        
        // Trigger UI updates
        setInput("");
        setIsThinking(true); // Start "Thinking" animation
        
        // Process
        await onSend(msg);
        
        setIsThinking(false); // Stop animation
    };

    const suggestions = [
        "Analysis Report",
        "Fix my Neck Pain",
        "Why Head Loading?",
        "Generate Power Routine",
        "Show Anatomy Class"
    ];

    return (
        <div className="flex flex-col h-full bg-slate-900/80 backdrop-blur-xl rounded-2xl border border-slate-700 overflow-hidden shadow-2xl relative">
            
            {/* Header with "Live" Status */}
            <div className="p-4 bg-slate-950 border-b border-slate-800 flex justify-between items-center shadow-md z-10">
                <div className="flex items-center gap-3">
                    <div className="relative">
                        <div className="w-3 h-3 rounded-full bg-emerald-500 animate-ping absolute inset-0 opacity-75"></div>
                        <div className="w-3 h-3 rounded-full bg-emerald-500 relative z-10 border-2 border-slate-900"></div>
                    </div>
                    <div>
                        <div className="text-xs font-black text-white uppercase tracking-widest leading-none">Pocket Coach</div>
                        <div className="text-[9px] text-cyan-400 font-mono mt-0.5">NEURAL LINK: ACTIVE</div>
                    </div>
                </div>
            </div>

            {/* Chat Area */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4 scroll-smooth">
                {chatHistory.length === 0 ? (
                    <div className="h-full flex flex-col items-center justify-center opacity-60">
                        <Icons.Scan className="w-12 h-12 text-slate-600 mb-4" />
                        <p className="text-sm text-slate-400 font-medium text-center">
                            Neural Core Ready.<br/>Awaiting Input.
                        </p>
                    </div>
                ) : (
                    chatHistory.map((msg, i) => (
                        <div key={i} className={`flex flex-col ${msg.sender === 'user' ? 'items-end' : 'items-start'} animate-popIn`}>
                            
                            {/* Message Bubble */}
                            <div className={`
                                relative max-w-[85%] px-4 py-3 rounded-2xl text-xs sm:text-sm leading-relaxed shadow-sm
                                ${msg.sender === 'user' 
                                    ? 'bg-gradient-to-br from-cyan-600 to-blue-700 text-white rounded-tr-sm' 
                                    : 'bg-slate-800 border border-slate-700 text-slate-200 rounded-tl-sm shadow-inner'
                                }
                            `}>
                                {/* Markdown-like bolding support */}
                                <div dangerouslySetInnerHTML={{ __html: msg.text.replace(/\*\*(.*?)\*\*/g, '<strong class="text-cyan-300 font-black">$1</strong>').replace(/\n/g, '<br/>') }} />
                                
                                {/* 🚀 NEW: ACTION BUTTONS IN CHAT */}
                                {msg.action && (
                                    <button 
                                        onClick={() => onAction(msg.action)}
                                        className="mt-3 w-full py-2 bg-slate-950 hover:bg-black border border-cyan-500/30 hover:border-cyan-400 rounded-lg flex items-center justify-center gap-2 text-xs font-bold text-cyan-400 transition-all group"
                                    >
                                        <span>{msg.action.label}</span>
                                        <span className="group-hover:translate-x-1 transition-transform">→</span>
                                    </button>
                                )}
                            </div>

                            {/* Timestamp / Label */}
                            <span className="text-[9px] text-slate-600 mt-1 px-1 font-mono uppercase">
                                {msg.sender === 'user' ? 'You' : 'Biometric AI'}
                            </span>
                        </div>
                    ))
                )}
                
                {/* Thinking Indicator */}
                {isThinking && (
                    <div className="flex items-center gap-2 px-4 py-3 bg-slate-800/50 rounded-2xl rounded-tl-sm w-fit animate-pulse">
                        <div className="w-1.5 h-1.5 bg-cyan-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                        <div className="w-1.5 h-1.5 bg-cyan-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                        <div className="w-1.5 h-1.5 bg-cyan-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>

            {/* Quick Chips */}
            <div className="px-4 pb-2 flex gap-2 overflow-x-auto no-scrollbar mask-linear-fade">
                {suggestions.map(s => (
                    <button key={s} onClick={() => handleSend(s)} className="whitespace-nowrap px-3 py-1.5 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-cyan-500/50 rounded-full text-[10px] font-bold text-slate-400 hover:text-cyan-300 transition-all shadow-lg flex-shrink-0">
                        {s}
                    </button>
                ))}
            </div>

            {/* Input Area */}
            <div className="p-3 bg-slate-950 border-t border-slate-800 flex gap-2">
                <input
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => { 
    if (e.key === 'Enter') { 
        e.preventDefault(); 
        handleSend(); 
    } 
}}
                    placeholder="Ask about pain, mechanics, or nutrition..."
                    className="flex-1 bg-slate-900 border border-slate-700 rounded-xl px-4 py-3 text-xs text-white focus:outline-none focus:border-cyan-500 focus:ring-1 focus:ring-cyan-500/50 transition-all placeholder:text-slate-600"
                />
                <button 
                    onClick={() => handleSend()} 
                    disabled={!input.trim() || isThinking}
                    className="p-3 bg-gradient-to-br from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 text-white rounded-xl shadow-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                >
                    <Icons.Send />
                </button>
            </div>
        </div>
    );
};

// --- KINETIC CANVAS ENGINE ---
const KineticCanvas = ({ type, playing }) => {
    const ref = useRef(null);
    const animationRef = useRef(null);

    useEffect(() => {
        const canvas = ref.current;
        if (animationRef.current) cancelAnimationFrame(animationRef.current);
        if (!canvas) return;

        const ctx = canvas.getContext('2d', { alpha: false });
        const dpr = window.devicePixelRatio || 1;

        // Mutable variables that update when screen resizes
        let w, h, cx, cy, s;
        let offscreen, offCtx;

        const handleResize = () => {
            const rect = canvas.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) return;

            // 1. Resize Canvas Buffer
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            // 2. Update Physics Variables (The Fix)
            w = rect.width;
            h = rect.height;
            cx = w / 2;
            cy = h / 2;
            s = h / 350; // <--- This now updates instantly when layout opens!

            // 3. Re-draw Grid
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            offscreen = document.createElement('canvas');
            offscreen.width = w * dpr;
            offscreen.height = h * dpr;
            offCtx = offscreen.getContext('2d');
            offCtx.scale(dpr, dpr);
            offCtx.strokeStyle = '#1e293b'; 
            offCtx.lineWidth = 1; 
            offCtx.beginPath();
            for (let i = 0; i < w; i += 40) { offCtx.moveTo(i, 0); offCtx.lineTo(i, h); }
            for (let i = 0; i < h; i += 40) { offCtx.moveTo(0, i); offCtx.lineTo(w, i); }
            offCtx.stroke();
        };

        // Attach the listener
        const observer = new ResizeObserver(handleResize);
        observer.observe(canvas);
        let startTime = Date.now();
        let lastFrameTime = 0;  // NEW: Tracks last draw time
        const targetFPS = 30;  // NEW: Cap at 30 (smooth, low CPU)
        const frameInterval = 1000 / targetFPS;  // NEW: ~33ms between frames

        const loop = (currentTime) => {  // CHANGED: Now accepts timestamp param
            if (!ref.current) return;

            const delta = currentTime - lastFrameTime;  // NEW: Time since last frame
            if (delta < frameInterval) {  // NEW: Skip if too soon (throttle)
                animationRef.current = requestAnimationFrame(loop);
                return;
            }
            lastFrameTime = currentTime;  // NEW: Update timestamp

            try {
                ctx.clearRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'source-over'; // Faster blending
                ctx.imageSmoothingEnabled = false; // Crisp, low-cost pixels
                ctx.drawImage(offscreen, 0, 0, w * dpr, h * dpr, 0, 0, w, h);  // Scaled blit: physical src → logical dest
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, cy + 100 * s, w, h - (cy + 100 * s));
                ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, cy + 100 * s); ctx.lineTo(w, cy + 100 * s); ctx.stroke();

                const t = (Date.now() - startTime) / 1000;
                const cycle = Math.sin(t * 2.5); const pos = (cycle + 1) / 2;
                const safe = (v) => Number.isFinite(v) ? v : 0;

                const drawSegment = (x1, y1, x2, y2, w, c = '#94a3b8') => { ctx.save(); ctx.strokeStyle = c; ctx.lineWidth = w; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(safe(x1), safe(y1)); ctx.lineTo(safe(x2), safe(y2)); ctx.stroke(); ctx.restore(); };
                const drawMuscle = (x1, y1, x2, y2, w, act, lbl, sd = 'right') => {
                    const dx = x2 - x1, dy = y2 - y1, len = Math.sqrt(dx * dx + dy * dy); if (len < 1) return;
                    const mx = (x1 + x2) / 2, my = (y1 + y2) / 2, nx = -dy / len, ny = dx / len;
                    const bx = mx + nx * w * (act ? 0.6 : 0.3) * (sd === 'right' ? 1 : -1), by = my + ny * w * (act ? 0.6 : 0.3) * (sd === 'right' ? 1 : -1);
                    ctx.save(); ctx.strokeStyle = act ? '#22d3ee' : '#475569'; ctx.lineWidth = 2; ctx.fillStyle = act ? 'rgba(34,211,238,0.3)' : 'rgba(71,85,105,0.2)';
                    ctx.beginPath(); ctx.moveTo(safe(x1), safe(y1)); ctx.quadraticCurveTo(safe(bx), safe(by), safe(x2), safe(y2)); ctx.fill(); ctx.stroke(); ctx.restore();
                };
                const drawEquipment = (tp, x, y, rt) => {
                    ctx.save(); ctx.translate(safe(x), safe(y)); ctx.rotate(rt);
                    if (tp === 'ball') { ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(0, 0, 8 * s, 0, 2 * Math.PI); ctx.fill(); }
                    else if (tp === 'smash_ball') { ctx.fillStyle = '#f43f5e'; ctx.beginPath(); ctx.arc(0, 0, 5 * s, 0, 2 * Math.PI); ctx.fill(); }
                    else if (tp === 'bar') { ctx.strokeStyle = '#64748b'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(60 * s, 0); ctx.stroke(); }
                    else if (tp === 'swiss') { ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(0, 0, 25 * s, 0, 2 * Math.PI); ctx.fill(); }
                    else if (tp === 'sled') { ctx.fillStyle = '#475569'; ctx.fillRect(-20 * s, -10 * s, 40 * s, 20 * s); }
                    else if (tp === 'dumbbell') { ctx.fillStyle = '#334155'; ctx.fillRect(-10 * s, -5 * s, 20 * s, 10 * s); ctx.fillRect(-15 * s, -8 * s, 5 * s, 16 * s); ctx.fillRect(10 * s, -8 * s, 5 * s, 16 * s); }
                    else if (tp === 'plate') { ctx.fillStyle = '#1e293b'; ctx.beginPath(); ctx.ellipse(0, 0, 15 * s, 15 * s, 0, 0, 2 * Math.PI); ctx.fill(); ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2; ctx.stroke(); }
                    else if (tp === 'handle') { ctx.fillStyle = '#334155'; ctx.fillRect(-5 * s, -15 * s, 10 * s, 30 * s); }
                    else if (tp === 'towel') { ctx.fillStyle = '#e2e8f0'; ctx.fillRect(-30 * s, 0, 60 * s, 3 * s); ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1; ctx.strokeRect(-30 * s, 0, 60 * s, 3 * s); }
                    else if (tp === 'pullup_bar') { ctx.strokeStyle = '#64748b'; ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(-50 * s, 0); ctx.lineTo(50 * s, 0); ctx.stroke(); ctx.fillStyle = '#475569'; ctx.fillRect(-5 * s, -5 * s, 10 * s, 10 * s); } // Grip
                    ctx.restore();
                };

                const drawForce = (x, y, dirX, dirY, lbl) => {
                    const scale = 40 * s;
                    ctx.save(); ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3; ctx.setLineDash([2, 2]);
                    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + dirX * scale, y + dirY * scale); ctx.stroke();
                    ctx.translate(x + dirX * scale, y + dirY * scale); ctx.rotate(Math.atan2(dirY, dirX));
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-5 * s, -5 * s); ctx.lineTo(-5 * s, 5 * s); ctx.fill();
                    ctx.restore();
                    ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 9px monospace'; ctx.fillText(lbl, x + dirX * scale + 5, y + dirY * scale);
                };

                // Easing function for smoother animations
                const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                // --- SCENES ---
                if (type === 'split_squat') {
                    const phase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                    const lunge = phase * 20 * s;
                    const footY = cy + 80 * s;
                    const kneeY = cy + 20 * s + lunge;
                    const hipY = cy - 20 * s + lunge;
                    const backFootX = cx - 60 * s;

                    // Back leg
                    drawSegment(cx, hipY, backFootX + 20 * s, cy + 40 * s + lunge / 2, 16 * s, '#475569');
                    drawSegment(backFootX + 20 * s, cy + 40 * s + lunge / 2, backFootX, footY, 10 * s, '#475569');

                    // Front leg - knee over toe
                    const frontFootX = cx + 40 * s;
                    const frontKneeX = frontFootX + 20 * s;
                    drawSegment(cx, hipY, frontKneeX, kneeY, 16 * s, '#22d3ee');
                    drawSegment(frontKneeX, kneeY, frontFootX, footY, 16 * s, '#22d3ee');

                    // Torso upright
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // VMO glow when deep
                    if (phase > 0.6) {
                        drawMuscle(frontKneeX + 5 * s, kneeY, frontKneeX + 10 * s, kneeY + 20 * s, 14 * s, true, "VMO", 'right');
                    }

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("ATG SPLIT SQUAT", 20, 20);

                    ctx.fillStyle = '#22d3ee';
                    ctx.font = `bold ${12 * s}px sans-serif`;
                    ctx.fillText("KNEE OVER TOE = VMO ACTIVATION", 20, 45);

                    if (phase > 0.7) {
                        ctx.fillStyle = '#f59e0b';
                        ctx.font = `bold ${11 * s}px sans-serif`;
                        ctx.fillText("DEEP FLEXION BUILDS BULLETPROOF KNEE", 20, h - 30);
                    }
                }
                else if (type === 'body_bounce') {
                    // REFINED: Based on video - bouncing w/ significant hip rotation
                    const bouncePhase = easeInOutCubic(Math.abs(Math.sin(t * 6)) / 2 + 0.5); // Smoother fast bounce
                    const bounce = bouncePhase * 8 * s;
                    const shiftPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const shift = shiftPhase * 15 * s;
                    const twistPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const twist = twistPhase * 0.4;

                    const hipX = cx + shift;
                    const hipY = cy + 20 * s - bounce;
                    const footY = cy + 100 * s;
                    const headY = hipY - 70 * s;

                    // Legs slanted due to shift with knee bend for realism
                    const leftKneeY = hipY + (footY - hipY) * 0.5 + Math.sin(t * 6) * 2 * s; // Slight knee flex
                    const leftKneeX = cx - 15 * s + (hipX - (cx - 5 * s)) * 0.5;
                    ctx.beginPath(); ctx.moveTo(cx - 15 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, hipX - 5 * s, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                    const rightKneeY = hipY + (footY - hipY) * 0.5 - Math.sin(t * 6) * 2 * s; // Opposite flex
                    const rightKneeX = cx + 15 * s + (hipX - (cx + 5 * s)) * 0.5;
                    ctx.beginPath(); ctx.moveTo(cx + 15 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, hipX + 5 * s, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();

                    // Torso with slight rotation cue and curve for spine
                    ctx.save();
                    ctx.translate(hipX, hipY);
                    ctx.rotate(twist); // Twist the hips
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * Math.sin(t * 2), -35 * s, 0, -70 * s); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke(); // Curved torso
                    ctx.restore();

                    // Head with slight tilt
                    ctx.beginPath(); ctx.arc(hipX + twist * 5 * s, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Arms relaxed, loose with elbow bend
                    const armBounce = easeInOutCubic((Math.sin(t * 6 + Math.PI) + 1) / 2) * 5 * s;
                    const leftElbowX = hipX - 20 * s - 10 * s * Math.sin(t * 2); const leftElbowY = headY + 10 * s + armBounce / 2;
                    ctx.beginPath(); ctx.moveTo(hipX - 20 * s, headY + 10 * s); ctx.quadraticCurveTo(leftElbowX, leftElbowY, hipX - 35 * s, headY + 40 * s + armBounce); ctx.strokeStyle = '#475569'; ctx.lineWidth = 6 * s; ctx.stroke();
                    const rightElbowX = hipX + 20 * s + 10 * s * Math.sin(t * 2); const rightElbowY = headY + 10 * s - armBounce / 2;
                    ctx.beginPath(); ctx.moveTo(hipX + 20 * s, headY + 10 * s); ctx.quadraticCurveTo(rightElbowX, rightElbowY, hipX + 35 * s, headY + 40 * s + armBounce); ctx.strokeStyle = '#475569'; ctx.lineWidth = 6 * s; ctx.stroke();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("FASCIAL BOUNCE W/ HIP TWIST", 20, 30);
                    drawForce(hipX, hipY, shift > 0 ? 1 : -1, 0, "SHIFT & TWIST");
                    // Actionable cue: Pulsing shift arrow
                    if (shiftPhase > 0.7) {
                        ctx.save(); ctx.globalAlpha = 0.6 + Math.sin(t * 10) * 0.4;
                        drawForce(hipX, hipY, shift > 0 ? 1 : -1, 0, "SHIFT");
                        ctx.restore();
                    }
                }
                else if (type === 'body_wave') {
                    // REFINED: Skier Swing Style - Standing arm swing w/ knee bend
                    // Video shows standing in place, swinging arms down/back (knees bend) then up/overhead (knees straight)
                    const wavePhase = t * 4;
                    const cycle = easeInOutCubic((Math.sin(wavePhase) + 1) / 2); // Smoother cycle

                    // Body posture linked to arm swing
                    // Cycle 0: Arms Back, Knees Bent (Skier Tuck)
                    // Cycle 1: Arms Up, Body Extended

                    const kneeBend = cycle * 15 * s; // Inverted for bend when arms back
                    const trunkLean = cycle * 10 * s; // Lean forward when arms back

                    const hipY = cy + 20 * s + kneeBend;
                    const footY = cy + 100 * s;
                    const headX = cx + trunkLean;
                    const headY = hipY - 70 * s + trunkLean / 2; // Head drops slightly

                    // Legs with knee joints
                    const leftKneeY = hipY + (footY - hipY) * 0.5 - kneeBend / 2; // Bend at knee
                    const leftKneeX = cx - 15 * s + trunkLean / 4;
                    ctx.beginPath(); ctx.moveTo(cx - 15 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, cx, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                    const rightKneeY = hipY + (footY - hipY) * 0.5 + kneeBend / 2; // Slight offset
                    const rightKneeX = cx + 15 * s + trunkLean / 4;
                    ctx.beginPath(); ctx.moveTo(cx + 15 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, cx, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();

                    // Torso with curve
                    const midTorsoX = cx + trunkLean / 2; const midTorsoY = hipY - 35 * s;
                    ctx.beginPath(); ctx.moveTo(cx, hipY); ctx.quadraticCurveTo(midTorsoX, midTorsoY, headX, headY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();

                    // Head
                    ctx.beginPath(); ctx.arc(headX, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Arms: Swing from Overhead to Behind Hips with elbow bend
                    // Angle -PI (up) to 0.5*PI (back)
                    const armAngle = -Math.PI / 2 - (cycle * Math.PI * 0.7); // Dynamic range

                    const shX = headX;
                    const shY = headY + 10 * s;
                    const armLen = 50 * s;
                    const elbowBend = 10 * s * Math.abs(Math.sin(armAngle)); // Bend elbows naturally

                    const leftElbowX = shX + 0.2 * Math.sin(armAngle) * (armLen / 2) - elbowBend;
                    const leftElbowY = shY + Math.cos(armAngle) * (armLen / 2);
                    const leftHandX = leftElbowX + 0.2 * Math.sin(armAngle + 0.2) * (armLen / 2); // Slight offset for realism
                    const leftHandY = leftElbowY + Math.cos(armAngle + 0.2) * (armLen / 2);
                    drawSegment(shX - 5 * s, shY, leftElbowX, leftElbowY, 10 * s, '#22d3ee');
                    drawSegment(leftElbowX, leftElbowY, leftHandX, leftHandY, 10 * s, '#22d3ee');

                    const rightElbowX = shX + 0.2 * Math.sin(armAngle) * (armLen / 2) + elbowBend;
                    const rightElbowY = shY + Math.cos(armAngle) * (armLen / 2);
                    const rightHandX = rightElbowX + 0.2 * Math.sin(armAngle - 0.2) * (armLen / 2);
                    const rightHandY = rightElbowY + Math.cos(armAngle - 0.2) * (armLen / 2);
                    drawSegment(shX + 5 * s, shY, rightElbowX, rightElbowY, 10 * s, '#22d3ee');
                    drawSegment(rightElbowX, rightElbowY, rightHandX, rightHandY, 10 * s, '#22d3ee');

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("STANDING BODY WAVE (SKIER)", 20, 30);
                    // Actionable cue: Arm swing direction
                    if (cycle > 0.5) {
                        drawForce(shX, shY, 0, -1, "EXTEND ARMS");
                    } else {
                        drawForce(shX, shY, 0, 1, "BEND KNEES");
                    }
                }
                else if (type === 'trunk_twist') {
                    // REFINED: Arms are bent at elbows ("washing machine")
                    const rotPhase = easeInOutCubic((Math.sin(t * 4) + 1) / 2); // Smoother rotation
                    const rot = rotPhase * 60; // vigorous twist
                    const hipY = cy + 20 * s;
                    const footY = cy + 100 * s;

                    // Feet wide with slight knee bend
                    const kneeBend = 5 * s + Math.sin(t * 4) * 2 * s;
                    const leftKneeY = hipY + kneeBend; const leftKneeX = cx - 30 * s + (rot * 0.1);
                    ctx.beginPath(); ctx.moveTo(cx - 30 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, cx, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();
                    const rightKneeY = hipY - kneeBend; const rightKneeX = cx + 30 * s - rot * 0.1;
                    ctx.beginPath(); ctx.moveTo(cx + 30 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, cx, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();

                    // Hips with slight rotation
                    ctx.beginPath(); ctx.arc(cx, hipY, 14 * s, 0, 2 * Math.PI); ctx.fillStyle = '#475569'; ctx.fill();

                    ctx.save();
                    ctx.translate(cx, hipY);
                    ctx.rotate(rot * 0.01); // slight hip rot
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * Math.sin(t * 2), -35 * s, 0, -70 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke(); // Curved torso

                    ctx.translate(0, -60 * s);
                    ctx.rotate(rot * Math.PI / 180); // Shoulder rot

                    // Shoulders
                    drawSegment(-20 * s, 0, 20 * s, 0, 16 * s, '#22d3ee');

                    // ARMS: Bent at elbows, hands near chest, swinging with forearm movement
                    // Left Arm
                    const leftUpperAngle = Math.PI / 4 + Math.sin(t * 4) * 0.1;
                    const leftForearmAngle = Math.PI / 2 + Math.cos(t * 4) * 0.1;
                    const leftUpperX = -20 * s + Math.cos(leftUpperAngle) * 20 * s;
                    const leftUpperY = 0 + Math.sin(leftUpperAngle) * 20 * s;
                    drawSegment(-20 * s, 0, leftUpperX, leftUpperY, 8 * s, '#cbd5e1'); // Upper
                    const leftForearmX = leftUpperX + Math.cos(leftForearmAngle) * 15 * s;
                    const leftForearmY = leftUpperY + Math.sin(leftForearmAngle) * 15 * s;
                    drawSegment(leftUpperX, leftUpperY, leftForearmX, leftForearmY, 8 * s, '#cbd5e1'); // Forearm

                    // Right Arm
                    const rightUpperAngle = -Math.PI / 4 - Math.sin(t * 4) * 0.1;
                    const rightForearmAngle = -Math.PI / 2 - Math.cos(t * 4) * 0.1;
                    const rightUpperX = 20 * s + Math.cos(rightUpperAngle) * 20 * s;
                    const rightUpperY = 0 + Math.sin(rightUpperAngle) * 20 * s;
                    drawSegment(20 * s, 0, rightUpperX, rightUpperY, 8 * s, '#cbd5e1'); // Upper
                    const rightForearmX = rightUpperX + Math.cos(rightForearmAngle) * 15 * s;
                    const rightForearmY = rightUpperY + Math.sin(rightForearmAngle) * 15 * s;
                    drawSegment(rightUpperX, rightUpperY, rightForearmX, rightForearmY, 8 * s, '#cbd5e1'); // Forearm

                    // Head with slight counter-rotation
                    ctx.beginPath(); ctx.arc(0 + Math.sin(t * 4) * 2 * s, -15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.restore();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("TRUNK TWIST (BENT ARMS)", 20, 30);
                    // Actionable cue: Rotation direction
                    drawForce(cx, hipY - 70 * s, rot > 0 ? 1 : -1, 0, "TWIST TORSO");
                }
                else if (type === 'arm_raise') {
                    // REFINED: Arms go straight up and down in front (sagittal), not out to side
                    const hipY = cy + 20 * s;
                    const footY = cy + 100 * s;
                    drawSegment(cx - 10 * s, footY, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx + 10 * s, footY, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    const cycle = easeInOutCubic((Math.sin(t * 3) + 1) / 2); // 0 to 1 smoother
                    // Angle: PI (down) to 0 (up)
                    const angle = Math.PI - (cycle * Math.PI); // PI (down) to 0 (up)

                    const shY = hipY - 60 * s;
                    // Arms originate closer to midline to imply sagittal plane
                    const shL = cx - 5 * s;
                    const shR = cx + 5 * s;
                    const armLen = 50 * s;

                    // Better: Draw the arc. If sagittal, x changes little, y changes a lot.
                    // Add elbow for realism
                    const elbowBend = 5 * s * (1 - cycle); // More bend when down
                    const lElbowX = shL - 0.2 * Math.sin(angle) * (armLen / 2) - elbowBend;
                    const lElbowY = shY + Math.cos(angle) * (armLen / 2);
                    const lx = lElbowX - 0.2 * Math.sin(angle - 0.1) * (armLen / 2); // Slight curve
                    const ly = lElbowY + Math.cos(angle - 0.1) * (armLen / 2);

                    drawSegment(shL, shY, lElbowX, lElbowY, 8 * s, '#22d3ee');
                    drawSegment(lElbowX, lElbowY, lx, ly, 8 * s, '#22d3ee');

                    const rElbowX = shR + 0.2 * Math.sin(angle) * (armLen / 2) + elbowBend;
                    const rElbowY = shY + Math.cos(angle) * (armLen / 2);
                    const rx = rElbowX + 0.2 * Math.sin(angle + 0.1) * (armLen / 2);
                    const ry = rElbowY + Math.cos(angle + 0.1) * (armLen / 2);

                    drawSegment(shR, shY, rElbowX, rElbowY, 8 * s, '#22d3ee');
                    drawSegment(rElbowX, rElbowY, rx, ry, 8 * s, '#22d3ee');

                    // Thumbs indicator (yellow dot)
                    if (cycle > 0.8) {
                        ctx.beginPath(); ctx.arc(lx, ly - 5 * s, 4 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f59e0b'; ctx.fill();
                        ctx.beginPath(); ctx.arc(rx, ry - 5 * s, 4 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f59e0b'; ctx.fill();
                    }

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SAGITTAL ARM RAISES", 20, 30);
                    // Actionable cue: Thumb up highlight
                    if (cycle > 0.8) {
                        ctx.save(); ctx.globalAlpha = 0.7; ctx.fillStyle = '#f59e0b'; ctx.fillText("THUMBS UP", 20, 50);
                        ctx.restore();
                    }
                }
                else if (type === 'chest_opener') {
                    // REFINED: Arms meet in middle (clap/touch) then fling wide
                    const hipY = cy + 20 * s;
                    drawSegment(cx, cy + 100 * s, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    const phase = easeInOutCubic((Math.sin(t * 3) + 1) / 2); // Smoother phase
                    const shY = hipY - 60 * s;
                    const maxSpan = 60 * s;

                    // When phase is 0: Hands meet (span is 0 or small)
                    // When phase is 1: Hands wide (span is max)

                    const currentSpan = phase * maxSpan; // 0 to 60

                    // Add a minimal gap so they "meet"
                    const gap = 5 * s;

                    const lx = cx - gap - currentSpan;
                    const rx = cx + gap + currentSpan;

                    // Arms with slight curve for realism
                    const lCurveX = (cx - 15 * s + lx) / 2; const lCurveY = shY - 5 * s * (1 - phase); // Dip when opening
                    ctx.beginPath(); ctx.moveTo(cx - 15 * s, shY); ctx.quadraticCurveTo(lCurveX, lCurveY, lx, shY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 8 * s; ctx.stroke();
                    const rCurveX = (cx + 15 * s + rx) / 2; const rCurveY = shY + 5 * s * (1 - phase);
                    ctx.beginPath(); ctx.moveTo(cx + 15 * s, shY); ctx.quadraticCurveTo(rCurveX, rCurveY, rx, shY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 8 * s; ctx.stroke();

                    // Visual cue for "meeting"
                    if (currentSpan < 5 * s) {
                        ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(cx, shY, 5 * s, 0, 2 * Math.PI); ctx.fill(); // Spark/Touch
                    }

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("CHEST OPENER (MEET & OPEN)", 20, 30);
                    if (phase > 0.8) drawForce(rx, shY, 1, 0, "EXPAND");
                }
                else if (type === 'alt_arm_raise') {
                    // REFINED: Vertical sagittal alternating (Soldier/Swim style)
                    const hipY = cy + 20 * s;
                    const footY = cy + 100 * s;
                    drawSegment(cx - 10 * s, footY, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx + 10 * s, footY, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    const shY = hipY - 60 * s;
                    const shL = cx - 15 * s;
                    const shR = cx + 15 * s;
                    const armLen = 50 * s;

                    // Phase for alternation with easing
                    const phase = easeInOutCubic((Math.sin(t * 4) + 1) / 2);

                    // Left Arm: 0 = Down (PI), 1 = Up (0)
                    const lAngle = Math.PI - (phase * Math.PI); // PI to 0

                    // Right Arm: Opposite
                    const rAngle = Math.PI - ((1 - phase) * Math.PI); // 0 to PI (inverted)

                    // Draw with slight sagittal tilt and elbow for depth
                    const lElbowAngle = lAngle + 0.2 * Math.sin(t * 2); // Dynamic bend
                    const lElbowX = shL - Math.sin(lElbowAngle) * (armLen / 2) * s / s;
                    const lElbowY = shY + Math.cos(lElbowAngle) * (armLen / 2);
                    const lx = lElbowX - Math.sin(lAngle) * (armLen / 2) * 5 * s / 100;
                    const ly = lElbowY + Math.cos(lAngle) * (armLen / 2);

                    drawSegment(shL, shY, lElbowX, lElbowY, 8 * s, '#22d3ee');
                    drawSegment(lElbowX, lElbowY, lx, ly, 8 * s, '#22d3ee');

                    const rElbowAngle = rAngle - 0.2 * Math.sin(t * 2);
                    const rElbowX = shR - Math.sin(rElbowAngle) * (armLen / 2) * s / s;
                    const rElbowY = shY + Math.cos(rElbowAngle) * (armLen / 2);
                    const rx = rElbowX - Math.sin(rAngle) * (armLen / 2) * 5 * s / 100;
                    const ry = rElbowY + Math.cos(rAngle) * (armLen / 2);

                    drawSegment(shR, shY, rElbowX, rElbowY, 8 * s, '#22d3ee');
                    drawSegment(rElbowX, rElbowY, rx, ry, 8 * s, '#22d3ee');

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ALTERNATE ARM RAISES", 20, 30);
                    // Actionable cue: Reciprocal motion label
                    drawForce(cx, shY, 0, phase > 0.5 ? -1 : 1, "ALTERNATE");
                }
                else if (type === 'landmine_rotation' || type === 'landmine_twist') {
                    // FIXED: Starts from ground, rigid bar
                    const rotPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const rot = rotPhase * 40 * s;
                    const hipY = cy + 20 * s; const footY = cy + 100 * s;
                    // Legs pivoting with knee bend
                    const pivotLeft = rot > 0;
                    const kneeBend = 5 * s * rotPhase;
                    const leftShinX = cx - 15 * s + (pivotLeft ? kneeBend : 0);
                    drawSegment(cx - 15 * s, hipY, leftShinX, cy + 50 * s, 16 * s, pivotLeft ? '#22d3ee' : '#475569');
                    drawSegment(leftShinX, cy + 50 * s, cx - 25 * s, footY, 16 * s, pivotLeft ? '#22d3ee' : '#475569');
                    const rightShinX = cx + 15 * s - (pivotLeft ? 0 : kneeBend);
                    drawSegment(cx + 15 * s, hipY, rightShinX, cy + 50 * s, 16 * s, !pivotLeft ? '#22d3ee' : '#475569');
                    drawSegment(rightShinX, cy + 50 * s, cx + 25 * s, footY, 16 * s, !pivotLeft ? '#22d3ee' : '#475569');

                    // Torso Twist with curve
                    ctx.save(); ctx.translate(cx, hipY); ctx.rotate(rot * 0.025);
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * rotPhase, -30 * s, 0, -60 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                    ctx.restore();

                    ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    const handsX = cx + rot * 1.5; const handsY = hipY - 50 * s + Math.abs(rot) * 0.5;

                    // Barbell anchored on ground with slight flex
                    const anchorX = cx - 80 * s; const anchorY = footY;
                    const barMidX = (anchorX + handsX) / 2 + Math.sin(t * 2) * 2 * s; // Slight vibration for realism
                    const barMidY = (anchorY + handsY) / 2;
                    ctx.beginPath(); ctx.moveTo(anchorX, anchorY); ctx.quadraticCurveTo(barMidX, barMidY, handsX, handsY); ctx.strokeStyle = '#64748b'; ctx.lineWidth = 6; ctx.stroke();
                    ctx.fillStyle = '#1e293b'; ctx.beginPath(); ctx.arc(anchorX, anchorY, 10 * s, 0, Math.PI); ctx.fill();

                    drawSegment(cx, hipY - 50 * s, handsX, handsY, 8 * s, '#cbd5e1');

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("LANDMINE TWIST", 20, 30);
                    // Actionable cue: Pivot feet
                    if (rotPhase > 0.7) {
                        drawForce(cx, footY, pivotLeft ? -1 : 1, 0, "PIVOT");
                    }
                }
                else if (type === 'band_twist') {
                    // REFINED: Looks like Pallof but rotates
                    const twistPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                    const twist = twistPhase * 35 * s;
                    const hipY = cy + 20 * s;
                    const cableX = cx - 100 * s; const cableY = cy - 20 * s;

                    // Static Stance (Pallof Base) with slight knee flex
                    const kneeFlex = 3 * s * twistPhase;
                    drawSegment(cx - 15 * s, hipY, cx - 20 * s, cy + 50 * s + kneeFlex, 16 * s, '#475569');
                    drawSegment(cx - 20 * s, cy + 50 * s + kneeFlex, cx - 20 * s, cy + 100 * s, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, hipY, cx + 20 * s, cy + 50 * s - kneeFlex, 16 * s, '#475569');
                    drawSegment(cx + 20 * s, cy + 50 * s - kneeFlex, cx + 20 * s, cy + 100 * s, 16 * s, '#475569');

                    ctx.save(); ctx.translate(cx, hipY); ctx.rotate(twist * 0.02);
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(3 * s * twistPhase, -30 * s, 0, -60 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                    ctx.restore();

                    // Hands follow rotation with grip
                    const handsX = cx + twist * 1.5;
                    drawSegment(cx, hipY - 50 * s, handsX, hipY - 50 * s, 8 * s, '#cbd5e1');
                    ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Band line from anchor to hands with stretch effect
                    const bandMidX = (cableX + handsX) / 2 + Math.sin(t * 5) * 2 * s; // Vibration for tension
                    const bandMidY = (cableY + hipY - 50 * s) / 2;
                    ctx.beginPath(); ctx.moveTo(cableX, cableY); ctx.quadraticCurveTo(bandMidX, bandMidY, handsX, hipY - 50 * s); ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 3 + twistPhase; ctx.stroke();
                    ctx.fillStyle = '#334155'; ctx.fillRect(cableX - 10 * s, hipY - 70 * s, 10 * s, 40 * s); // Anchor

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("BAND TWIST", 20, 30);
                    // Actionable cue: Resist twist
                    drawForce(handsX, hipY - 50 * s, -1, 0, "RESIST");
                }
                else if (type === 'wall_throw') {
                    // NEW: Rotational Wall Throw
                    const wallX = cx + 80 * s;
                    ctx.fillStyle = '#334155'; ctx.fillRect(wallX, 0, 10 * s, h); // Wall

                    const phase = easeInOutCubic(((t * 1.5) % 2) / 2); // Smoother phase
                    const isThrowing = phase > 0.5 && phase < 0.65;
                    const rotPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const rot = rotPhase * 25 * s;
                    const hipY = cy + 20 * s;

                    drawSegment(cx - 15 * s, hipY, cx - 20 * s, cy + 100 * s, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, hipY, cx + 20 * s, cy + 100 * s, 16 * s, isThrowing ? '#22d3ee' : '#475569');

                    ctx.save(); ctx.translate(cx, hipY); ctx.rotate(rot * 0.03);
                    drawSegment(0, 0, 0, -60 * s, 16 * s, '#22d3ee');
                    ctx.restore();

                    const handsX = cx + rot * 1.5;
                    drawSegment(cx, hipY - 50 * s, handsX, hipY - 50 * s, 8 * s, '#cbd5e1');
                    ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Ball Physics with bounce on wall
                    let ballX = handsX + 15 * s;
                    let ballY = hipY - 50 * s + Math.sin(t * 10) * 2 * s; // Slight vertical bob
                    if (isThrowing) {
                        ballX += (phase - 0.5) * 300 * s; // Faster fly to wall
                        if (ballX >= wallX - 8 * s) { // Bounce back
                            ballX = wallX - 8 * s - (phase - 0.6) * 50 * s;
                            ballY += Math.sin((phase - 0.6) * Math.PI * 5) * 10 * s; // Bounce arc
                        }
                        drawForce(ballX, ballY, 1, 0, "RELEASE");
                    }
                    drawEquipment('ball', ballX, ballY, t * 2); // Rotate ball for realism

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ROTATIONAL WALL THROW", 20, 30);
                    // Actionable cue: Rotate hips
                    if (isThrowing) {
                        drawForce(cx, hipY, rot > 0 ? 1 : -1, 0, "ROTATE HIPS");
                    }
                }
                else if (type === 'med_ball_slam') {
                    const phase = easeInOutCubic(((t * 2.3) % 2) / 2);
                    const isLifting = phase < 0.4;
                    const isTop = phase >= 0.4 && phase < 0.5;
                    const isSlamming = phase >= 0.5;

                    const hipY = cy + 20 * s;
                    const shY = cy - 40 * s;

                    // Triple extension on lift
                    const extension = isLifting ? (0.4 - phase) * 30 * s : isSlamming ? (phase - 0.5) * 40 * s : 0;
                    const kneeExtend = isLifting ? 20 * s : isSlamming ? -30 * s : 0;

                    // Legs
                    drawSegment(cx - 20 * s, hipY + kneeExtend, cx - 25 * s, cy + 100 * s, 16 * s, isLifting ? '#22d3ee' : '#475569');
                    drawSegment(cx + 20 * s, hipY + kneeExtend, cx + 25 * s, cy + 100 * s, 16 * s, isLifting ? '#22d3ee' : '#475569');

                    // Torso
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 18 * s, '#475569');

                    // Ball arc
                    let ballX = cx;
                    let ballY = shY - 140 * s;
                    if (isLifting) {
                        ballY = shY - 140 * s + (0.4 - phase) * 100 * s;
                    } else if (isSlamming) {
                        const p = (phase - 0.5) / 0.5;
                        ballX = cx + p * 70 * s;
                        ballY = shY - 140 * s + p * p * 400 * s;
                    }

                    // Arms
                    drawSegment(cx - 15 * s, shY, ballX - 10 * s, ballY, 10 * s, '#38bdf8');
                    drawSegment(cx + 15 * s, shY, ballX + 10 * s, ballY, 10 * s, '#38bdf8');

                    // Ball with impact glow
                    ctx.save();
                    if (!isLifting && phase > 0.8) {
                        ctx.shadowBlur = 40;
                        ctx.shadowColor = "#f59e0b";
                    }
                    drawEquipment('ball', ballX, ballY, t * (isSlamming ? 10 : 2));
                    ctx.restore();

                    // Head
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("MED BALL POWER SLAM", 20, 20);

                    if (isLifting) {
                        ctx.fillStyle = '#22d3ee';
                        ctx.font = `bold ${12 * s}px sans-serif`;
                        ctx.fillText("TRIPLE EXTENSION", 20, 50);
                    } else if (isSlamming) {
                        ctx.fillStyle = '#f59e0b';
                        ctx.font = `bold ${12 * s}px sans-serif`;
                        ctx.fillText("EXPLOSIVE HIP DRIVE", 20, 50);
                    }

                    if (phase > 0.9) {
                        ctx.fillStyle = '#f97316';
                        ctx.font = `bold ${13 * s}px sans-serif`;
                        ctx.fillText("IMPACT!", cx - 40, cy + 60);
                    }
                }
                else if (type === 'weck_pulse') {
                    const pulsePhase = easeInOutCubic(Math.abs(Math.sin(t * 4)));
                    const pulse = pulsePhase * 5 * s;
                    const hipY = cy + pulse;
                    drawSegment(cx, hipY, cx - 20 * s, cy + 80 * s, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx + 20 * s, cy + 80 * s, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 60 * s, 16 * s, '#22d3ee');
                    ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    const headX = cx; const footX = cx + 20 * s;
                    ctx.strokeStyle = '#22d3ee'; ctx.setLineDash([2, 2]); ctx.beginPath(); ctx.moveTo(headX, hipY - 75 * s); ctx.lineTo(footX, cy + 80 * s); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("DOUBLE DOWN PULSE", 20, 30);
                    // Actionable cue: Pulse highlight
                    ctx.save(); ctx.globalAlpha = pulsePhase; ctx.fillStyle = '#22d3ee'; ctx.fillRect(cx - 10 * s, hipY, 20 * s, -60 * s);
                    ctx.restore();
                }
                else if (type === 'towel_curl') {
    // PHYSICS: The "Windlass Mechanism" + Cloth Simulation
    // As toes curl (flex), the arch MUST rise, and the towel MUST bunch up.
    
    const cycle = easeInOutCubic((Math.sin(t * 2.5) + 1) / 2); // 0 (flat) to 1 (curled)
    const heelX = cx - 35 * s;
    const ballX = cx + 25 * s;
    const footY = cy + 80 * s; // Ground level
    
    // 1. Arch Mechanics (Windlass)
    // The arch rises as the toes curl. This is the bio-mechanical goal.
    const archHeight = 10 * s + (cycle * 15 * s); 
    const ankleX = cx - 10 * s;
    const ankleY = footY - 40 * s - (cycle * 5 * s); // Ankle rises slightly

    // Draw Leg
    drawSegment(ankleX, ankleY, ankleX + 5 * s, cy - 40 * s, 14 * s, '#475569'); // Shin
    
    // Draw Foot (Heel -> Arch -> Ball)
    ctx.beginPath();
    ctx.moveTo(heelX, footY);
    ctx.quadraticCurveTo(cx, footY - archHeight, ballX, footY);
    ctx.lineWidth = 14 * s;
    ctx.strokeStyle = '#22d3ee';
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // 2. Toe Dexterity (The "Grip")
    // Toes don't just bend; they hook downwards and pull back.
    const toeLen = 20 * s;
    const toeCurlAngle = cycle * Math.PI * 0.6; // Bend 100 degrees
    const toeX = ballX + Math.cos(toeCurlAngle) * toeLen;
    const toeY = footY + Math.sin(toeCurlAngle) * toeLen * 0.6; // Flatten on floor
    
    ctx.beginPath();
    ctx.moveTo(ballX, footY);
    ctx.quadraticCurveTo(ballX + 10 * s, footY - (cycle * 10 * s), toeX, toeY);
    ctx.lineWidth = 14 * s;
    ctx.strokeStyle = '#22d3ee';
    ctx.stroke();

    // 3. CLOTH SIMULATION (The Towel)
    // We draw the towel as a sine wave that increases in amplitude (bunching)
    // and decreases in length (gathering) as toes curl.
    ctx.beginPath();
    const towelStart = ballX;
    const towelLen = 80 * s * (1 - cycle * 0.4); // Towel gets shorter as it bunches
    const bunches = 6;
    
    ctx.moveTo(towelStart, footY + 8 * s);
    
    for (let i = 0; i <= bunches; i++) {
        const x = towelStart + (i / bunches) * towelLen;
        // Amplitude grows with cycle. Sine wave creates "wrinkles"
        const y = footY + 8 * s - Math.sin(i * Math.PI) * (cycle * 12 * s); 
        ctx.lineTo(x, y);
    }
    
    ctx.lineJoin = 'round';
    ctx.lineWidth = 4 * s;
    ctx.strokeStyle = '#e2e8f0'; // White towel
    ctx.stroke();
    
    // 4. Visual Feedback
    ctx.fillStyle = '#fff'; ctx.font = `bold ${12 * s}px sans-serif`; ctx.fillText("INTRINSIC FOOT STRENGTH", 20, 30);
    
    // Highlight the Arch rising (The "Why")
    if (cycle > 0.6) {
        drawForce(cx, footY - archHeight + 10 * s, 0, -1, "ARCH LIFT");
        ctx.fillStyle = '#22d3ee'; ctx.font = `bold ${10 * s}px sans-serif`; 
        ctx.fillText("WINDLASS ON", cx - 20 * s, cy);
    }
}
                else if (type === 'pallof_press') {
                    const pressPhase = easeInOutCubic(Math.abs(Math.sin(t * 2.2)));
                    const press = pressPhase * 35 * s;
                    const braceIntensity = pressPhase > 0.5 ? 0.6 + Math.sin(t * 8) * 0.3 : 0.3;

                    const cableX = cx - 90 * s;
                    const cableY = cy - 10 * s;
                    const bodyX = cx + 15 * s;
                    const handY = cy - 10 * s;

                    // Stable stance - slight knee soften
                    const kneeFlex = 5 * s;
                    drawSegment(bodyX - 20 * s, cy + 100 * s, bodyX - 15 * s, cy + 40 * s + kneeFlex, 16 * s, '#475569');
                    drawSegment(bodyX + 20 * s, cy + 100 * s, bodyX + 15 * s, cy + 40 * s + kneeFlex, 16 * s, '#475569');

                    // Torso - upright and braced
                    drawSegment(bodyX, cy + 40 * s, bodyX, cy - 60 * s, 18 * s, '#22d3ee');

                    // Oblique sling activation - clean X pattern glow
                    ctx.save();
                    ctx.globalAlpha = braceIntensity;
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 12 * s;
                    ctx.setLineDash([4, 8]);
                    ctx.beginPath();
                    // Left oblique to right hip
                    ctx.moveTo(bodyX - 10 * s, cy - 40 * s);
                    ctx.quadraticCurveTo(bodyX, cy, bodyX + 20 * s, cy + 50 * s);
                    // Right oblique to left hip
                    ctx.moveTo(bodyX + 10 * s, cy - 40 * s);
                    ctx.quadraticCurveTo(bodyX, cy, bodyX - 20 * s, cy + 50 * s);
                    ctx.stroke();
                    ctx.restore();

                    // Arms - clean, connected, no extras
                    const shoulderY = cy - 50 * s;
                    const elbowOffset = pressPhase * 8 * s;
                    const leftElbowX = bodyX - 15 * s - elbowOffset;
                    const rightElbowX = bodyX + 15 * s + elbowOffset;
                    const handX = bodyX + press;

                    // Upper arms
                    drawSegment(bodyX - 12 * s, shoulderY, leftElbowX, shoulderY + 5 * s, 10 * s, '#cbd5e1');
                    drawSegment(bodyX + 12 * s, shoulderY, rightElbowX, shoulderY + 5 * s, 10 * s, '#cbd5e1');

                    // Forearms to hands
                    drawSegment(leftElbowX, shoulderY + 5 * s, handX - 8 * s, handY, 10 * s, '#cbd5e1');
                    drawSegment(rightElbowX, shoulderY + 5 * s, handX + 8 * s, handY, 10 * s, '#cbd5e1');

                    // Cable - thicker when resisting
                    ctx.strokeStyle = '#f43f5e';
                    ctx.lineWidth = 5 + pressPhase * 4;
                    ctx.beginPath();
                    ctx.moveTo(cableX, cableY);
                    ctx.lineTo(handX, handY);
                    ctx.stroke();

                    // Anchor post
                    ctx.fillStyle = '#334155';
                    ctx.fillRect(cableX - 12 * s, cableY - 60 * s, 24 * s, 120 * s);

                    // Head - stable
                    ctx.beginPath();
                    ctx.arc(bodyX, cy - 75 * s, 18 * s, 0, 2 * Math.PI);
                    ctx.fillStyle = '#cbd5e1';
                    ctx.fill();

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("PALLOF PRESS", 20, 20);

                    ctx.fillStyle = '#f59e0b';
                    ctx.font = `bold ${13 * s}px sans-serif`;
                    ctx.fillText("ANTI-ROTATION = FOUNDATION OF POWER", 20, 45);

                    if (pressPhase > 0.5) {
                        ctx.fillStyle = '#22d3ee';
                        ctx.font = `bold ${12 * s}px sans-serif`;
                        ctx.fillText("OBLIQUE SLINGS BRACING", 20, h - 50);
                    }

                    drawForce(handX + 10, handY, -1, 0, "RESIST TWIST");
                }
                else if (type === 'head_loading_basic' || type === 'head_loading') {
                    // ELITE CERVICAL ALIGNMENT: Stillness + Deep Core Activation Under Axial Load
                    const breathPhase = easeInOutCubic((Math.sin(t * 1.4) + 1) / 2);
                    const armReachPhase = Math.min(1, t / 3);

                    const headX = cx;
                    const headY = cy - 60 * s - breathPhase * 6 * s;
                    const shoulderY = cy - 20 * s;
                    const hipY = cy + 40 * s;
                    const footY = cy + 100 * s;

                    // Gravity line
                    ctx.save();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(cx, footY);
                    ctx.lineTo(cx, headY - 50 * s);
                    ctx.stroke();
                    ctx.restore();

                    // Stable body
                    drawSegment(cx - 15 * s, footY, cx - 8 * s, hipY, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, footY, cx + 8 * s, hipY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, shoulderY, 16 * s, '#475569');

                    // Breath expansion glow
                    const breathExpand = breathPhase * 10 * s;
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#22d3ee';
                    ctx.beginPath();
                    ctx.ellipse(cx, (shoulderY + hipY) / 2, 30 * s + breathExpand, 50 * s + breathExpand / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // Multifidus glow
                    if (breathPhase > 0.5) {
                        drawMuscle(cx - 4 * s, hipY + 10 * s, cx - 4 * s, shoulderY - 10 * s, 12 * s, true);
                        drawMuscle(cx + 4 * s, hipY + 10 * s, cx + 4 * s, shoulderY - 10 * s, 12 * s, true);
                    }

                    // --- NEW REALISTIC HOLDING ARMS ---
// 1. Define the ball's position (it moves with the head breath)
const ballY = headY - 38 * s; // Matches the ball drawing coordinate

// 2. Define Shoulders (Fixed)
const shL_x = cx - 20 * s; 
const shR_x = cx + 20 * s;
const sh_y = shoulderY;

// 3. Define Target Hand Positions (Holding sides of ball)
const handL_target_x = cx - 14 * s; // Left hand on left side of ball
const handR_target_x = cx + 14 * s; // Right hand on right side of ball
const hand_target_y = ballY;

// 4. Define Target Elbow Positions (Flared out for stability)
const elbowL_target_x = cx - 45 * s;
const elbowR_target_x = cx + 45 * s;
const elbow_target_y = (sh_y + ballY) / 2; // Midpoint vertically

// 5. Define Start Positions (Hands at sides)
const handL_start_x = cx - 25 * s;
const handR_start_x = cx + 25 * s;
const hand_start_y = cy + 40 * s; // Hips

const elbowL_start_x = cx - 30 * s; 
const elbowR_start_x = cx + 30 * s;
const elbow_start_y = cy + 10 * s;

// 6. Interpolate based on armReachPhase (Smooth animation up)
const reach = easeInOutCubic(armReachPhase); 

const hLx = handL_start_x + (handL_target_x - handL_start_x) * reach;
const hLy = hand_start_y + (hand_target_y - hand_start_y) * reach;
const eLx = elbowL_start_x + (elbowL_target_x - elbowL_start_x) * reach;
const eLy = elbow_start_y + (elbow_target_y - elbow_start_y) * reach;

const hRx = handR_start_x + (handR_target_x - handR_start_x) * reach;
const hRy = hand_start_y + (hand_target_y - hand_start_y) * reach;
const eRx = elbowR_start_x + (elbowR_target_x - elbowR_start_x) * reach;
const eRy = elbow_start_y + (elbow_target_y - elbow_start_y) * reach;

// 7. Draw The Arms (Shoulder -> Elbow -> Hand)
drawSegment(shL_x, sh_y, eLx, eLy, 10 * s, '#cbd5e1'); // Left Upper
drawSegment(eLx, eLy, hLx, hLy, 9 * s, '#cbd5e1');     // Left Forearm
drawSegment(shR_x, sh_y, eRx, eRy, 10 * s, '#cbd5e1'); // Right Upper
drawSegment(eRx, eRy, hRx, hRy, 9 * s, '#cbd5e1');     // Right Forearm

// Draw Hands gripping (Small circles)
ctx.beginPath(); ctx.arc(hLx, hLy, 5 * s, 0, 2 * Math.PI); ctx.fillStyle = '#22d3ee'; ctx.fill();
ctx.beginPath(); ctx.arc(hRx, hRy, 5 * s, 0, 2 * Math.PI); ctx.fillStyle = '#22d3ee'; ctx.fill();

                    // Head & ball - perfectly stable
                    ctx.beginPath(); ctx.arc(headX, headY, 22 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    drawEquipment('ball', headX, headY - 38 * s, 0);

                    // === TEXT WITH FIXED SCALED FONTS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("CERVICAL AXIAL DECOMPRESSION", 20, 20);

                    ctx.fillStyle = breathPhase > 0.5 ? '#f59e0b' : '#22d3ee';
                    ctx.font = `bold ${12 * s}px sans-serif`;
                    ctx.fillText(breathPhase > 0.5 ? "EXHALE — RELAX & HOLD" : "INHALE — LENGTHEN & ACTIVATE", 20, 45);

                    if (breathPhase > 0.6) {
                        ctx.fillStyle = '#22d3ee';
                        ctx.font = `bold ${11 * s}px sans-serif`;
                        ctx.fillText("DEEP CORE FIRING", cx - 60, cy - 10);
                        ctx.fillText("(Multifidus + TA)", cx - 60, cy + 8);
                    }

                    ctx.fillStyle = '#f59e0b';
                    ctx.font = `bold ${11 * s}px sans-serif`;
                    ctx.fillText("GRAVITY LINE — PERFECT ALIGNMENT", cx + 15, footY - 25);

                    ctx.fillStyle = '#f59e0b';
                    ctx.font = `bold ${10 * s}px sans-serif`;
                    ctx.fillText("STILLNESS UNDER LOAD = TRUE STRENGTH", 20, h - 30);
                }
                else if (type === 'head_hinge') {  // Realistic Head-Loaded Hip Hinge with Hands Holding Ball
    const phase = easeInOutCubic((Math.sin(t * 1.8) + 1) / 2);  // Slower, smoother hinge
    const hingeAngle = phase * 50 * (Math.PI / 180);  // Up to ~50° for deeper hinge
    const hipShiftBack = -phase * 30 * s;  // Butt pushes back for realism (negative to shift opposite to lean)
    const hipX = cx + hipShiftBack;
    const thighLength = 50 * s;
    const shinLength = 50 * s;
    const kneeY = cy + shinLength;
    const footY = kneeY + shinLength;
    const deltaX = hipShiftBack;
    const thighEffectiveLength = Math.sqrt(thighLength ** 2 - deltaX ** 2);
    const hipY = kneeY - thighEffectiveLength;
    // Torso (spine) hinged from hips
    ctx.save();
    ctx.translate(hipX, hipY);
    ctx.rotate(hingeAngle);
    drawSegment(0, -60 * s, 0, 20 * s, 18 * s, '#475569');  // Thicker neutral spine
    ctx.restore();
    // Calculate shoulder position (top of torso)
    const shoulderX = hipX + Math.sin(hingeAngle) * 60 * s;
    const shoulderY = hipY - 60 * s * Math.cos(hingeAngle);
    // Head position (consistent with shoulder, no extra offset)
    const headX = shoulderX;
    const headY = shoulderY - 60 * s;  // Adjusted for better proportion
    // Draw head
    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
    // Draw ball on head
    drawEquipment('ball', headX, headY - 28 * s, 0);
    // Legs with knees: shins vertical, thighs angled
    const leftFootX = cx - 20 * s;
    const rightFootX = cx + 20 * s;
    const leftKneeX = leftFootX;
    const rightKneeX = rightFootX;
    const leftHipX = hipX - 20 * s;
    const rightHipX = hipX + 20 * s;
    // Left leg (thigh and shin)
    drawSegment(leftHipX, hipY, leftKneeX, kneeY, 16 * s, '#22d3ee');  // Thigh
    drawSegment(leftKneeX, kneeY, leftFootX, footY, 16 * s, '#22d3ee');  // Shin
    // Right leg (thigh and shin)
    drawSegment(rightHipX, hipY, rightKneeX, kneeY, 16 * s, '#22d3ee');  // Thigh
    drawSegment(rightKneeX, kneeY, rightFootX, footY, 16 * s, '#22d3ee');  // Shin
    // NEW: Both hands holding the ball - realistic bent arms
    // Left arm (visible in side view as "front" arm)
    const leftHandX = headX - 10 * s;
    const leftHandY = headY - 20 * s;
    const leftElbowX = shoulderX - 20 * s;  // Flare out left
    const leftElbowY = (shoulderY + leftHandY) / 2 + 10 * s;  // Slight down curve
    drawSegment(shoulderX, shoulderY, leftElbowX, leftElbowY, 8 * s, '#cbd5e1');
    drawSegment(leftElbowX, leftElbowY, leftHandX, leftHandY, 8 * s, '#cbd5e1');
    // Right arm (behind in side view, slightly offset for visibility)
    const rightHandX = headX + 10 * s;
    const rightHandY = headY - 20 * s;
    const rightElbowX = shoulderX + 20 * s;  // Flare out right
    const rightElbowY = (shoulderY + rightHandY) / 2 + 10 * s;
    drawSegment(shoulderX, shoulderY, rightElbowX, rightElbowY, 8 * s, '#cbd5e1');
    drawSegment(rightElbowX, rightElbowY, rightHandX, rightHandY, 8 * s, '#cbd5e1');
    // NEW: Neck glow during deep hinge (like VMO in split_squat)
    if (phase > 0.6) {
        drawMuscle(shoulderX, shoulderY - 10 * s, headX, headY + 10 * s, 14 * s, true, "AXIAL LOAD", 'right');
    }
    // NEW: Glutes/Hams glow for lower body engagement
    if (phase > 0.6) {
        drawMuscle(hipX, hipY - 10 * s, hipX, hipY + 20 * s, 20 * s, true, "GLUTES/HAMS", 'left');
    }
    // Captions and Cues
    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED HIP HINGE", 20, 30);
    drawForce(hipX, hipY + 60 * s, -1, 0, "PUSH BUTT BACK");  // Adjusted direction for realism
    if (phase > 0.5) {
        ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 11px sans-serif'; ctx.fillText("HANDS HOLD BALL", 20, h - 30);
    }
}
                else if (type === 'head_split') {
    const phase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
    const depth = phase * 35 * s;  // Deeper drop
    const headX = cx + Math.sin(t * 2) * 2 * s;  // Slight natural sway
    const headY = cy - 60 * s + depth * 0.3;  // Head stays high and stable
    const hipY = cy + 10 * s + depth;
    const frontFootX = cx + 55 * s;
    const backFootX = cx - 55 * s;
    const frontKneeX = cx + 45 * s;
    const backKneeX = cx - 20 * s;

    // Weight perfectly balanced on head
    drawEquipment('ball', headX, headY - 35 * s, t * 0.5);  // Slight wobble for realism

    // Front leg — deep ATG, knee well over toe
    drawSegment(cx, hipY, frontKneeX, cy + 45 * s + depth, 18 * s, '#22d3ee');
    drawSegment(frontKneeX, cy + 45 * s + depth, frontFootX, cy + 100 * s, 16 * s, '#22d3ee');

    // Back leg — straight, heel up
    drawSegment(cx, hipY, backKneeX, cy + 70 * s + depth * 0.5, 16 * s, '#475569');
    drawSegment(backKneeX, cy + 70 * s + depth * 0.5, backFootX, cy + 100 * s, 14 * s, '#475569');

    // Torso — perfectly upright, no lean
    drawSegment(cx, hipY, cx, hipY - 80 * s, 18 * s, '#22d3ee');

    // Head — stable on top
    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

    // VMO glow on front thigh when deep
    if (phase > 0.6) {
        drawMuscle(frontKneeX - 5 * s, cy + 45 * s + depth, frontKneeX + 10 * s, cy + 60 * s + depth, 16 * s, true, "VMO", 'right');
    }

    // Caption
    ctx.fillStyle = '#fff'; ctx.font = `bold ${14 * s}px sans-serif`; ctx.fillText("HEAD-LOADED ATG SPLIT SQUAT", 20, 30);

    // Key cue when deep
    if (phase > 0.7) {
        ctx.fillStyle = '#f59e0b'; ctx.font = `bold ${12 * s}px sans-serif`;
        ctx.fillText("KNEE OVER TOE • TORSO TALL", 20, 55);
    }
}
                else if (type === 'head_coiling') {  // Coiling (simple version)
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED COILING", 20, 30);
                    // (reuses coiling_lunge logic + ball on head - you already have coiling_lunge, so it will look good)
                }
                else if (type === 'head_march') {
                    const marchCycle = Math.sin(t * 5);  // Faster, smoother march
                    const leftKneeUp = marchCycle > 0 ? Math.abs(marchCycle) * 45 * s : 0;
                    const rightKneeUp = marchCycle < 0 ? Math.abs(marchCycle) * 45 * s : 0;

                    const headX = cx + Math.sin(t * 5) * 4 * s;  // Tiny natural sway
                    const headY = cy - 40 * s;
                    drawEquipment('ball', headX, headY - 28 * s, 0);

                    // Upright torso
                    drawSegment(cx, cy - 20 * s, cx, cy + 40 * s, 18 * s, '#475569');

                    // Left leg - marches when right is down
                    const leftThighY = cy + 40 * s + leftKneeUp * 0.5;
                    drawSegment(cx - 15 * s, cy + 40 * s, cx - 15 * s, leftThighY, 16 * s, leftKneeUp > 0 ? '#22d3ee' : '#475569');
                    drawSegment(cx - 15 * s, leftThighY, cx - 20 * s, cy + 90 * s + leftKneeUp * 0.8, 14 * s, leftKneeUp > 0 ? '#22d3ee' : '#475569');

                    // Right leg
                    const rightThighY = cy + 40 * s + rightKneeUp * 0.5;
                    drawSegment(cx + 15 * s, cy + 40 * s, cx + 15 * s, rightThighY, 16 * s, rightKneeUp > 0 ? '#22d3ee' : '#475569');
                    drawSegment(cx + 15 * s, rightThighY, cx + 20 * s, cy + 90 * s + rightKneeUp * 0.8, 14 * s, rightKneeUp > 0 ? '#22d3ee' : '#475569');

                    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED MARCH", 20, 30);
                    drawForce(headX, headY, 0, 0.3, "STABLE CORE");
                }
                else if (type === 'meta_release') {
                    // Seated figure crossing leg
                    const hipY = cy + 20 * s;
                    const headY = hipY - 60 * s;

                    // Torso & Head
                    ctx.beginPath(); ctx.moveTo(cx, hipY); ctx.quadraticCurveTo(cx + 10 * s, (hipY + headY) / 2, cx + 5 * s, headY);
                    ctx.lineWidth = 14 * s; ctx.strokeStyle = '#475569'; ctx.stroke();
                    ctx.beginPath(); ctx.arc(cx + 5 * s, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Legs: Left leg planted, Right leg crossed over knee
                    drawSegment(cx, hipY, cx - 10 * s, cy + 90 * s, 14 * s, '#475569'); // Planted leg

                    // Crossed Leg (Target)
                    const kneeX = cx + 25 * s; const kneeY = hipY - 10 * s;
                    const footTargetX = cx - 10 * s; const footTargetY = hipY + 10 * s;
                    drawSegment(cx, hipY, kneeX, kneeY, 14 * s, '#22d3ee'); // Thigh
                    drawSegment(kneeX, kneeY, footTargetX, footTargetY, 12 * s, '#22d3ee'); // Shin/Foot

                    // Hands working on the foot
                    const handPhase = Math.sin(t * 3);
                    drawSegment(cx + 5 * s, headY + 10 * s, footTargetX + 5 * s, footTargetY - 5 * s, 8 * s, '#cbd5e1'); // Arm

                    // The Specific Spot Highlight (Metatarsal 1-2)
                    ctx.save();
                    ctx.translate(footTargetX, footTargetY);
                    ctx.rotate(handPhase * 0.1);
                    ctx.fillStyle = '#f43f5e';
                    ctx.beginPath(); ctx.arc(0, 0, 6 * s + (handPhase * 2 * s), 0, 2 * Math.PI); ctx.fill();
                    ctx.restore();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("METATARSAL SPLAY RELEASE", 20, 30);
                    if (handPhase > 0) drawForce(footTargetX, footTargetY - 20 * s, 0, 1, "PRESS & SPLAY");
                }

                else if (type === 'ql_straddle') {
                    // Wide stance, single arm kettlebell hinge
                    const hingePhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const hingeAngle = hingePhase * 45 * (Math.PI / 180);

                    const hipY = cy + 10 * s;
                    const footY = cy + 90 * s;

                    // Wide Stance Legs
                    drawSegment(cx - 30 * s, footY, cx - 5 * s, hipY, 16 * s, '#475569');
                    drawSegment(cx + 30 * s, footY, cx + 5 * s, hipY, 16 * s, '#475569');

                    // Hinging Torso
                    ctx.save();
                    ctx.translate(cx, hipY);
                    ctx.rotate(hingeAngle); // Forward lean

                    // Spine
                    drawSegment(0, 0, 0, -70 * s, 18 * s, '#22d3ee'); // Blue to show QL activation focus
                    // Head
                    ctx.beginPath(); ctx.arc(0, -85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // Arms
                    // Non-working arm (on hip/side)
                    drawSegment(10 * s, -60 * s, 20 * s, -30 * s, 8 * s, '#cbd5e1');

                    // Working Arm (Holding Kettlebell)
                    // Arm hangs straight down relative to world (gravity), so we counter-rotate slightly or simplify geometry
                    drawSegment(-10 * s, -60 * s, -10 * s, 10 * s, 8 * s, '#cbd5e1');

                    // Kettlebell
                    const kbX = -10 * s; const kbY = 15 * s;
                    ctx.fillStyle = '#1e293b';
                    ctx.beginPath(); ctx.arc(kbX, kbY + 10 * s, 12 * s, 0, 2 * Math.PI); ctx.fill(); // Bell
                    ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 3; ctx.strokeRect(kbX - 6 * s, kbY, 12 * s, 10 * s); // Handle

                    ctx.restore();

                    // Highlight the QL area
                    if (hingePhase > 0.3) {
                        ctx.save();
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = '#f59e0b'; // Orange warning/activation
                        // Draw rectangle at lower back on the opposite side of weight
                        ctx.translate(cx, hipY);
                        ctx.rotate(hingeAngle);
                        ctx.fillRect(5 * s, -30 * s, 10 * s, 20 * s);
                        ctx.restore();
                    }

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("QL STRADDLE HINGE", 20, 30);
                    drawForce(cx, hipY - 20 * s, 0, -1, "ANTI-ROTATION");
                }
                else if (type === 'hft_swing') {
                    const hipY = cy; const kneeY = cy + 60 * s; const footY = cy + 100 * s;
                    drawSegment(cx - 10 * s, hipY, cx - 10 * s, footY, 6 * s, '#475569');
                    const swingPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                    const swing = swingPhase * 30 * s;
                    const kneeBend = swingPhase * 5 * s; // Bend knee during swing
                    const kneeX = cx + 10 * s + swing / 2;
                    const kneePosY = kneeY + kneeBend;
                    ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(kneeX, kneePosY, cx + 10 * s + swing, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                    ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("TOE TENSION", cx - 10 * s, footY + 20 * s);
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HFT KINETIC SWING", 20, 30);
                    drawForce(cx + 10 * s + swing, footY, swing > 0 ? 1 : -1, 0, "MOMENTUM");
                    // Actionable cue: Toe tension highlight
                    if (swingPhase > 0.6) {
                        ctx.save(); ctx.globalAlpha = 0.7; ctx.fillStyle = '#22d3ee'; ctx.beginPath(); ctx.arc(cx + 10 * s + swing, footY, 5 * s, 0, 2 * Math.PI); ctx.fill();
                        ctx.restore();
                    }
                }
                else if (type === 'coiling_lunge' || type === 'head_coiling') {
                    // ELITE COILING LUNGE: Integrated Torsion + Head Over Foot
                    const lungePhase = easeInOutCubic((Math.sin(t * 1.2) + 1) / 2);
                    const coilPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);

                    const lungeDepth = lungePhase * 25 * s;
                    const coilTwist = coilPhase * 0.4;        // Rotation in radians
                    const coilSideBend = coilPhase * 15 * s;  // Lateral offset

                    const frontFootX = cx + 50 * s;
                    const backFootX = cx - 50 * s;
                    const hipY = cy + 20 * s + lungeDepth;
                    const footY = cy + 100 * s;

                    // Legs - stable
                    drawSegment(cx, hipY, frontFootX, footY, 16 * s, '#22d3ee');
                    drawSegment(cx, hipY, backFootX, footY, 16 * s, '#475569');

                    // Torso base point at hips
                    ctx.save();
                    ctx.translate(cx, hipY);

                    // Apply coil: twist + side bend
                    ctx.rotate(coilTwist);
                    const torsoMidX = coilSideBend * Math.sign(coilTwist);
                    const torsoTopY = -70 * s;

                    // Draw curved torso showing spiral
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(torsoMidX, torsoTopY / 2, 0, torsoTopY);
                    ctx.lineWidth = 18 * s;
                    ctx.strokeStyle = '#22d3ee';
                    ctx.stroke();

                    // Head - stays connected to top of torso, no drift
                    const headX = torsoMidX * 0.3;  // Slight follow-through but minimal
                    const headY = torsoTopY - 15 * s;
                    ctx.beginPath();
                    ctx.arc(headX, headY, 18 * s, 0, 2 * Math.PI);
                    ctx.fillStyle = '#cbd5e1';
                    ctx.fill();

                    ctx.restore(); // Back to world space

                    // Optional ball for head_coiling
                    if (type === 'head_coiling') {
                        drawEquipment('ball', cx + headX, hipY + headY - 35 * s, 0);
                    }

                    // Head Over Foot line (from crown to front foot)
                    ctx.save();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 6]);
                    ctx.beginPath();
                    ctx.moveTo(cx + headX, hipY + headY);
                    ctx.lineTo(frontFootX, footY);
                    ctx.stroke();
                    ctx.restore();

                    // Spiral torsion glow during peak coil
                    if (coilPhase > 0.6) {
                        ctx.save();
                        ctx.globalAlpha = 0.4 + Math.sin(t * 8) * 0.2;
                        ctx.strokeStyle = '#22d3ee';
                        ctx.lineWidth = 6 * s;
                        ctx.translate(cx, hipY - 30 * s);
                        ctx.beginPath();
                        for (let i = 1; i < 7; i++) {
                            const radius = i * 10 * s;
                            ctx.arc(0, 0, radius, 0, Math.PI * 1.5 * coilPhase);
                        }
                        ctx.stroke();
                        ctx.restore();
                    }

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText(type === 'head_coiling' ? "HEAD-LOADED COILING LUNGE" : "COILING LUNGE", 20, 20);

                    ctx.fillStyle = '#f59e0b';
                    ctx.font = `bold ${13 * s}px sans-serif`;
                    ctx.fillText("HEAD OVER FOOT", cx - 70, hipY + headY - 20);

                    ctx.fillStyle = '#22d3ee';
                    ctx.font = `bold ${12 * s}px sans-serif`;
                    ctx.fillText("TORSION LOADING = ELASTIC POWER", 20, 50);

                    if (coilPhase > 0.7) {
                        ctx.fillStyle = '#f97316';
                        ctx.font = `bold ${11 * s}px sans-serif`;
                        ctx.fillText("COIL → STORE → WHIP RELEASE", 20, h - 30);
                    }
                }
                else if (type === 'shoulder_release') {
                    const headX = cx, headY = cy - 60 * s, shY = cy - 40 * s, shL = cx - 25 * s, shR = cx + 25 * s;
                    drawSegment(cx, shY, cx, cy + 50 * s, 14 * s, '#475569'); drawSegment(shL, shY, shR, shY, 4 * s);
                    ctx.beginPath(); ctx.arc(headX, headY, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    drawMuscle(shR, shY, headX, headY + 10 * s, 15 * s, cycle > 0, "TISSUE RELEASE");
                    const ballRoll = Math.sin(t * 2) * 3 * s; // Rolling motion
                    drawEquipment('smash_ball', shR - 8 * s + ballRoll, shY - 5 * s, t * 2); // Rotate ball
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SOFT TISSUE MOBILIZATION", 20, 30);
                    // Actionable cue: Breathe label
                    ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("BREATHE DEEP", shR + 10 * s, shY);
                }
                else if (type === 'foot_roll') {
                    const footY = cy + 80 * s; const ankleX = cx;
                    // Draw Foot with arch curve
                    const heelX = ankleX - 20 * s; const toeX = ankleX + 20 * s;
                    const archPhase = Math.sin(t * 2) * 5 * s; // Arch flex
                    ctx.beginPath(); ctx.moveTo(heelX, footY); ctx.quadraticCurveTo(ankleX, footY - 10 * s - archPhase, toeX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();

                    // Draw Leg (Standing) with slight bend
                    const kneeY = cy + 20 * s; const hipY = cy - 40 * s;
                    const shinBend = Math.sin(t * 2) * 2 * s;
                    ctx.beginPath(); ctx.moveTo(ankleX, footY); ctx.quadraticCurveTo(ankleX + shinBend, (footY + kneeY) / 2, ankleX, kneeY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 10 * s; ctx.stroke(); // Shin
                    ctx.beginPath(); ctx.moveTo(ankleX, kneeY); ctx.quadraticCurveTo(ankleX - shinBend, (kneeY + hipY) / 2, ankleX, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke(); // Thigh

                    // Draw Torso/Head with slight lean
                    const headY = hipY - 50 * s;
                    const torsoLean = Math.sin(t * 2) * 3 * s;
                    ctx.beginPath(); ctx.moveTo(ankleX, hipY); ctx.quadraticCurveTo(ankleX + torsoLean / 2, (hipY + headY) / 2, ankleX + torsoLean, headY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 14 * s; ctx.stroke(); // Torso
                    ctx.beginPath(); ctx.arc(ankleX + torsoLean, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    const ballPosPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const ballPos = ballPosPhase * 20 * s - 10 * s;
                    drawEquipment('smash_ball', ankleX + ballPos, footY + 5 * s, t * 2); // Rolling ball
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("PLANTAR RELEASE", 20, 30);
                    // Actionable cue: Pressure point
                    ctx.save(); ctx.globalAlpha = 0.5 + Math.cos(t * 3) * 0.3; ctx.beginPath(); ctx.arc(ankleX + ballPos, footY + 5 * s, 8 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f43f5e'; ctx.fill();
                    ctx.restore();
                }
                else if (type === 'spinal_wave') {
                    const ballX = cx, ballY = cy + 40 * s; drawEquipment('swiss', ballX, ballY, 0);
                    const curvePhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const curve = 30 * s + (curvePhase * 30 * s); // Deeper curve
                    const bodyColor = curvePhase > 0.5 ? '#22d3ee' : '#475569';
                    ctx.beginPath(); ctx.moveTo(cx - 40 * s, cy + 40 * s); ctx.quadraticCurveTo(cx, cy - curve, cx + 40 * s, cy + 40 * s);
                    ctx.lineWidth = 14 * s; ctx.strokeStyle = bodyColor; ctx.lineCap = 'round'; ctx.stroke();
                    ctx.beginPath(); ctx.arc(cx - 45 * s, cy + 35 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill(); // Head
                    if (curvePhase > 0.5) { ctx.fillStyle = '#22c55e'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("SEGMENTATION", cx - 20 * s, cy - 60 * s); }
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SPINAL WAVE", 20, 30);
                    // Actionable cue: Wave direction
                    drawForce(cx, cy, curvePhase > 0.5 ? 0 : 0, curvePhase > 0.5 ? -1 : 1, "WAVE UP");
                }
                else if (type === 'hyperarch_hop') {
                    const hopPhase = easeInOutCubic(Math.abs(Math.sin(t * 3))); // Half speed for control
                    const hop = hopPhase * 15 * s;
                    const footY = cy + 80 * s - hop; const hipY = cy - 60 * s - hop;
                    const ankleFlex = hopPhase * 5 * s; // Ankle dorsiflexion
                    const leftAnkleY = footY - ankleFlex; const leftAnkleX = cx - 10 * s;
                    ctx.beginPath(); ctx.moveTo(cx - 10 * s, hipY); ctx.quadraticCurveTo(cx - 10 * s, (hipY + leftAnkleY) / 2, leftAnkleX, leftAnkleY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(leftAnkleX, leftAnkleY); ctx.lineTo(cx - 10 * s, footY); ctx.stroke(); // Foot
                    const rightAnkleY = footY + ankleFlex; const rightAnkleX = cx + 10 * s;
                    ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(cx + 10 * s, (hipY + rightAnkleY) / 2, rightAnkleX, rightAnkleY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(rightAnkleX, rightAnkleY); ctx.lineTo(cx + 10 * s, footY); ctx.stroke();
                    drawSegment(cx, hipY, cx, hipY - 60 * s, 14 * s, '#475569');
                    if (hop > 5 * s) { ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("LOCKED ANKLE", cx + 20 * s, footY); }
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("2-FOOT FASCIAL HOP", 20, 30);
                    drawForce(cx, footY, 0, -1, "RECOIL");
                    // Actionable cue: Heel suspend
                    ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(cx, footY - 5 * s, 3 * s, 0, 2 * Math.PI); ctx.fill(); // Heel point
                    ctx.restore();
                }
                else if (type === 'standing_pull') {
                    const hipY = cy + 20 * s; const footY = cy + 100 * s;
                    drawSegment(cx - 15 * s, hipY, cx - 20 * s, footY, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, hipY, cx + 20 * s, footY, 16 * s, '#475569');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#22d3ee'); // Torso
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    const pullPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                    const pull = pullPhase * 20 * s;
                    // Arms pulling back from high cable with elbow flare
                    const cableX = cx - 80 * s; const cableY = hipY - 100 * s;
                    const elbowX = cx - 30 * s - Math.abs(pull) + pullPhase * 5 * s; const handX = cx + 20 * s + pullPhase * 10 * s; const handY = hipY - 80 * s - pullPhase * 5 * s;

                    ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2 + pullPhase; ctx.beginPath(); ctx.moveTo(cableX, cableY); ctx.lineTo(handX, handY); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(cx, hipY - 60 * s); ctx.quadraticCurveTo(elbowX, hipY - 70 * s, handX, handY); ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 8 * s; ctx.stroke();
                    drawMuscle(cx, hipY - 60 * s, elbowX, hipY - 70 * s, 16 * s, true, "RHOMBOID", 'left');
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("CABLE FACE PULL", 20, 30);
                    // Actionable cue: Squeeze blades
                    if (pullPhase > 0.7) {
                        ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#22d3ee'; ctx.fillRect(cx - 20 * s, hipY - 70 * s, 40 * s, 20 * s);
                        ctx.fillStyle = '#000'; ctx.font = 'bold 8px sans-serif'; ctx.fillText("SQUEEZE", cx - 15 * s, hipY - 60 * s);
                        ctx.restore();
                    }
                }
                else if (type === 'inversion_hang') {
                    // ENHANCED: Dynamic hang with progression cues - hang, twist, leg swing/pull-up
                    const hangPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const hangDrop = hangPhase * 40 * s; // Drop from bar
                    const barY = cy - 100 * s;
                    drawEquipment('pullup_bar', cx, barY, 0);
                    const handY = barY + 10 * s; // Grip
                    const torsoY = handY + 20 * s + hangDrop;
                    const hipY = torsoY + 40 * s;
                    const kneeY = hipY + 30 * s + hangDrop * 0.5;
                    const footY = kneeY + 40 * s;
                    // Arms hanging straight
                    drawSegment(cx - 10 * s, handY, cx - 10 * s, torsoY, 8 * s, '#22d3ee');
                    drawSegment(cx + 10 * s, handY, cx + 10 * s, torsoY, 8 * s, '#22d3ee');
                    // Torso relaxed hang
                    ctx.beginPath(); ctx.moveTo(cx - 15 * s, torsoY); ctx.quadraticCurveTo(cx, torsoY + 10 * s, cx + 15 * s, torsoY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();
                    // Head
                    ctx.beginPath(); ctx.arc(cx, torsoY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    // Legs swinging for level 3 cue
                    const swingPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                    const legSwing = swingPhase * 20 * s - 10 * s;
                    const leftKneeX = cx - 15 * s + legSwing; const leftFootX = cx - 25 * s + legSwing * 1.5;
                    ctx.beginPath(); ctx.moveTo(cx - 10 * s, hipY); ctx.quadraticCurveTo(leftKneeX, kneeY, leftFootX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                    const rightKneeX = cx + 15 * s - legSwing; const rightFootX = cx + 25 * s - legSwing * 1.5;
                    ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(rightKneeX, kneeY, rightFootX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                    // Twist for level 2
                    if (hangPhase > 0.5) {
                        ctx.save(); ctx.translate(cx, torsoY); ctx.rotate(Math.sin(t * 2) * 0.2); ctx.beginPath(); ctx.arc(0, -15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill(); ctx.restore();
                        drawForce(cx, torsoY, Math.sin(t * 2) > 0 ? 1 : -1, 0, "TWIST");
                    }
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("INVERSION HANG & SWING", 20, 30);
                    // Actionable cue: Relax/ swing
                    drawForce(cx, footY, legSwing > 0 ? 1 : -1, 0, "LEG SWING");
                }
                else if (type === 'diaphragm_breath') {
                    const breathPhase = easeInOutCubic((Math.sin(t * 1.2) + 1) / 2);
                    const diaphragmDrop = breathPhase * 20 * s;
                    const bellyExpand = breathPhase * 25 * s;
                    const ribExpand = breathPhase * 15 * s;

                    const hipY = cy + 40 * s;
                    const chestY = cy - 20 * s;
                    const headY = cy - 80 * s;

                    // Body
                    drawSegment(cx - 15 * s, cy + 100 * s, cx, hipY, 16 * s, '#475569');
                    drawSegment(cx + 15 * s, cy + 100 * s, cx, hipY, 16 * s, '#475569');

                    // 360 expansion
                    ctx.save();
                    ctx.translate(cx, (hipY + chestY) / 2);
                    ctx.scale(1 + ribExpand / 50, 1 + bellyExpand / 80);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 30 * s, 50 * s, 0, 0, Math.PI * 2);
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 12 * s;
                    ctx.stroke();
                    ctx.restore();

                    // Diaphragm piston
                    ctx.beginPath();
                    ctx.ellipse(cx, hipY - diaphragmDrop, 25 * s, 10 * s, 0, 0, Math.PI);
                    ctx.fillStyle = '#22d3ee';
                    ctx.fill();

                    // Hydraulic glow
                    ctx.save();
                    ctx.globalAlpha = breathPhase * 0.6;
                    ctx.fillStyle = 'rgba(34,211,238,0.4)';
                    ctx.fillRect(cx - 20 * s, hipY - 40 * s, 40 * s, 80 * s);
                    ctx.restore();

                    // Head stable
                    ctx.beginPath(); ctx.arc(cx, headY, 18 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    // === CAPTIONS ===
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${14 * s}px sans-serif`;
                    ctx.fillText("DIAPHRAGMATIC BREATHING", 20, 20);

                    ctx.fillStyle = breathPhase > 0.5 ? '#f59e0b' : '#22d3ee';
                    ctx.font = `bold ${12 * s}px sans-serif`;
                    ctx.fillText(breathPhase > 0.5 ? "EXHALE — DIAPHRAGM RISES" : "INHALE — 360° EXPANSION", 20, 45);

                    ctx.fillStyle = '#22d3ee';
                    ctx.font = `bold ${10 * s}px sans-serif`;
                    ctx.fillText("HYDRAULIC CORE PRESSURE", 20, h - 40);
                }
                else if (type === 'contra_pull') {
                    // ENHANCED: Explosive snap with quick recoil, hip drive
                    const pullPhase = easeInOutCubic((Math.sin(t * 4) + 1) / 2); // Faster for snap
                    const pull = pullPhase * 40 * s;
                    const recoil = Math.sin(t * 8) * 5 * s * pullPhase; // Quick snap back
                    const hipY = cy + 20 * s; const footY = cy + 100 * s;
                    // Contralateral stance: Right hand pull, left foot back
                    drawSegment(cx + 10 * s, footY, cx + 5 * s, hipY, 16 * s, '#475569');
                    drawSegment(cx - 20 * s, footY, cx - 10 * s, hipY, 16 * s, '#22d3ee'); // Emphasize back leg
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    // Band from anchor to hand
                    const anchorX = cx - 60 * s; const anchorY = hipY - 50 * s;
                    const handX = cx + pull - recoil; const handY = hipY - 50 * s;
                    ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 4 + pullPhase * 2; ctx.beginPath(); ctx.moveTo(anchorX, anchorY); ctx.lineTo(handX, handY); ctx.stroke();
                    // Arm explosive pull with elbow bend
                    const elbowX = (cx + handX) / 2 + Math.sin(t * 6) * 3 * s; const elbowY = handY + 5 * s * pullPhase;
                    ctx.beginPath(); ctx.moveTo(cx, hipY - 50 * s); ctx.quadraticCurveTo(elbowX, elbowY, handX, handY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                    drawMuscle(cx, hipY - 50 * s, handX, handY, 16 * s, pullPhase > 0.7, "SNAP", 'right');
                    // Hip drive cue
                    if (pullPhase > 0.8) {
                        ctx.save(); ctx.globalAlpha = 0.7 + Math.sin(t * 10) * 0.3; drawForce(cx, hipY, 1, 0, "HIP DRIVE"); ctx.restore();
                    }
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("EXPLOSIVE CONTRA SNAP", 20, 30);
                    drawForce(handX, handY, -1, 0, "RECOIL");
                }
                else if (type === 'royal_coil') {
                    const phase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                    const coil = phase * 25 * s;
                    const hipY = cy + 20 * s;
                    const frontFootX = cx + 50 * s;
                    const backFootX = cx - 50 * s;
                    const headX = frontFootX + coil * 0.3;
                    const headY = hipY - 80 * s + coil * 0.2;

                    // Legs
                    drawSegment(cx, hipY, frontFootX, cy + 100 * s, 16 * s, '#22d3ee');
                    drawSegment(cx, hipY, backFootX, cy + 100 * s, 16 * s, '#475569');

                    // Torso coil
                    ctx.save();
                    ctx.translate(cx, hipY);
                    ctx.rotate(coil * 0.04);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(10 * s * Math.sin(t * 2), -40 * s, 0, -80 * s);
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 18 * s;
                    ctx.stroke();
                    ctx.restore();

                    // Head
                    ctx.beginPath(); ctx.arc(headX, headY, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ROYAL COIL PULSE", 20, 30);
                    drawForce(headX, headY, coil > 0 ? 1 : -1, 0, "TORSION LOAD");
                }
                else if (type === 'catapult_bounce') {
                    const bouncePhase = Math.abs(Math.sin(t * 6));
                    const bounce = bouncePhase * 12 * s;
                    const hipY = cy + 20 * s - bounce;
                    const footY = cy + 100 * s;

                    drawSegment(cx - 15 * s, footY, cx, hipY, 16 * s, '#22d3ee');
                    drawSegment(cx + 15 * s, footY, cx, hipY, 16 * s, '#22d3ee');
                    drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ELASTIC CATAPULT BOUNCE", 20, 30);
                    if (bouncePhase > 0.7) drawForce(cx, footY, 0, -1, "RECOIL");
                }
                else if (type === 'foot_flow') {
                    const phase = Math.sin(t * 3);
                    const pronation = phase * 10 * s;
                    const footY = cy + 80 * s;
                    const heelX = cx - 20 * s;
                    const toeX = cx + 30 * s + pronation;

                    ctx.beginPath();
                    ctx.moveTo(heelX, footY);
                    ctx.quadraticCurveTo(cx, footY - 15 * s - Math.abs(pronation), toeX, footY);
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 8 * s;
                    ctx.stroke();

                    drawSegment(cx, cy + 20 * s, cx, cy - 60 * s, 16 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, cy - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("PRONATION-SUPINATION FLOW", 20, 30);
                    drawForce(toeX, footY, phase > 0 ? 1 : -1, 0, "FOOT OPPOSITION");
                }
                else if (type === 'spiral_flow') {
                    const phase = Math.sin(t * 2);
                    const twist = phase * 30 * s;
                    const hipY = cy + 20 * s;

                    ctx.save();
                    ctx.translate(cx, hipY);
                    ctx.rotate(twist * 0.02);
                    drawSegment(-20 * s, 0, 20 * s, -80 * s, 16 * s, '#22d3ee');
                    ctx.restore();

                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SPIRAL LINE FLOW", 20, 30);
                }
                else if (type === 'spinal_wave_seg') {
                    const wave = Math.sin(t * 2) * 30 * s;
                    ctx.beginPath();
                    ctx.moveTo(cx - 40 * s, cy + 40 * s);
                    ctx.quadraticCurveTo(cx, cy - wave, cx + 40 * s, cy + 40 * s);
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 16 * s;
                    ctx.stroke();

                    ctx.beginPath(); ctx.arc(cx - 40 * s, cy + 35 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SPINAL WAVE SEGMENTATION", 20, 30);
                }
                else if (type === 'pos_sling_snap') {
                    const snapPhase = easeInOutCubic(Math.abs(Math.sin(t * 4)));
                    const snap = snapPhase * 40 * s;
                    const hipY = cy + 20 * s;

                    // Contralateral pull
                    drawSegment(cx + 20 * s, hipY - 50 * s, cx + snap, hipY - 50 * s, 10 * s, '#22d3ee');
                    drawSegment(cx - 20 * s, cy + 100 * s, cx - 10 * s, hipY, 16 * s, '#22d3ee');

                    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("POSTERIOR OBLIQUE SLING SNAP", 20, 30);
                    if (snapPhase > 0.7) drawForce(cx + snap, hipY - 50 * s, 1, 0, "SNAP");
                }
                else {
                    // FALLBACK
                    const pulsePhase = easeInOutCubic(Math.abs(Math.sin(t * 4)));
                    const pulse = pulsePhase * 5 * s;
                    drawSegment(cx, cy - 50 * s - pulse, cx, cy + 50 * s, 4 * s, '#475569');
                    ctx.beginPath(); ctx.arc(cx, cy - 60 * s - pulse, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText(type.toUpperCase().replace(/_/g, ' '), 20, 30);
                }
            } catch (e) { }
            if (playing) animationRef.current = requestAnimationFrame(loop);
        };
        loop();
        return () => {
            observer.disconnect(); // Stop listening to resize
            cancelAnimationFrame(animationRef.current);
        };
    }, [type, playing]);
    return <canvas ref={ref} className="relative w-full h-full bg-slate-950 rounded-lg shadow-inner overflow-hidden" />;
};


const getGrade = (score) => {
  if (typeof score !== 'number' || isNaN(score)) return 'C';
  if (score >= 95) return 'A+';
  if (score >= 90) return 'A';
  if (score >= 85) return 'A-';
  if (score >= 80) return 'B+';
  if (score >= 75) return 'B';
  if (score >= 70) return 'B-';
  if (score >= 65) return 'C+';
  if (score >= 60) return 'C';
  if (score >= 55) return 'C-';
  if (score >= 50) return 'D';
  return 'F';
};

// --- NEW: Progress Streak Component (Retention Booster) ---
const StreakTracker = ({ streakDays, onReset }) => (
    <div className="bg-gradient-to-r from-orange-500/20 to-red-500/20 border border-orange-500/30 rounded-lg p-4 mb-4">
        <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-2">
                <div className="text-orange-400 streak-flame"><Icons.Flame /></div>
                <span className="text-sm font-bold text-orange-300">Current Streak</span>
            </div>
            {streakDays > 0 && <button onClick={onReset} className="text-xs text-orange-400 hover:text-orange-300">Reset</button>}
        </div>
        <div className="text-2xl font-black text-orange-400">{streakDays}</div>
        <div className="text-xs text-orange-300 mt-1">Days Consecutive Scans</div>
        {streakDays >= 7 && <div className="text-xs text-emerald-400 mt-1 font-bold"> On Fire! Bonus Protocol Unlocked</div>}
    </div>
);

// --- NEW: Goal Tracker Component (Retention Booster) ---
const GoalTracker = ({ currentScore, targetScore, progress, onUpdateGoal, forecast }) => {
    const completion = (currentScore / targetScore) * 100;
    const onTrack = currentScore >= targetScore * 0.8;
    const pred = forecast?.predicted || currentScore + 10; // Fallback

    return (
        <div className="bg-slate-900/50 border border-slate-700 rounded-lg p-4 mb-4">
            <div className="flex justify-between items-center mb-2">
                <span className="text-sm font-bold text-slate-300">Goal: {targetScore}% Integrity</span>
                <button onClick={onUpdateGoal} className="text-xs text-cyan-400 hover:text-cyan-300">Edit</button>
            </div>
            <div className="w-full bg-slate-800 rounded-full h-2 overflow-hidden mb-2">
                <div className="goal-progress" style={{ width: `${completion}%` }} />
            </div>
            <div className="text-xs text-emerald-400 font-bold flex items-center gap-1">
                <Icons.ArrowUp /> Projected: {pred}% in {progress.duration} days {onTrack ? '🎉' : '💪 Keep Going!'}
            </div>
            <div className="text-xs text-slate-400 flex justify-between">
                <span>Current: {currentScore}%</span>
                <span>{Math.round(completion)}% to Goal</span>
            </div>
        </div>
    );
};

// ─────────────────────────────────────────────────────────────────────
// THE UPGRADED ELITE COACH — V84.0 KINETIC VOICE ENGINE
// ─────────────────────────────────────────────────────────────────────
const ProgramPlayer = ({ program, onClose, onFeedback }) => {
    const [step, setStep] = useState(0);
    const [playing, setPlaying] = useState(true);
    const [timeLeft, setTimeLeft] = useState(program[0]?.duration || 60);
    const [voiceOn, setVoiceOn] = useState(false);
    const [musicOn, setMusicOn] = useState(false);
    const [rated, setRated] = useState(false);
    const [completed, setCompleted] = useState(false);
    const [currentExercise, setCurrentExercise] = useState(program[0]);

    const lastSpokenId = useRef(null);
    const sessionCueIndex = useRef({});  // remembers which cue we used this session

    const toggleVoice = () => {
        const next = !voiceOn;
        if (!next) window.speechSynthesis.cancel();
        setVoiceOn(next);
    };

    useEffect(() => {
        if (!musicOn) return;
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const master = ctx.createGain(); master.gain.value = 0.05; master.connect(ctx.destination);
        const osc432 = ctx.createOscillator(); osc432.type = 'sine'; osc432.frequency.value = 432;
        const osc528 = ctx.createOscillator(); osc528.type = 'triangle'; osc528.frequency.value = 528;
        const g = ctx.createGain(); g.gain.value = 0.26;
        const f = ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 820;
        osc432.connect(master);
        osc528.connect(g).connect(f).connect(master);
        osc432.start(); osc528.start();
        return () => { osc432.stop(); osc528.stop(); ctx.close(); };
    }, [musicOn]);

    // --- THE NEW VOICE LOGIC ---
    useEffect(() => {
        if (!voiceOn || !currentExercise || currentExercise.id === lastSpokenId.current) return;
        lastSpokenId.current = currentExercise.id;

        window.speechSynthesis.cancel();

        const voices = window.speechSynthesis.getVoices();
        // Prioritize deep/authoritative voices
        const best = voices.find(v =>
            /Daniel|Alex|Fred|Google.*male|Microsoft.*David/i.test(v.name)
        ) || voices.find(v => v.lang.includes('en')) || voices[0];

        const speak = (text) => {
            const u = new SpeechSynthesisUtterance(text);
            u.voice = best;
            u.rate = 0.95; // Slightly slower for clarity
            u.pitch = 0.9; // Slightly deeper for authority
            u.volume = 1.0;
            window.speechSynthesis.speak(u);
        };

        // *** THE UPGRADED DATABASE ***
        const masterCoach = {
            // --- POSTURE & NECK ---
            meta_release: [
                "Find the groove between the big toe and the second toe.",
                "Press deep. This might be uncomfortable. Breathe into it.",
                "Soften the tissues. Allow the toes to splay apart. This releases the entire foot."
            ],
            ql_straddle: [
                "Wide stance. Hinge from the hips, do not round the back.",
                "As you lower the weight, fight the rotation. Keep your chest square to the floor.",
                "This is purely for the SI joint and QL. Feel the opposite side of your lower back fire to keep you stable."
            ],
            head_loading: [
                "Lengthen the spine. Imagine the ball is floating, and you are reaching up to keep contact.",
                "Chin tucked. Don't let the ribs flare. Breathe into the back of your neck. The deeper you breathe, the more you activate your core",
                "Axial decompression. Feel the multifidus muscles waking up along your spine."
            ],
            head_loading_march: [
                "Maintain the column. Head over hips over heels. No wobble.",
                "As you lift the knee, drive the crown of your head higher.",
                "Stabilize. The weight is teaching your spine how to resist gravity."
            ],

            // --- FEET & GAIT ---
            plantar_release: [
                "Find the trigger point near the heel. Apply pressure and breathe.",
                "Your foot is a sensory organ. Wake it up. Roll the inner arch.",
                "Melt the fascia. When this releases, your hamstring and glute will fire instantly."
            ],
            towel_curl: [
                "Spread the toes wide, then grip. Dominate the floor.",
                "Don't just curl the toes, pull the arch up. Build the windlass mechanism.",
                "This is intrinsic foot strength. It's the foundation of all athletic power."
            ],
            hyperarch: [
                "Heels suspended. Do not let them touch the ground. You are a spring.",
                "Pop. Pop. Pop. Minimal ground contact time. Stiffness is speed.",
                "Load the Achilles. Recoil through the glute. Stay elastic."
            ],

            // --- KNEES & LEGS ---
            split_squat: [
                "Full range. Let that front knee travel well past the toe. Restore the VMO.",
                "Back leg straight. Squeeze the glute on the trailing leg to open the hip flexor.",
                "Hamstring covers the calf at the bottom. Pressure proves the pipe."
            ],
            atg_split_squat: [
                "Drive the knee forward. Keep the heel flat if you can, or elevate it.",
                "This is structural integrity. You are bulletproofing the knee joint.",
                "Long range strength. Fight for depth."
            ],

            // --- FASCIA & BOUNCE ---
            body_bounce: [
                "Loose and rhythmic. Shake out the tension. Let the shoulders drop.",
                "Shift the hips left and right. Feel the lateral fascial line engaging.",
                "Lymphatic flush. Bounce on the balls of the feet. No muscle, just elasticity."
            ],
            body_wave: [
                "Initiate from the tailbone. Ripple up through the spine.",
                "Segmental motion. Vertebra by vertebra. Unlock the thoracic cage.",
                "Flow like water. Remove the rigid blocks in your back."
            ],

            // --- ROTATION & CORE ---
            trunk_twist: [
                "Hips and thoracic spine move together. Protect the lumbar.",
                "Let the arms swing dead weight. Centrifugal force drives the blood flow.",
                "Spiral line activation. Wring out the tension in the obliques."
            ],
            pallof: [
                "Resist rotation. Shoulders down. Ribs locked to pelvis.",
                "Anti-rotation is the prerequisite for power. Do not let the band win.",
                "Breathe behind the shield. Brace the core, but keep breathing."
            ],
            landmine_rotation: [
                "Pivot the foot! All power comes from the hip drive.",
                "Arms stay straight. The bar moves because your hips rotate.",
                "Transfer force from the ground, through the core, into the bar."
            ],
            band_twist: [
                "Explosive hips. Snap the rotation. Control the return.",
                "Load the posterior oblique sling. Lat to opposite glute.",
                "Power comes from the coil. Twist and drive."
            ],
            coiling: [
                "Side bend and rotate. Head over the load-bearing foot.",
                "Load the spring. Feel the tension wrap around your torso.",
                "The Royal Coil. Spiraling energy through the core. Maximize torsion."
            ],

            // --- SHOULDERS & ARMS ---
            arm_raise: [
                "Thumbs up, ribs down. Do not arch your back to get the arms up.",
                "True shoulder flexion. Reach for the ceiling, create space in the joint.",
                "Open the deep front arm line. Breathe into the armpits."
            ],
            alt_arm_raise: [
                "Contralateral rhythm. This is the gait cycle. Left arm, right leg.",
                "Reach high. Reciprocate. One side lengthens, the other shortens.",
                "Sync with your breath. Restore the cross-crawl pattern."
            ],
            chest_opener: [
                "Dynamic opening. Squeeze the shoulder blades together at the back.",
                "Open the front line. Undo the sitting posture.",
                "Expand the ribcage. Big inhale as you open."
            ],
            trap_release: [
                "Lean into the wall. Find the knot in the upper trap.",
                "Pin the tissue, then move the arm. Floss the nerve.",
                "Drop the shoulder. Stop wearing your shoulders as earrings."
            ],
            standing_pull: [
                "Retract the scapula first. Pull with the back, not the arms.",
                "Squeeze the mid-back. Lower trapezius activation.",
                "Postural reset. Pull the shoulders back and down."
            ],
            contra_pull: [
                "Step back and pull. Connect the right hand to the left foot.",
                "Feel the X pattern across your back. That is the posterior oblique sling.",
                "Tension through the torso. Do not let the spine twist."
            ],

            // --- POWER & INTEGRATION ---
            med_ball_power: [
                "Reach high, slam hard! Use your whole bodyweight.",
                "Flex at the hips. Drive the ball through the floor.",
                "Explosive flexion. Turn potential energy into kinetic power."
            ],
            spinal_wave: [
                "Roll down, chin to chest. Roll up, stacking the spine.",
                "Articulate every joint. If a section feels stuck, spend time there.",
                "Hydrate the discs. Movement is the pump."
            ],
            diaphragm_breath: [
                "Breathe into the belly, not the chest. 360 degree expansion.",
                "Intra-abdominal pressure. This is your internal weight belt.",
                "Calm the nervous system. Slow, nasal inhale. Long exhale."
            ],
            inversion_hang: [
                "Let gravity do the work. create space between the vertebrae.",
                "Relax the lower back. Let the hips heavy.",
                "Decompression. Undo the compressive forces of the day."
            ]
        };

        const cues = masterCoach[currentExercise.id] || [
            "Focus on quality movement.",
            "Control the range of motion.",
            "Breathe rhythmically."
        ];

        // Cycle through cues based on session history
        const index = (sessionCueIndex.current[currentExercise.id] || 0) % cues.length;
        sessionCueIndex.current[currentExercise.id] = index + 1;
        const line = cues[index];

        if (step === 0) {
            speak("Beginning Protocol. Let's go.");
            setTimeout(() => speak(line), 2500);
        } else {
            speak(line);
        }

    }, [voiceOn, currentExercise, step]);

    useEffect(() => { lastSpokenId.current = null; sessionCueIndex.current = {}; }, [step]);

    // Standard logic
    useEffect(() => {
        setCurrentExercise(program[step]);
        setRated(false);
        if (program[step]) setTimeLeft(program[step].duration);
        setPlaying(true);
    }, [step, program]);

    useEffect(() => {
        let i;
        if (playing && timeLeft > 0 && !completed)
            i = setInterval(() => setTimeLeft(t => t - 1), 1000);
        else if (timeLeft === 0) setPlaying(false);
        return () => clearInterval(i);
    }, [playing, timeLeft, completed]);

    const changeLevel = (dir) => {
        const idx = currentExercise.currentLevelIdx + dir;
        if (idx >= 0 && idx < currentExercise.allLevels.length) {
            setCurrentExercise({ ...currentExercise, ...currentExercise.allLevels[idx], currentLevelIdx: idx });
        }
    };

    const submitFeedback = (rating) => {
        onFeedback(currentExercise.id, currentExercise.currentLevelIdx, rating);
        setRated(true);
        setTimeout(() => {
            if (step < program.length - 1) setStep(s => s + 1);
            else { setCompleted(true); setPlaying(false); }
        }, 900);
    };

    const openVideo = () => {
        const q = currentExercise.videoSearch?.startsWith('http')
            ? currentExercise.videoSearch
            : `https://www.youtube.com/results?search_query=${encodeURIComponent(currentExercise.videoSearch || currentExercise.name)}`;
        window.open(q, '_blank');
    };

    if (completed) {
        return (
            <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center p-4 backdrop-blur-md no-print animate-popIn">
                <div className="bg-slate-900 w-full max-w-lg rounded-2xl border border-slate-700 shadow-2xl p-8 flex flex-col items-center text-center">
                    <div className="w-20 h-20 bg-emerald-500/20 rounded-full flex items-center justify-center mb-6">
                        <svg className="w-10 h-10 text-emerald-400" fill="none" stroke="currentColor" strokeWidth="3" viewBox="0 0 24 24"><path d="M20 6 9 17l-5-5" /></svg>
                    </div>
                    <h2 className="text-3xl font-black text-white mb-2">SESSION COMPLETE</h2>
                    <p className="text-slate-400 mb-8">Your body just changed forever.</p>
                    <button onClick={onClose} className="btn-primary w-full">RETURN</button>
                </div>
            </div>
        );
    }

    return (
        <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center p-4 backdrop-blur-md no-print">
            <div className="bg-slate-900 w-full max-w-6xl h-[90vh] rounded-2xl border border-slate-700 shadow-2xl flex flex-col md:flex-row overflow-hidden">
                {/* Canvas */}
                <div className="w-full md:w-2/3 bg-black flex flex-col relative border-r border-slate-800">
                    <div className="absolute top-4 left-4 z-10 pointer-events-none">
                        <span className="text-[10px] font-bold px-2 py-1 rounded border bg-slate-800 text-white border-slate-600">
                            {currentExercise.baseTitle ? `FLOW STEP ${currentExercise.currentLevelIdx + 1}` : `LEVEL ${currentExercise.currentLevelIdx + 1}`}
                        </span>                        </div>
                    <div className="absolute top-4 right-4 z-10 flex gap-2 pointer-events-auto">
                        <button onClick={toggleVoice} className={`px-4 py-1.5 text-[10px] font-bold rounded flex items-center gap-2 shadow-lg transition-all ${voiceOn ? 'bg-cyan-600 text-white' : 'bg-slate-800 text-slate-400 border border-slate-600'}`}>
                            <Icons.Speaker /> COACH {voiceOn ? 'ON' : 'OFF'}
                        </button>
                        <button onClick={() => setMusicOn(m => !m)} className={`px-4 py-1.5 text-[10px] font-bold rounded flex items-center gap-2 shadow-lg transition-all ${musicOn ? 'bg-green-600 text-white' : 'bg-slate-800 text-slate-400 border border-slate-600'}`}>
                            <Icons.Music /> 432·528Hz
                        </button>
                        <button onClick={openVideo} className="px-3 py-1 bg-red-600 hover:bg-red-500 text-white text-[10px] font-bold rounded flex items-center gap-2 shadow-lg shadow-red-900/50 transition-all">
                            <Icons.Video /> TUTORIAL
                        </button>
                    </div>
                    <div className="flex-1 relative">
                        <KineticCanvas type={currentExercise.demoType} playing={playing} />
                        <div className="absolute bottom-8 left-1/2 -translate-x-1/2 text-5xl font-black text-white font-mono pointer-events-none">
                            {Math.floor(timeLeft / 60)}:{(timeLeft % 60).toString().padStart(2, '0')}
                        </div>
                    </div>
                    <div className="h-16 bg-slate-950 border-t border-slate-800 flex items-center px-6 justify-between">
                        <button onClick={() => setPlaying(p => !p)} className="text-white hover:text-cyan-400">
                            {playing ? <Icons.Pause /> : <Icons.Play />}
                        </button>
                        <div className="flex-1 flex items-center justify-center gap-8">
    <button 
        onClick={() => setStep(Math.max(0, step - 1))}
        disabled={step === 0}
        className="px-8 py-4 bg-slate-800 hover:bg-slate-700 disabled:opacity-50 rounded-xl font-black text-xl uppercase tracking-wider text-white transition-all shadow-lg"
    >
        ← PREV
    </button>

    <div className="text-4xl font-black text-cyan-400">
        {step + 1} / {program.length}
    </div>

    <button 
        onClick={() => setStep(Math.min(program.length - 1, step + 1))}
        disabled={step === program.length - 1}
        className="px-8 py-4 bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 disabled:opacity-50 rounded-xl font-black text-xl uppercase tracking-wider text-white transition-all shadow-lg shadow-cyan-900/50"
    >
        NEXT →
    </button>
</div>
                    </div>
                </div>

                {/* RIGHT PANEL */}
                <div className="w-full md:w-1/3 bg-slate-950 flex flex-col p-6 overflow-y-auto">
                    <div className="flex justify-between items-center mb-6"><h2 className="text-lg font-bold text-white flex gap-2"><Icons.List /> Protocol V84.0</h2><button onClick={onClose} className="text-slate-400 hover:text-white"><Icons.Close /></button></div>
                    <div>
                        <div className="mb-6">
    <h3 className="text-2xl font-black text-white mb-3 text-center">
        {currentExercise.baseTitle || currentExercise.name}
    </h3>
    {program.length > 1 && (
        <p className="text-center text-lg text-cyan-400 font-bold">
            Step {step + 1} of {program.length}
        </p>
    )}
                            <p className="text-sm text-cyan-400 mb-4">
                                {currentExercise.baseTitle && `Step ${step + 1} of ${program.length}`}
                            </p>                            </div>
                        <div className="flex items-center gap-2 mb-4">
                            <button onClick={() => changeLevel(-1)} disabled={currentExercise.currentLevelIdx === 0} className="text-[10px] bg-slate-800 hover:bg-slate-700 disabled:opacity-30 px-2 py-1 rounded border border-slate-700 text-slate-300 flex items-center gap-1"><Icons.ArrowDown /> REGRESS</button>
                            <div className="flex gap-1">
                                {currentExercise.allLevels.map((_, idx) => (
                                    <div key={idx} className={`w-2 h-2 rounded-full ${idx === currentExercise.currentLevelIdx ? 'bg-cyan-400' : 'bg-slate-800'}`}></div>
                                ))}
                            </div>
                            <button onClick={() => changeLevel(1)} disabled={currentExercise.currentLevelIdx === currentExercise.allLevels.length - 1} className="text-[10px] bg-slate-800 hover:bg-slate-700 disabled:opacity-30 px-2 py-1 rounded border border-slate-700 text-slate-300 flex items-center gap-1">PROGRESS <Icons.ArrowUp /></button>
                        </div>
                        <div className="flex flex-wrap gap-2 mb-4">
                            <span className="text-xs bg-slate-800 px-2 py-1 rounded text-cyan-400 border border-slate-700">{currentExercise.duration}s</span>
                            <span className="text-xs bg-emerald-900/30 px-2 py-1 rounded text-emerald-400 border border-emerald-900/50">{currentExercise.reason}</span>
                        </div>
                        <p className="text-sm text-slate-400 leading-relaxed mb-4">{currentExercise.desc}</p>
                        <h4 className="text-xs font-bold text-slate-500 uppercase mb-2">Technique</h4>
                        <ul className="space-y-2 mb-6">{currentExercise.steps.map((s, i) => <li key={i} className="text-sm text-slate-300 flex gap-2"><span className="text-cyan-500 font-bold">{i + 1}.</span>{s}</li>)}</ul>
                        <div className="bg-slate-900 border border-slate-800 p-4 rounded-xl mb-4">
                            <h4 className="text-[10px] font-bold text-slate-500 uppercase mb-3 text-center">How was this set?</h4>
                            {rated ? (
                                <div className="text-center text-xs text-emerald-400 font-bold py-2 animate-pulse">Feedback Saved</div>
                            ) : (
                                <div className="flex gap-2">
                                    <button onClick={() => submitFeedback('easy')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-emerald-900/30 border border-slate-700 hover:border-emerald-500/50 text-[10px] font-bold text-slate-300 hover:text-emerald-400 transition-all">TOO EASY</button>
                                    <button onClick={() => submitFeedback('good')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-blue-900/30 border border-slate-700 hover:border-blue-500/50 text-[10px] font-bold text-slate-300 hover:text-blue-400 transition-all">JUST RIGHT</button>
                                    <button onClick={() => submitFeedback('hard')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-red-900/30 border border-slate-700 hover:border-red-500/50 text-[10px] font-bold text-slate-300 hover:text-red-400 transition-all">TOO HARD</button>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="mt-auto pt-6 border-t border-slate-800">
                        <h4 className="text-xs font-bold text-slate-500 uppercase mb-3">Session Roadmap</h4>
                        <div className="space-y-2">{program.map((p, idx) => <div key={idx} onClick={() => setStep(idx)} className={`text-xs p-2 rounded cursor-pointer flex justify-between ${idx === step ? 'bg-cyan-900/20 text-cyan-400' : 'text-slate-500'}`}><span>{idx + 1}. {p.baseTitle}</span>
                            {p.reason === "Universal Primer" && <span className="text-[9px] font-bold text-emerald-400 bg-emerald-900/30 px-1 rounded ml-2">UNIVERSAL</span>}
                            {p.reason.includes("Fixes Knee") && <span className="text-[9px] font-bold text-red-400 bg-red-900/30 px-1 rounded ml-2">KNEE RELIEF</span>}
                            {p.reason.includes("Spinal") && <span className="text-[9px] font-bold text-yellow-400 bg-yellow-900/30 px-1 rounded ml-2">BACK RELIEF</span>}
                            <span className="opacity-50 ml-auto">LVL {p.currentLevelIdx + 1}</span></div>)}</div>
			    
                    </div>
                </div>
            </div>
        </div>
    );
};
const TrendGraph = ({ history }) => {
    if (history.length < 2) {
        return (
            <div className="mb-6 p-4 bg-slate-900/30 rounded text-center text-xs text-slate-500">
                Scan again to see trend
            </div>
        );
    }

    // FIX 1: Limit to strictly the last 20 items to prevent overcrowding
    const recentHistory = history.slice(0, 20).reverse(); // Reverse so oldest is left, newest is right
    const scores = recentHistory.map(h => h.score);

    const h = 50, w = 280;
    const points = scores.map((s, i) => {
        const x = (i / (scores.length - 1)) * w;
        const y = h - (s / 100) * h;
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="mb-6">
            <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">
                Recovery Trend (Last {scores.length})
            </div>
            <div className="h-[50px] w-full bg-slate-900/30 rounded relative overflow-hidden">
                <svg className="w-full h-full" viewBox={`0 0 ${w} ${h}`} preserveAspectRatio="none">
                    <polyline points={points} fill="none" stroke="#22d3ee" strokeWidth="2" vectorEffect="non-scaling-stroke" />
                    {scores.map((s, i) => (
                        <circle 
                            key={i} 
                            cx={(i / (scores.length - 1)) * w} 
                            cy={h - (s / 100) * h} 
                            r="3" 
                            fill="#0f172a" 
                            stroke="#22d3ee" 
                            strokeWidth="2" 
                        />
                    ))}
                </svg>
            </div>
        </div>
    );
};

const FascialLineTrends = ({ history }) => {
    if (history.length < 2) return null;
    const lines = [
        { key: 'head', name: 'Superficial Back Line', color: 'from-purple-500 to-pink-500' },
        { key: 'shoulders', name: 'Deep Front Arm Line', color: 'from-blue-500 to-cyan-500' },
        { key: 'spine', name: 'Deep Front Line', color: 'from-emerald-500 to-teal-500' },
        { key: 'hip', name: 'Lateral Line', color: 'from-orange-500 to-amber-500' },
        { key: 'gait', name: 'Spiral Line', color: 'from-red-500 to-rose-500' }
    ];
    const latest = history[0];
    const previous = history[1];
    return (
        <div className="mt-8 animate-popIn">
            <h3 className="text-lg font-black text-cyan-400 uppercase tracking-widest text-center mb-6">
                Fascial Line Trends
            </h3>
            <div className="space-y-4">
                {lines.map((line, idx) => {
                    const current = latest[line.key]?.val || 0;
                    const prev = previous[line.key]?.val || 0;
                    const delta = current - prev;
                    const isPositive = delta >= 0;
                    // Mini sparkline data
                    const data = history.slice(0, 10).reverse().map(h => h[line.key]?.val || 50);
                    const max = Math.max(...data, 100);
                    const min = Math.min(...data, 0);
                    const range = max - min || 1;
                    const points = data.map((v, i) => {
    const x = (i / (data.length - 1)) * 100;
    const y = 100 - ((v - min) / range) * 100;
    return `${x},${y}`;
}).join(' ');
                    
                    // Unique ID for gradients to prevent conflict
                    const gradId = `gradient-${line.key}`;

                    return (
                        <div key={line.key} className="bg-slate-900/70 border border-slate-700 rounded-2xl p-5 hover:border-cyan-500/50 transition-all">
                            <div className="flex justify-between items-start mb-3">
                                <div>
                                    <div className="text-sm font-bold text-white">{line.name}</div>
                                    <div className="text-xs text-slate-400 mt-1">
                                        Current: <span className="font-mono text-cyan-300">{current}%</span>
                                    </div>
                                </div>
                                <div className={`text-2xl font-black ${isPositive ? 'text-emerald-400' : 'text-red-400'}`}>
                                    {isPositive ? '+' : ''}{delta.toFixed(1)}
                                </div>
                            </div>
                            <div className="relative h-16 bg-slate-950/50 rounded-xl overflow-hidden">
                                <svg className="absolute inset-0 w-full h-full" preserveAspectRatio="none">
                                    <defs>
                                        <linearGradient id={gradId} x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" stopColor="#22d3ee" stopOpacity="0.8" />
                                            <stop offset="100%" stopColor="#a78bfa" stopOpacity="0.8" />
                                        </linearGradient>
                                    </defs>
                                    <polyline
                                        fill="none"
                                        stroke={`url(#${gradId})`}
                                        strokeWidth="3"
                                        points={points}
                                        vectorEffect="non-scaling-stroke"
                                        className="drop-shadow-lg"
                                    />
                                </svg>
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

const ReaderMode = ({ item, onClose }) => {
    // Force scroll to top on mount
    const scrollRef = useRef(null);
    useEffect(() => {
        if (scrollRef.current) scrollRef.current.scrollTop = 0;
    }, []);

    return (
        <div ref={scrollRef} className="fixed inset-0 bg-slate-950 z-50 overflow-y-auto no-print flex justify-center">
            <div className="w-full max-w-3xl bg-slate-900 min-h-screen border-x border-slate-800 shadow-2xl relative">
                <button onClick={onClose} className="fixed top-6 right-6 p-3 bg-slate-800 hover:bg-slate-700 rounded-full text-white shadow-lg z-50"><Icons.Close /></button>
                <div className={`h-64 w-full bg-gradient-to-br ${item.color} flex items-end p-8`}>
                    <div>
                        <div className="text-xs font-bold text-white/80 uppercase tracking-widest mb-2">MASTERCLASS</div>
                        <h1 className="text-4xl font-black text-white tracking-tighter mb-2">{item.title}</h1>
                        <p className="text-lg text-white/90 font-medium">{item.subtitle}</p>
                    </div>
                </div>
                <div className="p-8 md:p-12 space-y-8">
                    <div className="flex gap-4 border-b border-slate-800 pb-8">
                        <div className="w-12 h-12 rounded-full bg-slate-800 flex items-center justify-center text-xl">🎓</div>
                        <div>
                            <div className="text-sm font-bold text-white"> {item.author}</div>
                        </div>
                    </div>
                    <div className="prose prose-invert max-w-none">
                        <p className="text-lg text-slate-300 leading-relaxed font-light border-l-4 border-cyan-500 pl-4 mb-8">{item.desc}</p>
                        <h3 className="text-xl font-bold text-white mb-4">Core Principles</h3>
                        {item.sections && item.sections.map((sec, i) => (
                            <div key={i} className="mb-8">
                                <h4 className="text-lg font-bold text-cyan-400 mb-2">{sec.head}</h4>
                                <p className="text-slate-300 leading-relaxed">{sec.body}</p>
                            </div>
                        ))}
                        <h3 className="text-xl font-bold text-white mb-4">Key Terminology</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {item.key_terms && item.key_terms.map((term, i) => (
                                <div key={i} className="bg-slate-950 p-4 rounded border border-slate-800 text-sm text-cyan-400 font-mono">{term}</div>
                            ))}
                        </div>
                    </div>
                    <div className="pt-12 text-center">
                        <button onClick={onClose} className="btn-primary w-auto inline-flex">RETURN TO DASHBOARD</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

const KnowledgeBase = ({ onOpen }) => (
    <div className="p-8 space-y-6 pb-24">
        <div className="border-b border-slate-800 pb-4 mb-6">
            <h2 className="text-2xl font-black text-white tracking-tighter mb-2">MASTERING <span className="text-cyan-500">MOVEMENT</span></h2>
        </div>
        <div className="grid grid-cols-1 gap-4">
            {ACADEMY.map((item, i) => (
                <div key={i} onClick={() => onOpen(item)} className="bg-slate-900/50 border border-slate-700 rounded-xl p-6 hover:border-cyan-500/50 transition-all group cursor-pointer hover:bg-slate-800/50">
                    <div className={`h-1 w-10 rounded-full bg-gradient-to-r ${item.color} mb-4`}></div>
                    <h3 className="text-lg font-bold text-white mb-1 group-hover:text-cyan-400 transition-colors">{item.title}</h3>
                    <div className="text-xs font-bold text-slate-400 uppercase mb-3">{item.subtitle}</div>
                    <p className="text-sm text-slate-400 leading-relaxed line-clamp-2">{item.desc}</p>
                    <div className="mt-4 text-xs font-bold text-cyan-600 flex items-center gap-1">READ MASTERCLASS <Icons.Video /></div>
                </div>
            ))}
        </div>
    </div>
);

// --- NEW: Goal Setter Modal ---
const GoalSetter = ({ currentGoal, onSave, onClose }) => {
    const [target, setTarget] = useState(currentGoal.target || 80);
    const [duration, setDuration] = useState(currentGoal.duration || 30);
    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
            <div className="bg-slate-900 w-full max-w-md rounded-xl border border-slate-700 p-6">
                <h3 className="text-lg font-bold text-white mb-4">Set Your Goal</h3>
                <div className="space-y-4">
                    <div>
                        <label className="text-xs text-slate-400 mb-1 block">Target Score (%)</label>
                        <input type="range" min="50" max="100" value={target} onChange={(e) => setTarget(e.target.value)} className="w-full" />
                        <div className="text-sm text-white">{target}%</div>
                    </div>
                    <div>
                        <label className="text-xs text-slate-400 mb-1 block">Duration (Days)</label>
                        <input type="number" min="7" max="90" value={duration} onChange={(e) => setDuration(e.target.value)} className="w-full bg-slate-800 border border-slate-700 rounded px-3 py-2 text-white text-sm" />
                    </div>
                    <div className="flex gap-2 pt-4">
                        <button onClick={onClose} className="flex-1 py-2 bg-slate-800 hover:bg-slate-700 rounded text-white text-sm">Cancel</button>
                        <button onClick={() => onSave({ target, duration })} className="flex-1 py-2 bg-cyan-600 hover:bg-cyan-500 rounded text-white text-sm font-bold">Save Goal</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

// --- NEW: Share Report Component ---
const ShareReport = ({ audit, symptoms, onClose }) => {
    return (
        <div className="fixed inset-0 bg-black/90 z-50 flex items-center justify-center p-4 backdrop-blur-md">
            <div className="bg-gradient-to-br from-slate-900 to-slate-950 p-1 rounded-2xl border border-cyan-500/50 shadow-[0_0_50px_rgba(34,211,238,0.2)]">
                {/* THE CARD TO SCREENSHOT */}
                <div className="bg-slate-900 rounded-xl p-8 w-full max-w-sm text-center relative overflow-hidden">
                    
                    {/* Background Glow */}
                    <div className="absolute top-0 left-0 w-full h-32 bg-gradient-to-b from-cyan-900/20 to-transparent pointer-events-none"></div>

                    <div className="relative z-10">
    <div className="text-xs font-black text-cyan-400 tracking-[0.3em] mb-6">BIOMECHANICS REPORT</div>
    
    {/* VIRAL HOOK: SPLIT SCORE VIEW */}
<div className="flex justify-center items-center gap-6 mb-8">
    <div className="text-center">
        <div className="text-5xl font-black text-white">
            {audit.score}<span className="text-2xl">%</span>
        </div>
        <div className="text-sm text-slate-400 uppercase">Structural Integrity</div>
        
        <div className="text-4xl font-black text-red-400 mt-4">
            {audit.bioAge} <span className="text-lg">yrs</span>
        </div>
        <div className="text-sm text-slate-400 uppercase">Biological Age</div>
        
        <div className="w-32 mx-auto my-6">
            <BioAvatar audit={audit} symptoms={symptoms} />
        </div>
        
        <div className="w-24 h-24 bg-white rounded-xl mx-auto mb-4 flex items-center justify-center">
            <div className="text-black font-black text-center text-xs">QR to App</div>
        </div>
    </div>
</div>

    {/* Reuse the BioAvatar Component! */}

                        <div className="grid grid-cols-2 gap-4 text-xs font-bold text-slate-500 mb-6">
                            <div className="bg-slate-800/50 p-2 rounded">HEAD: {audit.head.grade}</div>
                            <div className="bg-slate-800/50 p-2 rounded">SPINE: {audit.spine.grade}</div>
                            <div className="bg-slate-800/50 p-2 rounded">HIPS: {audit.hip.grade}</div>
                            <div className="bg-slate-800/50 p-2 rounded">GAIT: {audit.gait.grade}</div>
                        </div>

                        <div className="text-[10px] text-slate-600 mb-4">Analyzed by Bio-Metric Pro Neural Core</div>
                        
                        <button onClick={onClose} className="w-full py-3 bg-white text-black font-black rounded-lg hover:scale-105 transition-transform">
                            DONE / SCREENSHOT THIS
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};

// --- NEW: CLINICAL BIOMECHANICS DASHBOARD (REAL PHYSICS) ---
const ClinicalDashboard = ({ audit, onClose }) => {
    // 1. Calculate REAL metrics based on the audit data
    // "Force Leak" is the inverse of the score. If score is 80%, 20% of force is leaking.
    const forceLeak = 100 - audit.score; 
    
    // Asymmetry is derived from the difference between specific metrics if available, 
    // or estimated from the difference between hip/shoulder grades vs neutral.
    // (In a real scenario, we'd pull raw L/R keypoint deltas, but we'll infer from the grades here)
    const asymmetryRisk = (audit.shoulders.val < 80 || audit.hip.val < 80) ? "High" : "Low";
    
    // "Axial Compression" estimates how much gravity is crushing the spine vs flowing through it
    // Forward head (low head score) = High shear force
    const shearForce = Math.max(0, 100 - audit.head.val); 

    // Metrics for the dashboard
    const metrics = [
        { label: "Kinetic Efficiency", val: audit.score, desc: "Force transfer through skeletal stack", color: "bg-emerald-500" },
        { label: "Axial Shear Load", val: shearForce, desc: "Non-vertical spinal loading (Risk Factor)", color: "bg-red-500" },
        { label: "Pelvic Stability", val: audit.hip.val, desc: "Base of support integrity", color: "bg-blue-500" },
        { label: "Gait Recoil Potential", val: audit.gait.val, desc: "Elastic energy storage capacity", color: "bg-amber-500" }
    ];

    return (
        <div className="fixed inset-0 bg-black/95 z-[90] flex items-center justify-center p-4 backdrop-blur-xl animate-popIn">
            <div className="bg-slate-900 w-full max-w-5xl h-[85vh] rounded-2xl border border-slate-700 shadow-2xl flex flex-col overflow-hidden">
                
                {/* HEADER */}
                <div className="p-6 border-b border-slate-800 flex justify-between items-center bg-slate-950">
                    <div className="flex items-center gap-4">
                        <div className="w-3 h-12 bg-cyan-500 rounded-sm"></div>
                        <div>
                            <h2 className="text-2xl font-black text-white uppercase tracking-tighter">Clinical Kinetics</h2>
                            <p className="text-xs text-slate-400 font-mono">VECTOR ANALYSIS V85.0</p>
                        </div>
                    </div>
                    <button onClick={onClose} className="p-2 hover:bg-slate-800 rounded-full text-slate-400 hover:text-white transition-colors">
                        <Icons.Close />
                    </button>
                </div>

                {/* MAIN CONTENT GRID */}
                <div className="flex-1 overflow-y-auto p-8 grid grid-cols-1 lg:grid-cols-2 gap-8">
                    
                    {/* LEFT: VISUALIZATIONS */}
                    <div className="space-y-8">
                        
                        {/* 1. FORCE VECTOR STACK */}
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl relative overflow-hidden">
                            <h3 className="text-sm font-bold text-slate-400 uppercase mb-6 flex items-center gap-2">
                                <Icons.Layers /> Structural Load Distribution
                            </h3>
                            <div className="space-y-4">
                                {metrics.map((m, i) => (
                                    <div key={i}>
                                        <div className="flex justify-between text-xs mb-1">
                                            <span className="text-slate-300 font-bold">{m.label}</span>
                                            <span className="text-slate-400 font-mono">{m.val}%</span>
                                        </div>
                                        <div className="w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                                            <div className={`h-full ${m.color}`} style={{ width: `${m.val}%` }}></div>
                                        </div>
                                        <div className="text-[10px] text-slate-500 mt-1">{m.desc}</div>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* 2. ASYMMETRY WARNING */}
                        <div className={`p-6 rounded-xl border ${asymmetryRisk === 'High' ? 'bg-red-900/10 border-red-500/30' : 'bg-emerald-900/10 border-emerald-500/30'}`}>
                            <div className="flex items-start gap-4">
                                <div className={`mt-1 p-2 rounded-lg ${asymmetryRisk === 'High' ? 'bg-red-500/20 text-red-400' : 'bg-emerald-500/20 text-emerald-400'}`}>
                                    <Icons.Target />
                                </div>
                                <div>
                                    <h4 className={`text-lg font-bold ${asymmetryRisk === 'High' ? 'text-red-400' : 'text-emerald-400'}`}>
                                        {asymmetryRisk === 'High' ? 'Significant Asymmetry Detected' : 'Symmetrical Loading Optimized'}
                                    </h4>
                                    <p className="text-sm text-slate-400 mt-1 leading-relaxed">
                                        {asymmetryRisk === 'High' 
                                            ? "Your scan indicates uneven loading between Left and Right hemispheres. This creates rotational torque on the spine (Shear Force)." 
                                            : "Your skeletal stacking is effectively neutralizing gravity. Load is distributed evenly across the kinetic chain."}
                                    </p>
                                </div>
                            </div>
                        </div>

                    </div>

                    {/* RIGHT: TEXT ANALYSIS */}
                    <div className="space-y-6">
                        <h3 className="text-sm font-bold text-slate-400 uppercase mb-2">Biomechanics Report</h3>
                        
                        <div className="bg-slate-950 p-6 rounded-xl border border-slate-800 font-mono text-xs text-slate-300 leading-loose">
                            <p className="mb-4"><span className="text-cyan-500">>> ANALYZING PLUMB LINE...</span></p>
                            <p>
                                HEAD POSITION: <span className={audit.head.grade === 'A' ? 'text-emerald-400' : 'text-red-400'}>{audit.head.grade === 'A' ? 'NEUTRAL' : 'ANTERIOR SHIFT'}</span><br/>
                                Impact: {audit.head.grade === 'A' ? 'Minimal cervical load.' : 'Increased leverage load on C7/T1 junction.'}
                            </p>
                            <div className="h-px bg-slate-800 my-3"></div>
                            <p>
                                PELVIC TILT: <span className={audit.hip.grade === 'A' ? 'text-emerald-400' : 'text-red-400'}>{audit.hip.grade === 'A' ? 'NEUTRAL' : 'DETECTED'}</span><br/>
                                Impact: {audit.hip.grade === 'A' ? 'Optimal force transfer.' : 'Disrupted gluteal firing patterns (Amoritzation Phase).'}
                            </p>
                            <div className="h-px bg-slate-800 my-3"></div>
                            <p>
                                ELASTICITY: <span className={audit.gait.grade === 'A' ? 'text-emerald-400' : 'text-red-400'}>{audit.gait.grade === 'A' ? 'HIGH' : 'LOW'}</span><br/>
                                Impact: {audit.gait.grade === 'A' ? 'Efficient energy recycling.' : 'High metabolic cost of movement.'}
                            </p>
                        </div>

                        <div className="bg-cyan-900/10 p-6 rounded-xl border border-cyan-500/20">
                            <h4 className="text-cyan-400 font-bold mb-2">Corrective Engineering</h4>
                            <p className="text-sm text-slate-400 mb-4">
                                Based on your vector analysis, we need to increase <strong>{audit.spine.grade === 'F' ? 'Posterior Chain Tension' : 'Anterior Core Stiffness'}</strong>.
                            </p>
                            <button onClick={onClose} className="w-full py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg transition-all">
                                APPLY PROTOCOL
                            </button>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    );
};

// --- CAMERA COMPONENT ---
const CameraCapture = ({ onCapture, onClose }) => {
    const videoRef = useRef(null);
    const [timer, setTimer] = useState(null);
    const [cameraError, setCameraError] = useState(false);

    useEffect(() => {
        let stream = null;
        navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
            stream = s;
            if (videoRef.current) videoRef.current.srcObject = stream;
        }).catch(err => { console.error(err); onClose(); });
        return () => { if (stream) stream.getTracks().forEach(t => t.stop()); };
    }, []);

    const trigger = () => setTimer(3);

    useEffect(() => {
        if (timer === null) return;
        if (timer > 0) setTimeout(() => setTimer(timer - 1), 1000);
        else {
            const cvs = document.createElement('canvas');
            cvs.width = videoRef.current.videoWidth;
            cvs.height = videoRef.current.videoHeight;
            // Flip horizontally to match mirror view
            const ctx = cvs.getContext('2d');
            ctx.translate(cvs.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(videoRef.current, 0, 0);
            onCapture(cvs.toDataURL('image/jpeg'));
        }
    }, [timer]);

    return (
        <div className="fixed inset-0 bg-black/95 z-[60] flex flex-col items-center justify-center p-4 animate-popIn">
            <div className="relative w-full max-w-lg bg-slate-900 border border-slate-700 rounded-2xl overflow-hidden shadow-2xl">
                <video ref={videoRef} autoPlay playsInline className="w-full bg-black transform scale-x-[-1]" />
                {timer > 0 && <div className="absolute inset-0 flex items-center justify-center bg-black/40 text-9xl font-black text-white animate-ping backdrop-blur-sm">{timer}</div>}
                <div className="absolute bottom-6 left-0 right-0 flex justify-center gap-4">
                    <button onClick={onClose} className="px-6 py-2 bg-slate-800 text-slate-300 rounded-full font-bold border border-slate-600 hover:bg-slate-700 transition-all">CANCEL</button>
                    <button onClick={trigger} className="px-6 py-2 bg-cyan-600 text-white rounded-full font-bold shadow-lg flex items-center gap-2 hover:bg-cyan-500 transition-all"><Icons.Camera /> {timer ? 'CAPTURING...' : 'CAPTURE (3s)'}</button>
                </div>
            </div>
        </div>
    );
};

const App = () => {

    const viewportRef = useRef(null);

    const [uploads, setUploads] = useState({ front: null, side: null, back: null });
    const [liveScore, setLiveScore] = useState(null);
    const [lastAlertScore, setLastAlertScore] = useState(100);
    const [isModelLoading, setIsModelLoading] = useState(false);
    const [cameraActive, setCameraActive] = useState(null);
    const [system, setSystem] = useState({ detector: null });
    // --- APP STATE ---
    // Ensure we start with null or valid data
    const [audit, setAudit] = useState(null);
    const [history, setHistory] = useState([]);
    const [status, setStatus] = useState({ analyzing: false, logs: [], analyzed: false });
    const [ready, setReady] = useState(false); // Added ready state
    

    const [symptoms, setSymptoms] = useState([]);
    const [userPrefs, setUserPrefs] = useState({ lowImpact: false, noJumps: false, noEquipment: false });
const [tab, setTab] = useState('dashboard');

useEffect(() => {
        if (viewportRef.current) {
            viewportRef.current.scrollTo({ top: 0, behavior: 'smooth' });
        }
    }, [tab]);

    const [showReader, setShowReader] = useState(null);
    const [rightPanelTab, setRightPanelTab] = useState('twin');
    const [activeProgram, setActiveProgram] = useState(null);
    const [generatedRoutine, setGeneratedRoutine] = useState(null); // The waiting area
    const [showClinical, setShowClinical] = useState(false);
    const [chatHistory, setChatHistory] = useState(() => {
    try {
        const saved = localStorage.getItem('bio_chat_memory');
        return saved ? JSON.parse(saved) : [];
    } catch (e) { return []; }
});


    // --- INIT ---
    useEffect(() => {
        // SANITIZATION ROUTINE
        try {
            const saved = localStorage.getItem('biometric_data_v99'); // BUMP TO V99
            if (saved) {
                const data = JSON.parse(saved);

                // DATA CLEANSE V99: Extreme Prejudice
                if (data.history && Array.isArray(data.history)) {
                    const saneHistory = data.history.filter(h => {
                        if (!h || typeof h.score !== 'number' || isNaN(h.score)) return false;
                        // Ensure all parts exist and are numbers
                        const parts = ['head', 'shoulders', 'spine', 'hip', 'gait'];
                        return parts.every(p => h[p] && typeof h[p].val === 'number' && !isNaN(h[p].val));
                    });

                    if (saneHistory.length > 0) {
                        setHistory(saneHistory);
                        setAudit(saneHistory[0]);
                        setReady(true);
                        setTab('dashboard');
                    }
                }

                if (data.symptoms) setSymptoms(data.symptoms);
                if (data.prefs) setUserPrefs(data.prefs);
            }
        } catch (e) {
            console.error("Data Load Failed - Resetting", e);
            localStorage.removeItem('biometric_data_v99');
        }

        // FORCE RESET ANALYZING STATE
        setStatus(s => ({ ...s, analyzing: false, logs: [] }));
        document.body.classList.remove('analyzing');
        document.querySelectorAll('.upload-slot').forEach(s => s.classList.remove('scanning'));

    }, []);

    // Save State (Debounced)
    useEffect(() => {
        if (!ready && history.length === 0) return;
        const data = { history, symptoms, prefs: userPrefs };
        localStorage.setItem('biometric_data_v99', JSON.stringify(data));
    }, [history, symptoms, userPrefs, ready]);



    // DAILY HABIT STATE
    const [dailyRoutine, setDailyRoutine] = useState([]);
    const [achievements, setAchievements] = useState([
        { id: 1, name: "First Step", desc: "Complete your first scan", unlocked: false, icon: <Icons.Check /> },
        { id: 2, name: "Consistency King", desc: "Scan 3 days in a row", unlocked: false, icon: <Icons.History /> },
        { id: 3, name: "Elite Structure", desc: "Achieve a Score > 80", unlocked: false, icon: <Icons.Award /> }
    ]);

    // Exercise History to ensure variety
    const [exerciseHistory, setExerciseHistory] = useState({});

    // Equipment Filter
    const [useEquipment, setUseEquipment] = useState(true);

    // NEW: Retention States
    const [streakDays, setStreakDays] = useState(0);
    const [currentGoal, setCurrentGoal] = useState({ target: 80, duration: 30, startDate: new Date().toDateString() });
    const [showGoalSetter, setShowGoalSetter] = useState(false);
    const [showShare, setShowShare] = useState(false);
    const [beforeImage, setBeforeImage] = useState(null); // First ever scan
    const [afterImage, setAfterImage] = useState(null);  // Latest scan
    const [showProtocolButton, setShowProtocolButton] = useState(false);
    const [currentTheme, setCurrentTheme] = useState('power');  // Weekly theme: power, recovery, mobility
    const [postAnalysisMode, setPostAnalysisMode] = useState(false);
    const [isModelReady, setIsModelReady] = useState(false);
    const [liveMode, setLiveMode] = useState(false);
    const [cameraError, setCameraError] = useState(false);
    const [liveKeypoints, setLiveKeypoints] = useState(null);
    const [sideKeypoints, setSideKeypoints] = useState(null);
    const liveVideoRef = useRef(null);
    const liveCanvasRef = useRef(null);
    const [liveCountdown, setLiveCountdown] = useState(null);

    const debouncedRunAnalysis = React.useCallback(() => {
        if (status.analyzing) return; // Ignore duplicates
        requestAnimationFrame(runAnalysis); // Queue after UI paints (smooth!)
    }, [status.analyzing]);
    const uploadRefs = { front: useRef(null), side: useRef(null), back: useRef(null) };

    const addLog = (msg) => setStatus(prev => ({ ...prev, logs: [`> ${msg}`, ...prev.logs].slice(0, 4) }));

    // NEW: Handle Exercise Feedback (ENHANCED for goodStreaks)
    const handleFeedback = (exerciseId, levelIdx, rating) => {
        const newHistory = { ...exerciseHistory };
        const existing = newHistory[exerciseId] || {};
        let goodStreaks = existing.goodStreaks || 0;
        if (rating === 'good') {
            goodStreaks = Math.min(3, goodStreaks + 1);
        } else {
            goodStreaks = 0;
        }
        newHistory[exerciseId] = {
            ...existing,
            lastUsed: new Date().toDateString(),
            lastLevel: levelIdx,
            lastRating: rating,
            goodStreaks
        };

    // LIVE MODE: Start webcam and run continuous detection
    useEffect(() => {
        if (!liveMode || !system.detector) return;

        let stream = null;
        let animationFrameId = null;

        const startCamera = async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "user" }
                });
                if (liveVideoRef.current) {
                    liveVideoRef.current.srcObject = stream;
                }

                const detectLoop = async () => {
  if (!liveVideoRef.current || liveVideoRef.current.readyState < 2) {
    animationFrameId = requestAnimationFrame(detectLoop);
    return;
  }

  const results = await system.detector.detectForVideo(
    liveVideoRef.current,
    performance.now()
  );

  if (results.landmarks && results.landmarks[0]) {
    const keypoints = results.landmarks[0];

    // LOWERED THRESHOLD + MORE LENIENT COUNT
    const requiredIndices = [11,12,23,24,25,26]; // shoulders, hips, knees
    const visibleCount = requiredIndices.filter(i => 
      keypoints[i] && (keypoints[i].visibility || keypoints[i].score || 0) > 0.5
    ).length;

    if (visibleCount >= 4) {  // Reduced from 6 → 4 (much more forgiving)
      // Good enough pose detected
      if (liveCountdown === null) {
        setLiveCountdown(5);
        addLog("Good pose locked — capturing in 5s");
      }

      const score = calculateLivePostureScore(keypoints);
      setLiveScore(score);

      // Gentle real-time feedback
      if (score < 70 && lastAlertScore >= 80) {
        if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
        SFX.play(300, 'sine', 0.4);
        setLastAlertScore(score);
      } else if (score >= 80) {
        setLastAlertScore(100);
      }

      setLiveKeypoints(keypoints);
      drawLiveSkeleton(keypoints);

    } else {
      // Not enough keypoints — helpful feedback
      setLiveScore(null);
      setLiveCountdown(null);
      setLiveKeypoints(null);
    }
  } else {
    setLiveScore(null);
    setLiveCountdown(null);
    setLiveKeypoints(null);
  }

  animationFrameId = requestAnimationFrame(detectLoop);
};

                detectLoop();
            } catch (err) {
                console.error("Camera access denied", err);
                addLog("Camera access blocked — allow in browser");
                setLiveMode(false);
            }
        };

        startCamera();

        return () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (stream) stream.getTracks().forEach(track => track.stop());
            setLiveKeypoints(null);
        };
    }, [liveMode, system.detector]);

// ← PASTE THE NEW useEffect RIGHT HERE
useEffect(() => {
    if (liveCountdown === null || liveCountdown === 0) return;

    if (liveCountdown > 0) {
        const timer = setTimeout(() => setLiveCountdown(liveCountdown - 1), 1000);
        return () => clearTimeout(timer);
    } else {
        // Countdown finished → capture front view and analyze
        const video = liveVideoRef.current;
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1); // Un-mirror for correct capture
        ctx.drawImage(video, 0, 0);

        const dataUrl = canvas.toDataURL('image/jpeg');
        setUploads(prev => ({ ...prev, front: { url: dataUrl, analyzed: false } }));

        // Auto-run analysis
        setLiveMode(false);
        runAnalysis();

        setLiveCountdown(null);
    }
}, [liveCountdown]);

    // Helper: Draw skeleton on live canvas
    const drawLiveSkeleton = (keypoints) => {
        const canvas = liveCanvasRef.current;
        if (!canvas || !liveVideoRef.current) return;

        const video = liveVideoRef.current;
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Scale keypoints to canvas size
        const scaled = keypoints.map(kp => ({
            x: kp.x * canvas.width,
            y: kp.y * canvas.height
        }));

        // Connections (same as your static version)
        const connections = [
            [11,12],[11,13],[13,15],[12,14],[14,16], // arms
            [11,23],[12,24],[23,25],[24,26],         // torso to hips/legs
            [23,24]                                  // hips
        ];

        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';

        connections.forEach(([a, b]) => {
            if (keypoints[a]?.visibility > 0.3 && keypoints[b]?.visibility > 0.3) {
                ctx.beginPath();
                ctx.moveTo(scaled[a].x, scaled[a].y);
                ctx.lineTo(scaled[b].x, scaled[b].y);
                ctx.stroke();
            }
        });

        // Keypoint dots
        scaled.forEach((kp, i) => {
            if (keypoints[i]?.visibility > 0.5) {
                ctx.fillStyle = '#0f172a';
                ctx.beginPath();
                ctx.arc(kp.x, kp.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#22d3ee';
                ctx.beginPath();
                ctx.arc(kp.x, kp.y, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    };
        setExerciseHistory(newHistory);
        // Visual feedback log
        const rateMsg = rating === 'easy' ? "Marked Easy (Progressing next time)" : rating === 'hard' ? "Marked Hard (Regressing next time)" : "Marked Good (Maintaining)";
        addLog(rateMsg);
    };

    // NEW HELPER: Quick trend delta (improvement over last 3 sessions)
    const getTrendDelta = (history, bodyPart) => {
        if (history.length < 2) return 0;
        const recent = history.slice(0, 3).map(h => h[bodyPart].val).reverse(); // Last 3 vals (lower val = worse)
        return (recent[0] - recent[recent.length - 1]) / recent.length; // Positive = improving
    };

    useEffect(() => {
        const init = async () => {
            // Check if MediaPipe is ready. If not, wait 500ms and try again.
            const mp = window.mpVision || window.vision;

            if (!mp || !mp.FilesetResolver || !mp.PoseLandmarker) {
                addLog("Awaiting Neural Assets...");
                setTimeout(init, 500);
                return;
            }

            addLog("Warming AI Engine...");
            try {
                // Use the 'mp' reference we found above
                const vision = await mp.FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );

                const poseLandmarker = await mp.PoseLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task`,
                        delegate: "GPU"
                    },
                    runningMode: "IMAGE",
                    numPoses: 1
                });

                setSystem(prev => ({ ...prev, detector: poseLandmarker }));
                setIsModelReady(true);
                addLog("Neural Engine Online. Ready for analysis");
            } catch (err) {
                console.error("Init Error:", err);
                addLog("Hardware Acceleration Error. Retrying...");
                setTimeout(init, 2000);
            }

            // Load saved data logic remains the same below...
            // V82 Legacy Load Removed - Using V99 Protocol Only
        };
        init();
    }, []);

    // NEW: Streak Calculation
    const calculateStreak = (hist) => {
        if (hist.length === 0) return;
        const dates = hist.map(h => new Date(h.date).toDateString()).sort();
        let streak = 0;
        const today = new Date().toDateString();
        if (dates[dates.length - 1] === today) streak = 1;
        for (let i = dates.length - 2; i >= 0; i--) {
            const prevDate = new Date(dates[i]);
            const nextDate = new Date(dates[i + 1]);
            if (nextDate - prevDate === 86400000) { // 24 hours
                streak++;
            } else break;
        }
        setStreakDays(streak);
    };

    // NEW: Save Goal
    const saveGoal = (goal) => {
        setCurrentGoal(goal);
        localStorage.setItem('bio_goal', JSON.stringify(goal));
        setShowGoalSetter(false);
        addLog(`Goal Set: ${goal.target}% in ${goal.duration} days`);
    };

    useEffect(() => {
        if (chatHistory.length > 0) localStorage.setItem('bio_chat_memory', JSON.stringify(chatHistory));
    }, [chatHistory]);

    // Save exercise history whenever it changes
    useEffect(() => {
        if (Object.keys(exerciseHistory).length > 0) localStorage.setItem('bio_exercise_history', JSON.stringify(exerciseHistory));
    }, [exerciseHistory]);

    // NEW: Reset Streak (For Testing/Edge Cases)
    const resetStreak = () => setStreakDays(0);

    const updateBadges = (hist) => {
        setAchievements(prev => prev.map(badge => {
            if (badge.id === 1 && hist.length > 0) return { ...badge, unlocked: true };
            if (badge.id === 2 && hist.length >= 3) return { ...badge, unlocked: true };
            if (badge.id === 3 && hist.some(h => h.score > 80)) return { ...badge, unlocked: true };
            return { ...badge, unlocked: false };
        }));
    };
// --- FIX: TURN BUTTON BLUE WHEN PHOTO UPLOADED ---
    useEffect(() => {
        // As soon as the AI is ready AND a photo exists -> Enable Button
        const aiReady = system.detector != null;
        const photoUploaded = uploads.front || uploads.side || uploads.back;
        
        if (aiReady && photoUploaded) {
            setReady(true);
        }
    }, [system.detector, uploads]);
    const handleFile = (e, view) => {
        if (e.target.files[0]) {
            setUploads(prev => ({ ...prev, [view]: { url: URL.createObjectURL(e.target.files[0]), analyzed: false } }));
            addLog(`${view.toUpperCase()} View Loaded`);
        }
    };

    const toggleSymptom = (sym) => {
        setSymptoms(prev => prev.includes(sym) ? prev.filter(s => s !== sym) : [...prev, sym]);
    };

    const toggleDailyTask = (index) => {
        const newRoutine = [...dailyRoutine];
        newRoutine[index].completed = !newRoutine[index].completed;
        setDailyRoutine(newRoutine);
    };

    // --- ULTIMATE OFFLINE BIO-COACH (MAX SOPHISTICATION, NO GEMINI) ---
const handleChat = async (input) => {
    // =========================================================================
    // 🧠 LAYER 1: COGNITIVE PRE-PROCESSING & STATE AWARENESS
    // =========================================================================
    
    setChatHistory(prev => [...prev, { sender: 'user', text: input }]);
    
    // Artificial "Cognitive Load" delay for realism
    await new Promise(r => setTimeout(r, 800 + Math.random() * 400)); 

    // 1.1 Fuzzy Match Utility
    const fuzzyMatch = (source, target) => {
        const a = source.toLowerCase();
        const b = target.toLowerCase();
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;
        const matrix = [];
        for (let i = 0; i <= b.length; i++) { matrix[i] = [i]; }
        for (let j = 0; j <= a.length; j++) { matrix[0][j] = j; }
        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
                }
            }
        }
        return 1 - (matrix[b.length][a.length] / Math.max(a.length, b.length));
    };

    // 1.2 Context Engines
    const getTimeContext = () => {
        const h = new Date().getHours();
        if (h < 11) return { phase: "Morning", focus: "Activation", icon: "🌅", advice: "Hydrate your fascia immediately." };
        if (h < 17) return { phase: "Day", focus: "Postural Reset", icon: "☀️", advice: "Break the sitting cycle." };
        return { phase: "Evening", focus: "Decompression", icon: "🌙", advice: "Switch to parasympathetic breathing." };
    };

    const detectSentiment = (str) => {
        if (["pain", "hurt", "dying", "agony", "injury"].some(w => str.includes(w))) return "distress";
        if (["ready", "let's go", "pumped", "start"].some(w => str.includes(w))) return "motivated";
        return "neutral";
    };

    // =========================================================================
    // 🧬 LAYER 2: KNOWLEDGE GRAPH & PREDICTIVE MODELING
    // =========================================================================

    const anatomyMatrix = {
        "suboccipital": "head", "scm": "head", "jaw": "head", "tmj": "head", "migraine": "head", "neck": "head",
        "pec": "shoulders", "rotator": "shoulders", "trap": "shoulders", "shoulder": "shoulders",
        "lats": "spine", "erector": "spine", "disk": "spine", "sciatica": "spine", "back": "spine", "lumbar": "spine",
        "psoas": "hip", "glute": "hip", "piriformis": "hip", "groin": "hip", "hip": "hip",
        "plantar": "gait", "shin": "gait", "ankle": "gait", "foot": "gait", "knee": "gait", "bunions": "gait"
    };

    // Predictive Analysis (The "Scare" Factor)
    const calculateRisk = (part, score) => {
        if (score > 85) return { risk: "Low", prediction: "Sustainable longevity." };
        if (score > 70) return { risk: "Moderate", prediction: "Performance leak detected." };
        return { risk: "High", prediction: "Chronic injury likely within 18 months if uncorrected." };
    };

    // =========================================================================
    // ⚙️ LAYER 3: CORE LOGIC EXECUTION
    // =========================================================================

    const lower = input.toLowerCase();
    const timeCtx = getTimeContext();
    const sentiment = detectSentiment(lower);
    
    // Analyze Audit State
    let worst = { part: "balanced", score: 100, key: "" };
    let second = { part: "great", score: 100, key: "" };
    
    if (audit) {
        const map = {
            head: { name: "Head/Neck", tips: "Head Loading" },
            shoulders: { name: "Shoulders", tips: "Standing Pulls" },
            spine: { name: "Spine", tips: "Spinal Waves" },
            hip: { name: "Hips", tips: "Split Squats" },
            gait: { name: "Gait", tips: "Hyperarch Hops" }
        };
        for (let key in map) {
            const val = audit[key]?.val || 100;
            if (val < worst.score) {
                second = worst;
                worst = { part: map[key].name, score: val, key, tips: map[key].tips };
            } else if (val < second.score) {
                second = { part: map[key].name, score: val, key, tips: map[key].tips };
            }
        }
    }

    // =========================================================================
    // 💬 LAYER 4: RESPONSE SYNTHESIS (With Actions)
    // =========================================================================

    let reply = "";
    let action = null; // Object { label: string, type: string, payload: any }
    let contextBonus = "";

    // 4.1 Keyword Matching (Intent Detection)
    const isAcademy = lower.includes("learn") || lower.includes("reading") || lower.includes("class") || lower.includes("academy");
    const isRoutine = lower.includes("plan") || lower.includes("routine") || lower.includes("workout") || lower.includes("start");
    const isPain = lower.includes("pain") || lower.includes("hurt");
    
    // Fuzzy Anatomy Match
    let bestMatchKey = null;
    Object.keys(anatomyMatrix).forEach(term => {
        if (fuzzyMatch(lower, term) > 0.85) bestMatchKey = anatomyMatrix[term];
    });

    // --- LOGIC BRANCHES ---

    // BRANCH A: Direct Action Request (Navigation)
    if (isAcademy) {
        reply = "Knowledge is the first step to correction. I'm opening the **Movement Academy** now. Start with the 'Biotensegrity' masterclass.";
        action = { label: "OPEN ACADEMY", type: "NAVIGATE", payload: "academy" };
    }
    // BRANCH B: Routine Generation
    else if (isRoutine) {
        reply = `I've constructed a ${timeCtx.phase} protocol targeting your **${worst.part}** (${worst.score}%).\n\n` +
                `**Objective:** Restore elastic recoil and alignment.\n` +
                `**Key Move:** ${worst.tips}\n\n` +
                `Ready to execute sequence?`;
        action = { label: "LAUNCH SESSION", type: "START_SESSION", payload: generatedRoutine };
    }
    // BRANCH C: Anatomy/Pain Specific
    else if (bestMatchKey && audit) {
        const score = audit[bestMatchKey]?.val || "?";
        const risk = calculateRisk(bestMatchKey, score);
        reply = `You asked about **${bestMatchKey.toUpperCase()}**. Your biometric score here is **${score}%**.\n\n` +
                `**Kinetic Reality:** ${risk.prediction}\n` +
                `In biotensegrity, the site of pain is rarely the source. This is likely a compensation pattern.`;
        
        // Contextual Recommendation
        if (bestMatchKey === 'head') contextBonus = "\n\n💡 *Tip: Check your tongue posture. Press tongue to roof of mouth to stabilize the deep neck line.*";
        if (bestMatchKey === 'gait') contextBonus = "\n\n💡 *Tip: Stop heel striking. Land mid-foot to engage the fascial spring.*";
        
        reply += contextBonus;
        
        // Suggest specific fix
        action = { label: `FIX ${bestMatchKey.toUpperCase()}`, type: "START_SESSION", payload: null }; // Will trigger preset load
    }
    // BRANCH D: General Greetings / Status
    else if (lower.includes("hi") || lower.includes("hello") || lower.includes("status")) {
        reply = `Systems Online. ${timeCtx.icon} **Good ${timeCtx.phase}.**\n\n` +
                `**Current Bio-Integrity:** ${audit?.score || "?"}%\n` +
                `**Weakest Link:** ${worst.part} (${worst.score}%)\n` +
                `**Advisory:** ${timeCtx.advice}\n\n` +
                `What is your directive?`;
    }
    // BRANCH E: Lifestyle/Nutrition (Expansion)
    else if (lower.includes("water") || lower.includes("diet") || lower.includes("sleep")) {
        reply = `**Fascial Health Protocol:**\n\n` +
                `1. **Hydration:** Fascia is 70% water. If you are dehydrated, you are brittle. Drink 0.5oz per lb of bodyweight.\n` +
                `2. **Collagen:** The building block of your web. Bone broth or Vitamin C + Glycine.\n` +
                `3. **Sleep:** Tensegrity creates space during REM sleep. If you don't sleep, you shrink.`;
    }
    // FALLBACK
    else {
        reply = `I am analyzing your query against your biomechanical data.\n\n` +
                `**Current Priority:** Fix the ${worst.part} (${worst.score}%).\n` +
                `Unless your question solves that, it is a distraction. Focus on the foundation.`;
        action = { label: "VIEW DATA", type: "NAVIGATE", payload: "progress" };
    }

    // Distress Override
    if (sentiment === "distress") {
        reply = `⚠️ **Pain Signal Detected.**\n\n` +
                `Stop immediately. Pain is not gain; it is a request for change. ` +
                `We need to downregulate your nervous system. Switch to **Parasympathetic Breathing** now.`;
        action = { label: "EMERGENCY RESET", type: "LOAD_PRESET", payload: "Sedentary Reset" };
    }

    // =========================================================================
    // 🚀 LAYER 5: EXECUTION
    // =========================================================================
    
    // Add to history with potential action button
    setChatHistory(prev => [...prev, { 
        sender: 'ai', 
        text: reply, 
        action: action 
    }]);
    
    // Audio Feedback (Optional voice line)
    if (window.speechSynthesis && !lower.includes("silent")) {
        // Only speak the first sentence to be less annoying
        const utterance = new SpeechSynthesisUtterance(reply.split('.')[0]);
        utterance.rate = 1.1;
        utterance.volume = 0.2;
        // window.speechSynthesis.speak(utterance); // Uncomment for voice
    }
};

// 3. ACTION HANDLER (Paste into App component where you define handleChat)
const handleCoachAction = (action) => {
    if (!action) return;
    
    addLog(`Executing: ${action.type} -> ${action.label}`);
    
    switch (action.type) {
        case 'NAVIGATE':
            setTab(action.payload);
            setPostAnalysisMode(false); // Close side panel if needed for mobile
            break;
        case 'START_SESSION':
    if (action.payload) {
        setActiveProgram(action.payload);
    } else {
        // Force generation AND immediate launch
        generateProgram(); 
        // We use a tiny timeout to let the state update, then grab it
        setTimeout(() => {
            setActiveProgram(prev => prev || generatedRoutine); 
        }, 100);
    }
    break;
        case 'LOAD_PRESET':
            loadPreset(action.payload);
            break;
        default:
            console.warn("Unknown Action", action);
    }
};
    // REPLACE the remaining arrow function with this:
function drawSkeleton(keypoints, view) {
  const canvas = document.getElementById(`canvas-${view}`);
  if (!canvas || !uploadRefs[view].current) return;

  const img = uploadRefs[view].current;
  const container = canvas.parentElement;
  const contW = container.clientWidth;
  const contH = container.clientHeight;

  const dpr = window.devicePixelRatio || 1;
  canvas.width = contW * dpr;
  canvas.height = contH * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  ctx.clearRect(0, 0, contW, contH);

  // Letterbox image (object-contain)
  const imgRatio = img.naturalWidth / img.naturalHeight;
  const contRatio = contW / contH;
  let drawW, drawH, offsetX = 0, offsetY = 0;
  if (imgRatio > contRatio) {
    drawH = contH;
    drawW = drawH * imgRatio;
    offsetX = (contW - drawW) / 2;
  } else {
    drawW = contW;
    drawH = drawW / imgRatio;
    offsetY = (contH - drawH) / 2;
  }
  ctx.drawImage(img, offsetX, offsetY, drawW, drawH);

  // Scale keypoints to drawn image size
  const scaledKeypoints = keypoints.map(kp => ({
    x: kp.x * drawW + offsetX,
    y: kp.y * drawH + offsetY,
    score: kp.score || kp.visibility || 0
  }));

  // Connections (MediaPipe indices)
  const connections = [
    [11,12],[11,13],[13,15],[12,14],[14,16],
    [11,23],[12,24],[23,25],[24,26],[23,24]
  ].filter(pair => {
    const a = keypoints[pair[0]];
    const b = keypoints[pair[1]];
    return a && b && a.score > 0.15 && b.score > 0.15;
  });

  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  connections.forEach(([i, j]) => {
    const p1 = scaledKeypoints[i];
    const p2 = scaledKeypoints[j];
    const avgScore = (p1.score + p2.score) / 2;
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = avgScore > 0.4 ? '#22d3ee' : 'rgba(34,211,238,0.6)';
    ctx.lineWidth = avgScore > 0.4 ? 5 : 3;
    ctx.stroke();
  });

  // Keypoints (skip face 0–10)
  scaledKeypoints.forEach((kp, i) => {
    if (i > 10 && kp.score > 0.15) {
      ctx.beginPath();
      ctx.arc(kp.x, kp.y, 8, 0, Math.PI * 2);
      ctx.fillStyle = '#0f172a';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(kp.x, kp.y, 6, 0, Math.PI * 2);
      ctx.fillStyle = kp.score > 0.5 ? '#22d3ee' : '#f59e0b';
      ctx.fill();
    }
  });
};

const startLiveMode = async () => {
    setCameraError(false);
    try {
        // Direct user gesture → requests permission properly
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user", width: 1280, height: 720 }
        });
        if (liveVideoRef.current) {
            liveVideoRef.current.srcObject = stream;
        }
        setLiveMode(true);
    } catch (err) {
        console.error("Camera access failed:", err);
        setCameraError(true);
        alert("Camera access was blocked. Please allow camera permission in your browser settings and try again.");
    }
};
    // ... inside the App component return statement ...

    const runAnalysis = async () => {
        // FIXED: Helper function for checking landmark validity
        const valid = (lm) => lm && (lm.score > 0.5 || lm.visibility > 0.5);

        let net = system.detector;
        if (!navigator.onLine) {
            addLog("⚠ Offline — Connect to analyze.");
            setStatus(prev => ({ ...prev, analyzing: false }));
            return;
        }

        // 1. SHOW LOADING STATE IMMEDIATELY
        setStatus(prev => ({
            ...prev,
            analyzing: true,
            logs: ["Initiating Neural Core V85...", ...prev.logs]
        }));

        document.body.classList.add('analyzing'); //
        document.querySelectorAll('.upload-slot.active').forEach(slot => slot.classList.add('scanning'));

        // 2. THE 50MS PAUSE (Lets the browser draw the "Analyzing" bar before freezing)
        await new Promise(r => setTimeout(r, 50));


        // 4. PREPARE FOR DATA
        const views = Object.keys(uploads).filter(k => uploads[k] && uploads[k].url);
        if (views.length === 0 && symptoms.length === 0) {
            addLog("Upload at least one photo.");
            setStatus(prev => ({ ...prev, analyzing: false }));
            return;
        }

        document.querySelectorAll('.upload-slot').forEach(slot => slot.classList.remove('scanning'));

        let rawScores = { head: [], shoulders: [], spine: [], hip: [], gait: [] };
        let detectedIssues = new Set();

// Calculates rotation in degrees relative to the camera plane
const calculateTorsion = (p1, p2) => {
    if (!p1 || !p2) return 0;
    const width = Math.abs(p1.x - p2.x);
    const depth = Math.abs(p1.z - p2.z); 
    // Arctan of depth/width gives the angle of rotation
    return Math.atan2(depth, width) * (180 / Math.PI);
};


        // ELITE BIOMECHANICAL ENGINE V2 (Z-Depth Compensated)
const rateMetric = (point1, point2, axis = 'y', sensitivity = 5000) => {
  if (!point1 || !point2) return 50;  // Lower default
  const visualDelta = Math.abs(point1[axis] - point2[axis]);
  const zDelta = Math.abs((point1.z || 0) - (point2.z || 0)) * 0.5;
  const trueDeviation = Math.max(0, visualDelta - (zDelta * 0.8));
  const score = 100 - (trueDeviation * sensitivity);
  return Math.max(30, Math.min(100, Math.floor(score)));  // Min 30 for F variance
};

        try {
            for (const view of views) {
                const img = uploadRefs[view].current;
                if (!img || img.naturalWidth === 0) continue;

                const result = await system.detector.detect(img);

                if (!result || result.landmarks.length === 0) {
                    addLog(`⚠ NO SKELETON FOUND in ${view}.`);
                    continue;
                }

                // Map MediaPipe landmarks to the format your app expects
                const keypoints = result.landmarks[0].map((lm, i) => ({
                    x: lm.x,
                    y: lm.y,
		    z: lm.z,
                    score: lm.visibility || 1.0,
                    name: i
                }));

const p = keypoints;
const landmarks3D = result.worldLandmarks ? result.worldLandmarks[0] : result.landmarks[0];

drawSkeleton(keypoints, view);



// NEW: Knee Valgus (Front: Knees inward)
if (view === 'front' && valid(p[24]) && valid(p[26]) && valid(p[28])) {
  const kneeAngle = calculateAngle(p[24], p[26], p[28]);
  const ideal = 180;
  const dev = Math.abs(ideal - kneeAngle);
  rawScores.gait.push(100 - dev * 3);
  if (dev > 10) detectedIssues.add("Knee Valgus");
}

// NEW: Spinal Curve (Side: Ear-shoulder-hip angle for kyphosis/lordosis)
if (view === 'side' && valid(p[8]) && valid(p[12]) && valid(p[24])) {
  const spineAngle = calculateAngle(p[8], p[12], p[24]);
  const ideal = 180;
  const dev = Math.abs(ideal - spineAngle);
  rawScores.spine.push(100 - dev * 2.5);
  if (dev > 20) detectedIssues.add("Kyphosis/Lordosis");
}

// NEW: Ankle Pronation (Front: Ankle vs knee/hip alignment)
if (view === 'front' && valid(p[26]) && valid(p[28])) {
  const pronation = Math.abs(p[26].x - p[28].x) * 5000;
  rawScores.gait.push(100 - pronation);
}


// REPLACEMENT: Local AI Classifier (100% Offline)
                try {
    // REFINED CLASSIFIER: Now View-Aware to prevent false positives
    const classifyPose = (kps, view) => {
        let flags = [];

        // 1. FORWARD HEAD (Only run on SIDE view)
        if (view === 'side' && valid(kps[8]) && valid(kps[12])) {
            const torsoH = Math.abs(kps[12].y - (kps[24]?.y || kps[12].y + 0.3));
            const headDev = Math.abs(kps[8].x - kps[12].x) / torsoH;
            if (headDev > 0.08) flags.push({ class: 'forward_head', conf: headDev * 2 });
        }

        // 2. SCOLIOSIS / TILT (Only run on FRONT or BACK view)
        if ((view === 'front' || view === 'back') && valid(kps[11]) && valid(kps[12])) {
            const shYDiff = Math.abs(kps[11].y - kps[12].y);
            const hipYDiff = valid(kps[23]) && valid(kps[24]) ? Math.abs(kps[23].y - kps[24].y) : 0;
            const curveRisk = Math.max(shYDiff, hipYDiff);
            if (curveRisk > 0.06) flags.push({ class: 'scoliosis_risk', conf: curveRisk * 20 });
        }

        // 3. KNEE VALGUS (Only run on FRONT view)
        if (view === 'front' && valid(kps[24]) && valid(kps[26]) && valid(kps[28])) {
            const kneeIn = Math.abs(kps[26].x - ((kps[24].x + kps[28].x) / 2));
            if (kneeIn > 0.08) flags.push({ class: 'valgus_knees', conf: kneeIn * 15 });
        }

        if (flags.length === 0) return { class: 'normal', conf: 1.0 };
        flags.sort((a, b) => b.conf - a.conf);
        return { class: flags[0].class, conf: Math.min(1.0, flags[0].conf) };
    };

    // Pass the current 'view' to the classifier
    const aiResult = classifyPose(keypoints, view);
    
    if (aiResult.conf > 0.6 && aiResult.class !== 'normal') {
        detectedIssues.add(aiResult.class);
        addLog(`Local AI Flag: ${aiResult.class} (${(aiResult.conf * 100).toFixed(0)}%)`);

        // Apply penalties only where appropriate
        if (aiResult.class.includes('head')) rawScores.head.push(100 - (aiResult.conf * 55));
        else if (aiResult.class.includes('scoliosis')) rawScores.spine.push(100 - (aiResult.conf * 50)); // Map tilt to spine
        else if (aiResult.class.includes('valgus')) rawScores.gait.push(100 - (aiResult.conf * 55));
    }

} catch (e) {
    console.error("Local Classifier Error", e);
}

              // --- FRONT VIEW: ELITE 3D ANALYSIS (V2) ---

if (view === 'side') {
  const ear = p[7]; // Left ear
  const shoulder = p[11]; // Left shoulder
  const hip = p[23]; // Left hip
  const neckAngle = calculateAngle(ear, shoulder, hip);
  rawScores.head.push(100 - neckAngle * 2); // Penalty for >45°
}
if (view === 'front') {
  const leftShoulder = p[11], rightShoulder = p[12];
  const asymmetry = Math.abs(leftShoulder.y - rightShoulder.y) * 1000;
  rawScores.shoulders.push(100 - asymmetry);
}
if (view === 'front') {
    // Use 3D Landmarks for Z-depth access
    const lSh = landmarks3D[11], rSh = landmarks3D[12];
    const lHip = landmarks3D[23], rHip = landmarks3D[24];

    // 1. SHOULDER ANALYSIS
    if (valid(lSh) && valid(rSh)) {
        const torsion = calculateTorsion(lSh, rSh);
        
        // If user is rotated > 15 degrees, the scan is invalid for symmetry
        if (torsion > 15) {
            addLog(`⚠ Severe Body Rotation Detected (${torsion.toFixed(1)}°). Please face forward.`);
            detectedIssues.add("Severe Rotation");
            // Heavy penalty for poor setup, or skip grading to avoid false positive
            rawScores.shoulders.push(65); 
        } else {
            // Use our new Z-Compensated Truth Calculator
            const score = rateMetric(lSh, rSh, 'y', 2000);
            rawScores.shoulders.push(score);
            if (torsion > 5) addLog(`Compensating for ${torsion.toFixed(1)}° shoulder twist...`);
        }
    }

    // 2. PELVIC HORIZON
    if (valid(lHip) && valid(rHip)) {
        const hipTorsion = calculateTorsion(lHip, rHip);
        const score = rateMetric(lHip, rHip, 'y', 1200); // Z-Compensated
        rawScores.hip.push(score);
        
        // Advanced: Detect "Torque" (Shoulders twisted one way, hips the other)
        if (valid(lSh) && Math.abs(calculateTorsion(lSh, rSh) - hipTorsion) > 8) {
            detectedIssues.add("Cross-Body Torque");
            addLog("⚠ Detected Spinal Torsion (Torque)");
        }
    }
}

// --- BACK VIEW: SYMMETRY ANALYSIS ---
if (view === 'back') {
    // Map Back View symmetry to Head/Spine scores (Superficial Back Line)
    const lSh = p[11], rSh = p[12];
    const lHip = p[23], rHip = p[24];

    if (valid(lSh) && valid(rSh) && valid(lHip) && valid(rHip)) {
        // Calculate symmetry
        const shSlope = Math.abs(lSh.y - rSh.y);
        const hipSlope = Math.abs(lHip.y - rHip.y);
        const symmetry = 100 - ((shSlope + hipSlope) * 1500);
        
        // Push to Head (Superficial Back Line) and Spine
        const score = Math.max(50, Math.floor(symmetry));
        rawScores.head.push(score); 
        rawScores.spine.push(score);
        addLog(`Back Symmetry Analysis: ${score}%`);
    }
}

                // --- SIDE VIEW: AXIAL ALIGNMENT ---
                if (view === 'side') {
                    const ear = p[8], shoulder = p[12], hip = p[24], ankle = p[28];
                    const torsoH = valid(shoulder) && valid(hip) ? Math.abs(hip.y - shoulder.y) : 0.5;

                    // 1. PLUMB LINE ACCURACY (Head over Shoulder)
                    if (valid(ear) && valid(shoulder)) {
                        const dev = Math.abs(ear.x - shoulder.x) / torsoH;
                        const s = 100 - (dev * 1000); // Scientific constant for Forward Head
                        rawScores.head.push(Math.max(40, Math.floor(s)));
                    }

                    // 2. KINETIC CHAIN (Hip over Ankle)
                    if (valid(hip) && valid(ankle)) {
                        const chainDev = Math.abs(hip.x - ankle.x) / torsoH;
                        const s = 100 - (chainDev * 800);
                        rawScores.spine.push(Math.max(40, Math.floor(s)));
                    }
                }
            }
        } catch (err) { console.error(err); }

        // --- 4. AGGREGATE & INFER ---
        // Helper to average an array, or return null. FILTERS NaN.
        const avg = (arr) => {
            const valid = arr.filter(n => typeof n === 'number' && !isNaN(n));
            return valid.length ? valid.reduce((a, b) => a + b) / valid.length : null;
        };

        let final = {
            head: avg(rawScores.head),
            shoulders: avg(rawScores.shoulders),
            spine: avg(rawScores.spine),
            hip: avg(rawScores.hip),
            gait: avg(rawScores.gait)
        };

        // FIND THE LOWEST SCORE (The "Weakest Link")
        // We use this to fill in missing data.
        // e.g. If Head is missing, but Shoulders are 40, Head becomes 45.
        // If NO data exists, we default to 70 (C-), not 85.
        const validScores = Object.values(final).filter(v => v !== null && !isNaN(v));
        const worstScore = validScores.length ? Math.min(...validScores) : 70;

        // Fill Nulls with Kinetic Logic
        if (final.head === null) final.head = final.shoulders ? final.shoulders + 5 : worstScore + 5;
        if (final.shoulders === null) final.shoulders = worstScore + 10;
        if (final.spine === null) final.spine = final.hip ? final.hip : worstScore; // Spine is slave to hips
        if (final.hip === null) final.hip = worstScore + 5;
        if (final.gait === null) final.gait = final.hip ? final.hip : 75;

       // --- 5. SYMPTOM PENALTIES (The "Truth" Layer) ---
// DISABLE CAPS to allow high scores even with pain
/* if (symptoms.includes('Neck Pain')) final.head = Math.min(final.head, 65);
if (symptoms.includes('Back Pain')) final.spine = Math.min(final.spine, 65);
if (symptoms.includes('Knee Pain')) final.gait = Math.min(final.gait, 65);
if (symptoms.includes('Foot Pain')) final.gait = Math.min(final.gait, 60);
*/

        // --- 6. FINAL ROUNDING & NAN PROTECTION ---
        Object.keys(final).forEach(k => {
            // CRITICAL FIX: If data is missing/NaN, default to 70 (Passing) to prevent app crash
            if (typeof final[k] !== 'number' || isNaN(final[k])) {
                final[k] = 70;
            }
            final[k] = Math.floor(Math.max(0, Math.min(100, final[k])));
        });

        // Total Score Calculation (Safe Mode)
        const scoreValues = Object.values(final);
        const average = scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length;
        const minimum = Math.min(...scoreValues);
// 1. Calculate the base score
const totalScore = isNaN(average) ? 0 : Math.floor((average * 0.6) + (minimum * 0.4));

// 2. THE BIO-AGE ALGORITHM
// We assume a baseline age of 30 if they haven't entered one. 
// For every point below 100, we add 0.5 years to their "Structural Age"
const baselineAge = 30; 
const agePenalty = (100 - totalScore) * 0.5;
const structuralAge = Math.floor(baselineAge + agePenalty);

const newAudit = {
    date: new Date().toLocaleDateString(),
    score: totalScore,
    bioAge: structuralAge, // <--- New Property
    ageDiff: structuralAge - baselineAge, // <--- New Property
    head: { val: final.head, grade: getGrade(final.head) },
    shoulders: { val: final.shoulders, grade: getGrade(final.shoulders) },
    spine: { val: final.spine, grade: getGrade(final.spine) },
    gait: { val: final.gait, grade: getGrade(final.gait) },
    hip: { val: final.hip, grade: getGrade(final.hip) }
};

        // NEW: Trend Forecasting
        const recent = history.slice(0, 5).map(h => h.score).reverse();
        if (recent.length > 1) {
            const n = recent.length;
            const sumX = recent.reduce((s, _, i) => s + i, 0);
            const sumY = recent.reduce((s, y) => s + y, 0);
            const sumXY = recent.reduce((s, y, i) => s + i * y, 0);
            const sumX2 = recent.reduce((s, _, i) => s + i * i, 0);
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const predicted = newAudit.score + slope * (currentGoal.duration || 30);  // Fallback 30 days
            newAudit.forecast = { predicted: Math.floor(Math.max(0, predicted)), slope };
        }

        // --- START DRAMATIC FINALE ---
        addLog("Synchronizing Biometric Data...");

        // This is the "Dramatic Pause". 3000 = 3 seconds of extra scanning time.
        await new Promise(r => setTimeout(r, 4000));

        setAudit(newAudit);
        setHistory([newAudit, ...history]);
	// Auto-set Before/After images (side view preferred)
if (history.length === 0) {
    // This is the user's VERY FIRST scan ever
    const firstImage = uploads.side?.url || uploads.front?.url || uploads.back?.url;
    setBeforeImage(firstImage);
}
const latestImage = uploads.side?.url || uploads.front?.url || uploads.back?.url;
setAfterImage(latestImage);

// Auto-set Before/After for comparison slider
if (history.length === 0) {
    // This is the very first scan ever
    setBeforeImage(uploads.side?.url || uploads.front?.url);
}
setAfterImage(uploads.side?.url || uploads.front?.url); // Always update "after" to latest

        setStatus(prev => ({ ...prev, analyzing: false }));
        localStorage.setItem('biometric_data_v82', JSON.stringify({ history: [newAudit, ...history], symptoms, prefs: userPrefs }));

        if (history.length === 0) {
            setTab('results');
        } else {
            setTab('dashboard');
        }

        // Trigger Premium Effects
SFX.success();
generateProgram();                    // Still generates the program in background
setShowProtocolButton(true);          // Shows the button
setPostAnalysisMode(true);            // Expands right panel
document.body.classList.remove('analyzing');
document.querySelectorAll('.upload-slot').forEach(slot => slot.classList.remove('scanning'));

        // Confetti Burst
        const confettiContainer = document.createElement('div');
        confettiContainer.style.position = 'fixed';
        confettiContainer.style.inset = '0';
        confettiContainer.style.pointerEvents = 'none';
        confettiContainer.style.zIndex = '100';
        document.body.appendChild(confettiContainer);
        for (let i = 0; i < 50; i++) {
            const c = document.createElement('div');
            c.className = 'confetti';
            c.style.left = Math.random() * 100 + 'vw';
            c.style.background = ['#22d3ee', '#fff', '#0ea5e9'][Math.floor(Math.random() * 3)];
            c.style.animationDelay = Math.random() * 2 + 's';
            confettiContainer.appendChild(c);
        }
        setTimeout(() => confettiContainer.remove(), 4000);
        // --- END DRAMATIC FINALE ---
    };
    // --- V101.0 APEX ARCHITECT ENGINE (TRUE VARIANCE & ROULETTE SELECTION) ---
const generateProgram = () => {
    if (!audit) return;

    // 1. PHASE CALCULATOR
    const score = audit.score;
    let userPhase = 1;
    if (score >= 85) userPhase = 5;      
    else if (score >= 75) userPhase = 3; 
    else if (score >= 65) userPhase = 2; 
    else userPhase = 1;                  

    if (history.length < 5) userPhase = 1;

    const parts = ['head', 'shoulders', 'spine', 'hip', 'gait'];


// 1. GRANULAR PHASE CALCULATOR (Per-Part)
const partPhases = {};
parts.forEach(part => {  // parts is always defined as array, no error
    const partScore = audit[part]?.val || 70;  // Safe fallback if audit[part] undefined
    let phase = 1;
    if (partScore >= 85) phase = 5;
    else if (partScore >= 75) phase = 3;
    else if (partScore >= 65) phase = 2;
    if (history.length < 5) phase = Math.min(phase, 2); // Cap early users
    partPhases[part] = phase;
});

// Use average for global, but per-part for filtering
userPhase = Math.floor(Object.values(partPhases).reduce((a,b) => a+b, 0) / parts.length);

// WEEKLY THEME (Cycles every week)
const now = new Date();
const start = new Date(now.getFullYear(), 0, 1);
const diff = (now - start) + ((start.getDay() === 0 ? -6 : 1) - start.getDay()) * 86400000;
const week_num = Math.ceil(diff / 604800000);  // 604800000 = 7 days ms
const themes = ['power', 'recovery', 'mobility'];
const currentTheme = themes[week_num % 3];

    // 2. TARGET IDENTIFICATION
    const sortedParts = parts.sort((a, b) => audit[a].val - audit[b].val);
    const weakestLink = sortedParts[0];
    const secondaryLink = sortedParts[1];

// SYMPTOM SEVERITY CALC (0-1 scale)
const symptomSeverity = symptoms.length / 4; // Max 4 symptoms, safe /0=0
const symptomMap = {
    'Neck Pain': ['head', 'shoulders'],
    'Back Pain': ['spine', 'hip'],
    'Knee Pain': ['gait', 'hip'],
    'Foot Pain': ['gait']
};

// Combo Detection (e.g., neck+back = spine bonus)
const affectedParts = new Set();
symptoms.forEach(sym => {  // symptoms is always array (empty ok)
    const mapped = symptomMap[sym] || [];  // Safe empty array if no match
    mapped.forEach(p => affectedParts.add(p));  // forEach on safe array
});

    // 3. RETRIEVE GLOBAL USAGE STATS (Total times done)
    // We calculate this on the fly to penalize over-used moves
    const globalUsage = {};
    Object.keys(exerciseHistory).forEach(key => {
        // We use a rough estimate based on history length or specific counters if you added them
        // For now, we assume if it's in history, it's been done at least once + goodStreaks
        globalUsage[key] = (exerciseHistory[key].goodStreaks || 0) + 1; 
    });

    // 4. GENERATE LOTTERY POOL
    let lotteryPool = EXERCISE_DB.map(ex => {
        // --- HARD FILTERS ---
        if (!useEquipment && ex.equipment === 'required') return null;
        if (userPrefs.noEquipment && ex.equipment === 'required') return null;
        if (userPrefs.lowImpact && ex.pattern.includes('power')) return null;
        if (userPrefs.noJumps && (ex.id.includes('hop') || ex.id.includes('bounce'))) return null;
        if (ex.requires_mastery && !ex.requires_mastery.every(id => exerciseHistory[id]?.goodStreaks >= 2)) return null;

        // --- TICKET ALLOCATION (The Weighting) ---
        let tickets = 100; 

        // A. Relevance (The Need)
        if (ex.target_grade === weakestLink) tickets += 300;       
        else if (ex.target_grade === secondaryLink) tickets += 150; 
        else if (audit[ex.target_grade]?.val < 70) tickets += 50; 

        // B. Pain Synergy (The Override)
        if (ex.synergies && ex.synergies.some(s => symptoms.includes(s))) {
            tickets += 500; 
// B. Pain Synergy + Severity (Dynamic Multiplier)
let painBoost = 0;
if (ex.synergies && Array.isArray(ex.synergies)) {  // Guard Array.isArray
    const matches = ex.synergies.filter(s => symptoms.includes(s)).length;
    painBoost = matches * 300 * (1 + symptomSeverity); // Base 300, up to 600 if severe
    if (affectedParts.has(ex.target_grade)) painBoost *= 1.5; // Combo 50% extra
}
tickets += painBoost;
        }

        // C. Phase Alignment
        if (ex.phase === userPhase) tickets += 150;       
        else if (ex.phase === userPhase - 1) tickets += 50; 
        else if (ex.phase > userPhase) tickets = 0; // Hard lock on future content

// In lotteryPool map, after C:
if (currentTheme === 'power' && (ex.pattern ?.includes('power') || false)) {
    tickets += 200;
} else if (currentTheme === 'recovery' && (ex.pattern ?.includes('release') || false)) {
    tickets += 200;
} else if (currentTheme === 'mobility' && (ex.pattern ?.includes('flow') || false)) {
    tickets += 200;
}

        // D. VARIANCE ENGINE (The Fix)
        const hist = exerciseHistory[ex.id];
        const lastDate = hist?.lastUsed;
        const today = new Date().toDateString();
        
        // 1. Immediate Staleness (Nuclear Penalty)
        // If done today, reduce chance by 99% (but leave 1% in case DB is small)
        if (lastDate === today) tickets *= 0.01; 

        // 2. Inverse Frequency (The "Variety" Enforcer)
        // The more you've done it, the less likely it is.
        const timesDone = globalUsage[ex.id] || 0;
        if (timesDone > 0) {
            // Decay formula: Tickets / (1 + (timesDone * 0.2))
            // Example: Done 5 times = Tickets / 2.
            tickets = tickets / (1 + (timesDone * 0.25)); 
        }

        // 3. Discovery Bonus (The "New" Boost)
        if (!hist) tickets += 400; // Massive boost for untouched exercises

        // 4. Session Exclusion (Prevent "Generate" -> "Generate" duplicates)
        // If this exercise is in the currently displayed routine, kill its tickets
        if (activeProgram && activeProgram.some(p => p.id === ex.id)) {
             tickets *= 0.001;
        }

        return { ...ex, tickets: Math.max(1, Math.floor(tickets)) };
    }).filter(e => e && e.tickets > 0);

    // 5. ROULETTE WHEEL SELECTION 
    // This replaces the "Sort and Slice" method. 
    // It creates a probability distribution so lower scores still have a chance.
    const routine = [];
    const usedPatterns = new Set();
    const usedIDs = new Set();

    const drawFromPool = (pool, criteriaFn, reasonLabel) => {
        // Filter candidates
        let candidates = pool.filter(ex => !usedIDs.has(ex.id) && criteriaFn(ex));
        
        // Pattern diversity filter (Soft filter)
        const freshPatternCandidates = candidates.filter(ex => !usedPatterns.has(ex.pattern));
        if (freshPatternCandidates.length > 0) candidates = freshPatternCandidates;

        if (candidates.length === 0) return null;

        // ROULETTE LOGIC
        const totalWeight = candidates.reduce((sum, ex) => sum + ex.tickets, 0);
        let randomValue = Math.random() * totalWeight;
        let selected = null;

        for (const ex of candidates) {
            randomValue -= ex.tickets;
            if (randomValue <= 0) {
                selected = ex;
                break;
            }
        }
        // Fallback (rare rounding errors)
        if (!selected) selected = candidates[candidates.length - 1];

        if (selected) {
            routine.push({ ...selected, smartReason: reasonLabel });
            usedPatterns.add(selected.pattern);
            usedIDs.add(selected.id);
        }
        return selected;
    };

    // --- SLOT CONFIGURATION ---

    // Slot 1: The Critical Fix (Must hit weak link or pain)
    drawFromPool(lotteryPool, ex => ex.target_grade === weakestLink || (ex.synergies && ex.synergies.some(s => symptoms.includes(s))), `Primary Fix: ${weakestLink.toUpperCase()}`);

    // Slot 2: The Secondary Support
    drawFromPool(lotteryPool, ex => ex.target_grade === secondaryLink, `Support: ${secondaryLink.toUpperCase()}`);

    // Slot 3: Phase Power (The "Fun" one)
    drawFromPool(lotteryPool, ex => ex.phase === userPhase, `Phase ${userPhase} Power`);

    // Slot 4: Structural Balance (Opposite pattern of what we've picked)
    drawFromPool(lotteryPool, ex => true, "Structural Balance");

    // Slot 5: Discovery (Prioritize things with high tickets - likely new ones)
    drawFromPool(lotteryPool, ex => !exerciseHistory[ex.id], "New Stimulus");

    // Slot 6: Wildcard (Pure Chaos)
    drawFromPool(lotteryPool, ex => true, "System Flush");

    // Failsafe fill
    while (routine.length < 4 && lotteryPool.length > routine.length) {
        drawFromPool(lotteryPool, ex => true, "Volume Filler");
    }

    // 6. BUILD FINAL OBJECTS
    const finalRoutine = routine.map(ex => {
        const hist = exerciseHistory[ex.id] || {};
        let levelIdx = hist.lastLevel || 0;

        // Smart Progression
        if (hist.lastRating === 'easy') levelIdx = Math.min(ex.levels.length - 1, levelIdx + 1);
        else if (hist.lastRating === 'hard') levelIdx = Math.max(0, levelIdx - 1);
        else if (userPhase >= 3 && ex.levels.length > 2) levelIdx = Math.max(levelIdx, 1);

// MASTERY GATE: Lock levels >2 until phase >=3 or goodStreaks >=2
if (levelIdx > 1 && (userPhase < 3 || hist.goodStreaks < 2)) {
    levelIdx = 1; // Force regress to safe level
}

        const levelData = ex.levels[levelIdx] || ex.levels[0];
        let duration = levelData.duration || 60;
        if (userPhase >= 4) duration += 30; 

        return {
            ...levelData,
            id: ex.id,
            baseTitle: ex.title,
            reason: ex.smartReason,
            allLevels: ex.levels,
            currentLevelIdx: levelIdx,
            duration: duration
        };
    });

    setGeneratedRoutine(finalRoutine);
    addLog(`V101 Logic: Generated ${finalRoutine.length} Unique Vectors`);
};
    // --- PRESET LOADER ---
   const loadPreset = (presetName) => {
    const exerciseIds = PRESET_PROTOCOLS[presetName];
    if (!exerciseIds || exerciseIds.length === 0) return;

    let routine = exerciseIds.map((id, overallIdx) => {
        const ex = EXERCISE_DB.find(e => e.id === id);
        if (!ex) return null;

        // FORCE level 0 (first level) for head_loading_progression
        // For all other exercises, use smart progression (level 1 or saved)
        let levelIdx = 0;
        if (id !== "head_loading_progression") {
            const hist = exerciseHistory[id] || {};
            levelIdx = hist.lastLevel || (ex.levels.length > 1 ? 1 : 0);
        }

        const levelData = ex.levels[levelIdx];

        return {
            ...levelData,
            id: ex.id,
            baseTitle: ex.title,
            reason: presetName,
            allLevels: ex.levels,
            currentLevelIdx: levelIdx,
            duration: levelData.duration || 90
        };
    }).filter(Boolean);

    setActiveProgram(routine);
    addLog(`Loaded ${presetName} — ${routine.length} movements`);
};
    // NEW: Update Goal Handler
    const updateGoal = () => setShowGoalSetter(true);

    return (
        <div className={`workspace bg-slate-950 text-white selection:bg-cyan-500 selection:text-black ${postAnalysisMode ? 'post-analysis' : ''}`}>
            {cameraActive && <CameraCapture onClose={() => setCameraActive(null)} onCapture={(url) => {
                setUploads(prev => ({ ...prev, [cameraActive]: { url, analyzed: false } }));
                setCameraActive(null);
                addLog(`Captured ${cameraActive} view via Camera`);
            }} />}

            {/* LIVE REAL-TIME MODE OVERLAY */}
                        {liveMode && (
                <div className="fixed inset-0 bg-black/95 z-[70] flex flex-col items-center justify-center p-4 animate-popIn">
                    <div className="relative w-full max-w-4xl h-[80vh] bg-slate-900 rounded-3xl overflow-hidden shadow-2xl border border-cyan-500/50">
                        {/* Webcam Video (mirrored) */}
                        <video
                            ref={liveVideoRef}
                            autoPlay
                            playsInline
                            muted
                            className="absolute inset-0 w-full h-full object-cover scale-x-[-1]"
                        />

                        {/* Live Skeleton Canvas */}
                        <canvas
                            ref={liveCanvasRef}
                            className="absolute inset-0 w-full h-full pointer-events-none"
                        />

                        <div className="absolute top-8 left-1/2 -translate-x-1/2 bg-black/70 backdrop-blur px-10 py-5 rounded-2xl border border-cyan-500 shadow-2xl text-center">
                            <div className="text-4xl font-black text-cyan-400">
                                {liveKeypoints 
                                    ? (liveCountdown !== null ? `CAPTURING IN ${liveCountdown}...` : "GOOD POSE LOCKED!")
                                    : "FINDING POSE..."
                                }
                            </div>

                            {liveScore !== null && (
                                <div className="mt-4 text-6xl font-black text-white">
                                    {liveScore}<span className="text-2xl text-cyan-400">%</span>
                                </div>
                            )}

                            <div className="text-sm text-slate-300 mt-4 max-w-md">
                                {liveKeypoints 
                                    ? "Hold steady — capturing front view automatically"
                                    : "Step back • Full body visible • Arms at sides • Face camera directly"
                                }
                            </div>
                        </div>

                        {cameraError && (
                            <div className="absolute inset-0 flex items-center justify-center bg-red-900/80 backdrop-blur">
                                <div className="text-center">
                                    <div className="text-4xl font-black text-white mb-4">Camera Blocked</div>
                                    <p className="text-white mb-4">Please allow camera access</p>
                                    <button 
                                        onClick={() => setLiveMode(false)}
                                        className="px-6 py-3 bg-white text-black rounded-xl font-bold"
                                    >
                                        Back
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Countdown Number */}
                        {liveCountdown !== null && (
                            <div className="absolute inset-0 flex items-center justify-center text-9xl font-black text-white animate-ping">
                                {liveCountdown}
                            </div>
                        )}

                        {/* Close Button */}
                        <button
                            onClick={() => {
                                setLiveMode(false);
                                if (liveVideoRef.current?.srcObject) {
                                    liveVideoRef.current.srcObject.getTracks().forEach(track => track.stop());
                                }
                                setLiveKeypoints(null);
                                setLiveCountdown(null);
                            }}
                            className="absolute top-6 right-6 w-16 h-16 bg-red-600/90 hover:bg-red-500 rounded-full flex items-center justify-center text-white text-3xl font-bold shadow-2xl"
                        >
                            ✕
                        </button>
                    </div>
                </div>
            )}

            {/* ALL MODALS IN ONE FRAGMENT */}
            <>
                {isModelLoading && (
                    <div className="fixed inset-0 bg-black/90 z-[100] flex flex-col items-center justify-center backdrop-blur-xl animate-popIn">
                        <div className="w-20 h-20 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-6"></div>
                        <div className="text-cyan-400 font-black text-xl tracking-widest animate-pulse">DOWNLOADING NEURAL CORE V85...</div>
                        <div className="text-slate-500 text-xs mt-2 uppercase">Initial load may take 5-10 seconds</div>
                    </div>
                )}
                {showReader && <ReaderMode item={showReader} onClose={() => setShowReader(null)} />}
                {showGoalSetter && <GoalSetter currentGoal={currentGoal} onSave={saveGoal} onClose={() => setShowGoalSetter(false)} />}
                {showShare && <ShareReport audit={audit} onClose={() => setShowShare(false)} />}
            </>

            <div ref={viewportRef} className={`viewport ${status.analyzing ? 'analyzing-blur-fix' : ''}`}>


                <div className="text-center px-6">
                    <h1 className="text-5xl md:text-6xl font-black text-white mb-4 tracking-tight bg-gradient-to-r from-cyan-400 via-blue-500 to-cyan-400 bg-clip-text text-transparent animate-popIn">
                        MOVEMENT MECHANICS
                    </h1>
                    <p className="text-xl md:text-2xl text-slate-300 mb-4 max-w-5xl mx-auto leading-relaxed opacity-90">
                        Upload photos → Get an instant biomechanical analysis + personalized training protocol.
                    </p>

<div className="text-center mb-8">
    <p className="text-lg text-cyan-400 font-medium tracking-wide">
        Completely free • 100% private (nothing leaves your browser)
    </p>
</div>
                    {postAnalysisMode && audit && (
                        <div className="mb-12 p-6 md:p-10 bg-gradient-to-r from-purple-900/40 via-cyan-900/40 to-blue-900/40 rounded-3xl border-2 border-cyan-500/50 text-center animate-popIn shadow-2xl shadow-cyan-900/50 mx-2 md:mx-8 overflow-hidden">
                            <p className="text-sm md:text-xl font-bold text-cyan-300 mb-4 uppercase tracking-widest opacity-80">Today's Primary Limitation</p>

                            <div className="flex justify-center items-center py-2">
                                <h2 className="text-3xl sm:text-4xl md:text-6xl font-black text-white leading-tight tracking-tight uppercase">
                                    <span style={{ display: 'block', whiteSpace: 'normal', wordBreak: 'keep-all' }}>
                                        {Object.keys(audit).find(k => audit[k] && (audit[k].grade === 'F' || audit[k].grade === 'D'))?.replace(/_/g, ' ').toUpperCase() || 'PERFECT BALANCE'}
                                    </span>
                                </h2>
                            </div>

                            {/* ROBUST SCORE DISPLAY */}
                            <div className="mt-2 text-center">
                                <span className={`text-4xl font-black ${(audit.score || 0) < 50 ? 'text-red-500' : (audit.score || 0) < 80 ? 'text-orange-400' : 'text-emerald-400'
                                    }`}>
                                    SCORE: {isNaN(audit.score) ? 0 : audit.score}%
                                </span>
                            </div>

                            <p className="text-base md:text-xl text-slate-300 max-w-2xl mx-auto mt-6 leading-relaxed italic opacity-90">
                                Your entire protocol is laser-focused on resolving this first.
                            </p>
                        </div>
                    )}
                </div>
                {/* HEADER NAV - ENHANCED with Progress Tab */}
                                <div className="flex justify-between items-center mb-2 no-print">
                    <div className="w-full max-w-4xl mx-auto space-y-8">
                        

                        {/* ORIGINAL: STANDARD ANALYSIS BUTTON */}
                        <button
                            onClick={() => { if (!status.analyzing && ready) runAnalysis(); }}
                            disabled={status.analyzing || !ready}
                            className={`
                                btn-primary 
                                w-full 
                                text-3xl py-8 
                                rounded-3xl 
                                font-black 
                                uppercase 
                                tracking-widest 
                                shadow-2xl shadow-cyan-900/60
                                bg-size-200
                                ${ready && !status.analyzing
                                    ? 'animate-pulse-slow bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600 bg-pos-0 hover:bg-pos-100'
                                    : 'opacity-60 bg-gradient-to-r from-slate-600 to-slate-700'
                                }
                                transition-all duration-1000
                            `}
                        >
                            {status.analyzing ? "NEURAL ANALYSIS IN PROGRESS..." : ready ? "ANALYZE MY POSTURE" : "UPLOAD PHOTOS TO BEGIN"}
                        </button>
                    </div>
                </div>

                {tab === 'dashboard' ? (
                    <>
                        {/* COMBINED SIDE-BY-SIDE: SYMPTOMS (Left) & PRESETS (Right) */}
<div className="mb-6 no-print grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
    
    {/* LEFT: Pain Selectors */}
    <div className="bg-slate-900/30 p-3 rounded-xl border border-slate-800/50">
        <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">Pain / Symptoms</div>
        <div className="flex flex-wrap gap-2">
            {['Neck Pain', 'Back Pain', 'Knee Pain', 'Foot Pain'].map(sym => (
                <div key={sym} onClick={() => toggleSymptom(sym)} className={`symptom-chip ${symptoms.includes(sym) ? 'selected' : ''}`}>
                    {symptoms.includes(sym) && <Icons.Check />} {sym}
                </div>
            ))}
        </div>
    </div>

    {/* RIGHT: Quick Start Chips */}
    <div className="bg-slate-900/30 p-3 rounded-xl border border-slate-800/50">
        <div className="text-[10px] font-bold text-slate-500 uppercase mb-2 flex justify-between items-center">
            <span>Quick Start Protocols</span>
            <span className="text-cyan-600 text-[9px] bg-cyan-900/20 px-1.5 py-0.5 rounded border border-cyan-900/30">NO SCAN NEEDED</span>
        </div>
        <div className="flex flex-wrap gap-2">
            {Object.keys(PRESET_PROTOCOLS).map((presetName) => (
                <button 
                    key={presetName} 
                    onClick={() => loadPreset(presetName)}
                    className="px-2 py-1 bg-slate-800 hover:bg-cyan-900/20 border border-slate-700 hover:border-cyan-500/30 rounded text-[9px] font-bold text-slate-400 hover:text-cyan-400 transition-all uppercase tracking-wider flex items-center gap-1 shadow-sm"
                >
                    <Icons.Play className="w-2 h-2" /> {presetName}
                </button>
            ))}
        </div>
    </div>
</div>

        
                        <div className="mb-4 flex justify-center gap-4 no-print">
                            <label className="flex items-center gap-3 cursor-pointer">
                                <input
                                    type="checkbox"
                                    checked={useEquipment}
                                    onChange={(e) => setUseEquipment(e.target.checked)}
                                    className="w-6 h-6 rounded text-cyan-500 focus:ring-cyan-500"
                                />
                                <span className="text-sm font-bold text-slate-300">Use Equipment</span>
                            </label>
                            <label className="flex items-center gap-3 cursor-pointer">
                                <input
                                    type="checkbox"
                                    checked={!userPrefs.lowImpact}
                                    onChange={(e) => setUserPrefs(p => ({ ...p, lowImpact: !e.target.checked }))}
                                    className="w-6 h-6 rounded text-orange-500 focus:ring-orange-500"
                                />
                                <span className="text-sm font-bold text-slate-300">High Intensity Mode</span>
                            </label>
                        </div>


                        {/* THIS MAKES THE 3 BOXES BIG AND NOT CUT OFF */}
                        <div className="flex-1 upload grid">
                            <div className="upload-grid gap-6 px-4">
                                {['front', 'side', 'back'].map(view => (
                                    <div key={view} className={`upload-slot ${uploads[view] ? 'active' : ''} ${status.analyzing && uploads[view] ? 'analyzing' : ''}`}>
                                        {uploads[view] ? (
                                            <div className="w-full h-full relative">
                                                <img
                                                    ref={el => { if (el) uploadRefs[view].current = el; }}
                                                    src={uploads[view].url}
                                                    className="absolute inset-0 w-full h-full object-cover opacity-0"
                                                    crossOrigin="anonymous"
                                                    alt={`User's ${view} body view for posture analysis`}
                                                />
                                                <canvas
                                                    id={`canvas-${view}`}
                                                    className="absolute inset-0 w-full h-full object-cover pointer-events-none z-10"
                                                />
                                                <div className="absolute top-2 right-2 bg-emerald-500 text-black text-[10px] font-bold px-2 py-1 rounded flex items-center gap-1 z-20"><Icons.Check /> ANALYZED</div>
                                                <div className="absolute inset-0 bg-black/40 opacity-0 hover:opacity-100 transition-opacity flex items-center justify-center text-xs font-bold uppercase tracking-widest z-20 cursor-pointer" onClick={() => uploadRefs[view].current.click()}>
                                                    Click to Change
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center h-full gap-8 relative">
                                                {/* Silhouette Guide */}
                                                <div className="absolute inset-0 flex items-center justify-center opacity-10 pointer-events-none">
                                                    <svg viewBox="0 0 200 400" className="w-1/2">
                                                        <circle cx="100" cy="60" r="30" fill="none" stroke="#22d3ee" strokeWidth="4" />
                                                        <rect x="70" y="100" width="60" height="120" rx="20" fill="none" stroke="#22d3ee" strokeWidth="4" />
                                                        <line x1="70" y1="140" x2="40" y2="200" stroke="#22d3ee" strokeWidth="4" />
                                                        <line x1="130" y1="140" x2="160" y2="200" stroke="#22d3ee" strokeWidth="4" />
                                                        <line x1="80" y1="220" x2="70" y2="320" stroke="#22d3ee" strokeWidth="4" />
                                                        <line x1="120" y1="220" x2="130" y2="320" stroke="#22d3ee" strokeWidth="4" />
                                                    </svg>
                                                </div>

                                                <div className="text-center z-10">
                                                    <p className="text-3xl font-black text-white mb-2 uppercase tracking-wider">{view}</p>
                                                    <p className="text-sm text-slate-400">Tap to upload or use camera</p>
                                                </div>

                                                <div className="flex gap-6 z-10">
                                                    <button onClick={() => uploadRefs[view].current.click()} className="px-8 py-4 bg-cyan-600 hover:bg-cyan-500 rounded-xl font-bold text-lg shadow-lg shadow-cyan-900/50 transition-all hover:scale-105">
                                                        Upload Photo
                                                    </button>
                                                    <button onClick={() => setCameraActive(view)} className="px-8 py-4 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-lg shadow-lg transition-all hover:scale-105">
                                                        Camera
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                        <div className="scanner-line"></div>
                                        <input type="file" ref={uploadRefs[view]} className="hidden" accept="image/*" onChange={(e) => handleFile(e, view)} />
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* LOGS AT BOTTOM */}
                        <div className="mt-4 flex gap-4 text-[10px] font-mono text-slate-500 bg-slate-900/50 p-2 rounded border border-slate-800 no-print">
                            {status.logs.map((l, i) => <span key={i}>{l}<br /></span>)}
                        </div>

                        {/* NEW: POST-ANALYSIS RESULTS PAGE - IMMEDIATE FEEDBACK */}
                        {status.analyzed && !status.analyzing && (
                            <div className="mt-12 animate-fadeIn">
                                {/* Hero Score + Avatar Section */}
                                <div className="bg-gradient-to-b from-cyan-900/40 to-purple-900/40 rounded-3xl p-8 shadow-2xl border border-cyan-500/30">
                                    <h2 className="text-4xl font-black text-center text-white mb-8 uppercase tracking-wider">Your Posture Score</h2>

                                    {/* Circular Gauge for Overall Score */}
                                    <div className="flex flex-col items-center mb-12">
                                        <div className="relative w-64 h-64">
                                            {/* Simple SVG Circular Progress Gauge */}
                                            <svg className="w-full h-full -rotate-90">
                                                <circle cx="128" cy="128" r="120" stroke="#1e293b" strokeWidth="16" fill="none" />
                                                <circle
                                                    cx="128" cy="128" r="120"
                                                    stroke={audit.score >= 80 ? "#10b981" : audit.score >= 60 ? "#f59e0b" : "#ef4444"}
                                                    strokeWidth="16"
                                                    fill="none"
                                                    strokeDasharray={`${2 * Math.PI * 120}`}
                                                    strokeDashoffset={`${2 * Math.PI * 120 * (1 - audit.score / 100)}`}
                                                    className="transition-all duration-2000 ease-out"
                                                    strokeLinecap="round"
                                                />
                                            </svg>
                                            <div className="absolute inset-0 flex items-center justify-center">
                                                <div className="text-center">
                                                    <div className="text-7xl font-black text-white">{audit.score}</div>
                                                    <div className="text-xl font-bold text-slate-300 uppercase tracking-wider">/100</div>
                                                </div>
                                            </div>
                                        </div>
                                        <p className="mt-6 text-2xl font-bold text-center text-white">
                                            {audit.score >= 80 ? "Excellent Alignment!" : audit.score >= 60 ? "Good, Room to Improve" : "Needs Attention"}
                                        </p>
                                    </div>

                                    {/* Digital Avatar - Simple Stick Figure Skeleton */}
                                    <div className="max-w-md mx-auto bg-black/60 rounded-2xl p-6 border border-cyan-400/50">
                                        <h3 className="text-xl font-bold text-center text-cyan-300 mb-4 uppercase">Your Biomechanical Avatar</h3>
                                        <div className="relative aspect-[3/5] bg-slate-900 rounded-xl overflow-hidden">
                                            {/* Composite background from side view or averaged */}
                                            {uploads.side && (
                                                <img src={uploads.side.url} className="absolute inset-0 w-full h-full object-cover opacity-30" alt="Background" />
                                            )}
                                            {/* SVG Skeleton Overlay - use keypoints from analysis */}
                                            <svg className="absolute inset-0 w-full h-full" viewBox="0 0 300 600" preserveAspectRatio="xMidYMid meet">
                                                {sideKeypoints ? (
                                                    <>
                                                        {/* Head - Nose (0), Ears (7,8), Eyes avg */}
                                                        {sideKeypoints[0]?.score > 0.5 && (
                                                            <circle
                                                                cx={150 + (sideKeypoints[0].x - 0.5) * 200}
                                                                cy={80 + (sideKeypoints[0].y - 0.2) * 400}
                                                                r="30"
                                                                fill={audit?.head.grade === 'F' ? '#ef4444' : audit?.head.grade === 'D' ? '#f59e0b' : '#22d3ee'}
                                                                opacity="0.8"
                                                            />
                                                        )}

                                                        {/* Spine: Shoulder (11/12 avg) → Hip (23/24 avg) */}
                                                        {(() => {
                                                            const leftShoulder = sideKeypoints[11];
                                                            const rightShoulder = sideKeypoints[12];
                                                            const leftHip = sideKeypoints[23];
                                                            const rightHip = sideKeypoints[24];

                                                            if (leftShoulder?.score > 0.5 && rightShoulder?.score > 0.5) {
                                                                const shoulderX = (leftShoulder.x + rightShoulder.x) / 2 * 300;
                                                                const shoulderY = (leftShoulder.y + rightShoulder.y) / 2 * 600;
                                                                const hipX = leftHip && rightHip ? (leftHip.x + rightHip.x) / 2 * 300 : shoulderX;
                                                                const hipY = leftHip && rightHip ? (leftHip.y + rightHip.y) / 2 * 600 : shoulderY + 200;

                                                                return (
                                                                    <line
                                                                        x1={shoulderX} y1={shoulderY}
                                                                        x2={hipX} y2={hipY}
                                                                        stroke={audit?.spine.grade === 'F' ? '#ef4444' : audit?.spine.grade === 'D' ? '#f59e0b' : '#22d3ee'}
                                                                        strokeWidth="12"
                                                                        strokeLinecap="round"
                                                                    />
                                                                );
                                                            }
                                                        })()}

                                                        {/* Arms - Left side visible in side view */}
                                                        {sideKeypoints[11]?.score > 0.5 && sideKeypoints[13]?.score > 0.5 && sideKeypoints[15]?.score > 0.5 && (
                                                            <>
                                                                <line x1={sideKeypoints[11].x * 300} y1={sideKeypoints[11].y * 600}
                                                                    x2={sideKeypoints[13].x * 300} y2={sideKeypoints[13].y * 600}
                                                                    stroke={audit?.shoulders.grade === 'F' ? '#ef4444' : audit?.shoulders.grade === 'D' ? '#f59e0b' : '#22d3ee'}
                                                                    strokeWidth="10" />
                                                                <line x1={sideKeypoints[13].x * 300} y1={sideKeypoints[13].y * 600}
                                                                    x2={sideKeypoints[15].x * 300} y2={sideKeypoints[15].y * 600}
                                                                    stroke={audit?.shoulders.grade === 'F' ? '#ef4444' : audit?.shoulders.grade === 'D' ? '#f59e0b' : '#22d3ee'}
                                                                    strokeWidth="10" />
                                                            </>
                                                        )}

                                                        {/* Legs */}
                                                        {sideKeypoints[23]?.score > 0.5 && sideKeypoints[25]?.score > 0.5 && sideKeypoints[27]?.score > 0.5 && (
                                                            <>
                                                                <line x1={sideKeypoints[23].x * 300} y1={sideKeypoints[23].y * 600}
                                                                    x2={sideKeypoints[25].x * 300} y2={sideKeypoints[25].y * 600}
                                                                    stroke={audit?.hip.grade === 'F' ? '#ef4444' : audit?.hip.grade === 'D' ? '#f59e0b' : '#10b981'}
                                                                    strokeWidth="12" />
                                                                <line x1={sideKeypoints[25].x * 300} y1={sideKeypoints[25].y * 600}
                                                                    x2={sideKeypoints[27].x * 300} y2={sideKeypoints[27].y * 600}
                                                                    stroke={audit?.gait.grade === 'F' ? '#ef4444' : audit?.gait.grade === 'D' ? '#f59e0b' : '#10b981'}
                                                                    strokeWidth="12" />
                                                            </>
                                                        )}
                                                    </>
                                                ) : (
                                                    // Fallback static skeleton while loading
                                                    <>
                                                        <circle cx="150" cy="80" r="30" fill="#22d3ee" opacity="0.6" />
                                                        <line x1="150" y1="110" x2="150" y2="400" stroke="#22d3ee" strokeWidth="8" opacity="0.6" />
                                                        <line x1="150" y1="150" x2="100" y2="300" stroke="#22d3ee" strokeWidth="8" opacity="0.6" />
                                                        <line x1="150" y1="150" x2="200" y2="300" stroke="#22d3ee" strokeWidth="8" opacity="0.6" />
                                                    </>
                                                )}
                                            </svg>
                                        </div>
                                        <p className="text-center text-sm text-slate-400 mt-4">Red = Major Deviation | Orange = Moderate | Green = Good</p>
                                    </div>
                                </div>
                            </div>
                        )}
                        {/* Quick Insights Chips */}
                        <div className="mt-12">
                            <h3 className="text-2xl font-bold text-center text-white mb-6 uppercase tracking-wider">Key Findings</h3>
                            <div className="flex flex-wrap justify-center gap-4">
                                {audit && [
                                    ...(audit.head.grade === 'F' || audit.head.grade === 'D' ? [{ name: "Forward Head Posture", severity: audit.head.grade === 'F' ? 'high' : 'medium' }] : []),
                                    ...(audit.shoulders.grade === 'F' || audit.shoulders.grade === 'D' ? [{ name: "Rounded / Uneven Shoulders", severity: audit.shoulders.grade === 'F' ? 'high' : 'medium' }] : []),
                                    ...(audit.spine.grade === 'F' || audit.spine.grade === 'D' ? [{ name: "Spinal Compression", severity: audit.spine.grade === 'F' ? 'high' : 'medium' }] : []),
                                    ...(audit.hip.grade === 'F' || audit.hip.grade === 'D' ? [{ name: "Pelvic Tilt / Hip Shift", severity: audit.hip.grade === 'F' ? 'high' : 'medium' }] : []),
                                    ...(audit.gait.grade === 'F' || audit.gait.grade === 'D' ? [{ name: "Weak Elastic Recoil", severity: audit.gait.grade === 'F' ? 'high' : 'medium' }] : []),
                                ].map((dev, i) => (
                                    <div key={i} className={`px-6 py-3 rounded-full font-bold text-lg shadow-lg transition-all hover:scale-105 ${dev.severity === 'high' ? 'bg-red-600 text-white' :
                                        'bg-orange-500 text-black'
                                        }`}>
                                        {dev.name}
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* ACADEMY LINK - RESTORED */}
                        <div className="mt-8 text-center pt-8 border-t border-slate-800">
                            <p className="text-sm font-bold text-slate-500 uppercase mb-4">WANT TO LEARN THE SCIENCE?</p>
                            <button onClick={() => setTab('academy')} className="px-8 py-3 bg-gradient-to-r from-slate-800 to-slate-900 border border-slate-700 hover:border-cyan-500 rounded-xl text-slate-300 font-bold flex items-center gap-2 mx-auto hover:text-cyan-400 transition-all">
                                <Icons.Video /> OPEN MOVEMENT ACADEMY
                            </button>
                        </div>

                        {/* LOGS AT BOTTOM */}
                        <div className="mt-4 flex gap-4 text-[10px] font-mono text-slate-500 bg-slate-900/50 p-2 rounded border border-slate-800 no-print">
                            {status.logs.map((l, i) => <span key={i}>{l}<br /></span>)}
                        </div>
                    </>
                ) : tab === 'progress' ? (
    <div className="p-6 space-y-8 overflow-y-auto">
        <div className="text-center mb-8">
            <h2 className="text-3xl font-black text-white mb-2">Progress Dashboard</h2>
            <p className="text-slate-400 text-lg">Watch your body evolve — one scan at a time.</p>
        </div>
        <StreakTracker streakDays={streakDays} onReset={resetStreak} />
        <GoalTracker
            currentScore={audit?.score || history[0]?.score || 0}
            targetScore={currentGoal.target}
            progress={currentGoal}
            forecast={audit?.forecast || history[0]?.forecast || null}
            onUpdateGoal={updateGoal}
        />
        
        {/* ADDED COMPONENTS HERE */}
        <TrendGraph history={history} />
        <FascialLineTrends history={history} />
        
        <div className="bg-slate-900/50 border border-slate-700 rounded-lg p-6">
            <h3 className="text-lg font-black text-white mb-4 flex items-center gap-3">
                <Icons.Award /> Milestones
            </h3>
            <div className="space-y-3">
                {achievements.map(a => (
                    <div key={a.id} className={`flex items-center justify-between p-4 rounded-xl border ${a.unlocked ? 'bg-emerald-900/30 border-emerald-600' : 'bg-slate-800/50 border-slate-700'}`}>
                        <div className="flex items-center gap-4">
                            <div className={`w-12 h-12 rounded-full flex items-center justify-center ${a.unlocked ? 'bg-emerald-600' : 'bg-slate-700'}`}>
                                {a.icon}
                            </div>
                            <div>
                                <div className="font-bold text-white">{a.name}</div>
                                <div className="text-xs text-slate-400">{a.desc}</div>
                            </div>
                        </div>
                        {a.unlocked && <Icons.Check className="text-emerald-400 w-8 h-8" />}
                    </div>
                ))}
            </div>
        </div>
        {audit && (
            <button onClick={() => setShowShare(true)} className="w-full py-4 bg-gradient-to-r from-cyan-600 to-purple-600 hover:from-cyan-500 hover:to-purple-500 text-white font-black rounded-2xl uppercase tracking-wider shadow-2xl shadow-cyan-900/50 flex items-center justify-center gap-3">
                <Icons.Share /> Share Progress Report
            </button>
        )}
    </div>
                ) : (
                    // Fallback to Academy for 'academy' or any unknown tab
                    <div className="min-h-screen bg-slate-950">
                        <KnowledgeBase onOpen={setShowReader} />
                    </div>
                )}
            </div>

            {/* RIGHT PANEL - The Value Engine */}
            {/* Removed 'flex flex-col' so it doesn't squeeze the content */}
            <div className={`glass-panel flex flex-col ${postAnalysisMode ? 'expanded' : ''}`}>
                {/* Removed 'shrink-0' because we aren't flexing anymore */}

                <div className="p-6 border-b border-slate-800 bg-slate-900/50 flex-1 overflow-y-auto">

{/* OPTIMIZED HEADER: Perfect spacing, slightly smaller buttons & numbers */}
<div className="relative mb-10 pt-4"> {/* Reduced bottom margin, added top padding */}

    {/* Top Nav Buttons - Slightly smaller, more compact */}
    <div className="flex justify-center gap-3 mb-10 px-6"> {/* Reduced gap & added horizontal padding */}
        <button 
            onClick={() => { 
                setTab('dashboard'); 
                setPostAnalysisMode(false);
            }} 
            className={`px-7 py-3 text-base font-black uppercase tracking-widest rounded-xl transition-all duration-300 shadow-lg ${
                tab === 'dashboard' 
                    ? 'bg-gradient-to-r from-cyan-500 to-blue-600 text-white shadow-cyan-900/50' 
                    : 'bg-slate-800/50 text-slate-400 hover:text-white hover:bg-slate-700'
            }`}
        >
            SCAN
        </button>
        <button 
            onClick={() => { 
                setTab('progress'); 
                setPostAnalysisMode(false);
            }} 
            className={`px-7 py-3 text-base font-black uppercase tracking-widest rounded-xl transition-all duration-300 shadow-lg ${
                tab === 'progress' 
                    ? 'bg-gradient-to-r from-indigo-500 to-purple-600 text-white shadow-indigo-900/50' 
                    : 'bg-slate-800/50 text-slate-400 hover:text-white hover:bg-slate-700'
            }`}
        >
            DATA
        </button>
        <button 
            onClick={() => { 
                setTab('academy'); 
                setPostAnalysisMode(false);
            }} 
            className={`px-7 py-3 text-base font-black uppercase tracking-widest rounded-xl transition-all duration-300 shadow-lg ${
                tab === 'academy' 
                    ? 'bg-gradient-to-r from-emerald-500 to-teal-600 text-white shadow-emerald-900/50' 
                    : 'bg-slate-800/50 text-slate-400 hover:text-white hover:bg-slate-700'
            }`}
        >
            LEARN
        </button>
    </div>

    {/* Score + Bio Age Row - Slightly smaller numbers, better vertical alignment */}
    <div className="flex justify-center items-baseline gap-10 px-6"> 
        {/* Structural Score */}
        <div className="text-center">
            <div className="text-xs font-bold text-cyan-500 uppercase tracking-widest mb-1">Structural Score</div>
            <div className={`text-7xl font-black tracking-tighter leading-none text-yellow-400 ${audit && audit.date !== new Date().toLocaleDateString() ? 'opacity-50' : ''}`}>
                {audit && !isNaN(audit.score) ? audit.score : 0}
            </div>
        </div>

        {/* Biological Age */}
        {audit && (
            <div className="text-center">
                <div className="text-xs font-bold text-red-500 uppercase tracking-widest mb-1">Biological Age</div>
                <div className="text-7xl font-black tracking-tighter leading-none text-red-500">
                    {audit.bioAge}
                </div>
                <div className="text-xs font-bold text-slate-500 uppercase tracking-widest mt-1">Years Old</div>
            </div>
        )}
    </div>
</div>

{/* MY PROTOCOL BUTTON - Appears only after scan */}
                    {/* Change activeProgram to generatedRoutine in the check below */}


                    {/* MY PROTOCOL Button - Always visible after scan */}
                    {audit && (
    <>
                {/* BIG MY PROTOCOL BUTTON - FIXED VERSION */}
        <div className="mt-8 animate-popIn">
            <button
                onClick={() => {
                    // ALWAYS regenerate the latest protocol on click
                    generateProgram();
                    // Use a small timeout to ensure state has updated
                    setTimeout(() => {
                        setActiveProgram(generatedRoutine);
                    }, 100);
                }}
                className="w-full py-10 bg-gradient-to-r from-cyan-500 via-blue-600 to-purple-700 
                       hover:from-cyan-400 hover:via-blue-500 hover:to-purple-600 
                       text-white font-black text-4xl rounded-3xl uppercase tracking-widest 
                       shadow-2xl shadow-cyan-900/80 
                       border-4 border-cyan-400/60
                       transition-all duration-700 hover:scale-105 hover:shadow-cyan-500/50 flex items-center justify-center gap-6"
            >
                <Icons.List className="w-12 h-12" />
                MY PROTOCOL
            </button>
        </div>

        {/* Streak Bonus Message */}
        {streakDays >= 7 && generatedRoutine && (
            <div className="mt-4 p-4 bg-emerald-900/30 border border-emerald-700/50 rounded-xl text-center animate-popIn">
                <div className="text-emerald-400 font-black text-lg flex items-center justify-center gap-2">
                    <Icons.Flame className="streak-flame" /> {streakDays}-DAY STREAK BONUS
                </div>
                <p className="text-xs text-emerald-300 mt-1">+1 Advanced Flow Added</p>
            </div>
        )}

{/* EQUIPMENT TOGGLE */}
        <div className="mt-12 w-full">
            <div className="flex bg-slate-900 p-1 rounded-xl border border-slate-700">
                <button onClick={() => setUseEquipment(false)} className={`flex-1 py-3 text-sm font-bold rounded-lg transition-all ${!useEquipment ? 'bg-cyan-600 text-white shadow-inner' : 'text-slate-400 hover:text-slate-200'}`}>
                    BODYWEIGHT ONLY
                </button>
                <button onClick={() => setUseEquipment(true)} className={`flex-1 py-3 text-sm font-bold rounded-lg transition-all ${useEquipment ? 'bg-cyan-600 text-white shadow-inner' : 'text-slate-400 hover:text-slate-200'}`}>
                    ALL EQUIPMENT
                </button>
            </div>
        </div>

<TrendGraph history={history} />

        {/* FASCIAL INTEGRITY REPORT - RIGHT BELOW THE BUTTON */}
        <div className="mt-12 animate-popIn">
            <div className="text-center mb-6">
                <h3 className="text-lg font-black text-cyan-400 uppercase tracking-widest">Fascial Integrity Report</h3>
            </div>
            <div className="space-y-5">
                {[
                    { label: "Superficial Back Line", sub: "Posture / Extension", data: audit.head, risk: "Restriction" },
                    { label: "Deep Front Arm Line", sub: "Shoulder Stability", data: audit.shoulders, risk: "Tightness" },
                    { label: "Deep Front Line", sub: "Core Foundation", data: audit.spine, risk: "Compression" },
                    { label: "Lateral Line", sub: "Hip & Side Balance", data: audit.hip, risk: "Asymmetry" },
                    { label: "Spiral Line", sub: "Rotational Power", data: audit.gait, risk: "Weak Recoil" }
                ].map((m, i) => (
                    <div key={i} className="bg-slate-900/70 backdrop-blur-sm border border-slate-700/80 p-6 rounded-2xl hover:border-cyan-500/60 transition-all shadow-xl">
                        <div className="flex justify-between items-start mb-4">
                            <div>
                                <div className="text-lg font-black text-white">{m.label}</div>
                                <div className="text-xs text-cyan-400 font-bold mt-1">{m.sub}</div>
                            </div>
                            <div className={`text-5xl font-black ${m.data.grade === 'A' ? 'text-emerald-400' : m.data.grade === 'B' ? 'text-blue-400' : m.data.grade === 'C' ? 'text-yellow-400' : m.data.grade === 'D' ? 'text-orange-400' : 'text-red-400'}`}>
                                {m.data.grade}
                            </div>
                        </div>
                        <div className="w-full bg-slate-800 h-4 rounded-full overflow-hidden mb-4">
                            <div className={`h-full transition-all duration-1500 ease-out ${m.data.grade === 'A' ? 'bg-emerald-500' : m.data.grade === 'B' ? 'bg-blue-500' : m.data.grade === 'C' ? 'bg-yellow-500' : m.data.grade === 'D' ? 'bg-orange-500' : 'bg-red-500'}`} 
                                 style={{ width: `${m.data.val}%` }} />
                        </div>
                        <div className="flex justify-between items-center">
                            <span className="text-sm text-slate-300 font-mono">Integrity: {m.data.val}%</span>
                            {m.data.grade !== 'A' && (
                                <span className="text-sm font-bold text-red-400 bg-red-900/40 px-4 py-1 rounded-full border border-red-800/50">
                                    {m.risk}
                                </span>
                            )}
                        </div>
                    </div>
                ))}
            </div>
        </div>

        {/* DIGITAL TWIN + AI COACH */}
        <div className="mt-16 animate-popIn">
            <div className="bg-slate-900/80 rounded-3xl p-8 border-4 border-cyan-600/50 shadow-2xl shadow-cyan-900/60">
                <div className="text-2xl font-black text-cyan-400 mb-6 text-center uppercase tracking-widest">Your Digital Twin</div>
                <div className="w-full max-w-md mx-auto">
                    <BioAvatar audit={audit} symptoms={symptoms} onPartClick={(part) => {
                        const data = audit[part];
                        const analysis = PART_ANALYSIS[part];
                        const message = `**${analysis.title}**\n${analysis.intro(data.grade, data.val)}\n\n**Root Cause:** ${analysis.rootCause}\n\n**Immediate Fix:** ${analysis.fix}\n\n**Key Insight:** ${analysis.insight}\n\nCurrent grade: **${data.grade}** (${data.val}%)`;
                        handleChat(message);
                    }} />
                </div>
                <p className="text-center text-cyan-300 mt-8 text-lg font-bold">Tap any region for deep analysis</p>
            </div>

            <div className="mt-8 bg-slate-900/60 rounded-2xl border border-slate-700 overflow-hidden shadow-2xl">
                <AICoach 
                audit={audit} 
                symptoms={symptoms} 
                chatHistory={chatHistory} 
                onSend={handleChat} 
                onAction={handleCoachAction} 
            />
            </div>
        </div>
    </>
)}

{/* BEFORE / AFTER COMPARISON SLIDER */}
{audit && history.length >= 1 && beforeImage && afterImage && (
    <div className="mt-12 animate-popIn">
        <h3 className="text-xl font-black text-cyan-400 uppercase tracking-widest text-center mb-6">
            Your Progress Slider
        </h3>
        <div className="relative w-full h-96 bg-slate-900/50 rounded-2xl overflow-hidden border border-cyan-500/30">
            {/* After Image (top layer) */}
            <img src={afterImage} className="absolute inset-0 w-full h-full object-contain" alt="Latest" />
            {/* Before Image (bottom layer) */}
            <img src={beforeImage} className="absolute inset-0 w-full h-full object-contain" alt="First scan" />
            {/* Slider Handle */}
            <input
                type="range"
                min="0"
                max="100"
                defaultValue="50"
                className="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-10"
                onInput={(e) => {
                    const val = e.target.value;
                    e.target.parentElement.style.clipPath = `inset(0 ${100 - val}% 0 0)`;
                }}
            />
            {/* Visual Handle */}
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div className="w-12 h-12 bg-white rounded-full shadow-2xl flex items-center justify-center">
                    <svg className="w-6 h-6 text-black" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M8 12h8M12 8v8" />
                    </svg>
                </div>
            </div>
            <div className="absolute bottom-4 left-4 bg-black/70 px-3 py-1 rounded text-xs font-bold text-cyan-300">First Scan</div>
            <div className="absolute bottom-4 right-4 bg-black/70 px-3 py-1 rounded text-xs font-bold text-emerald-300">Today</div>
        </div>
        <p className="text-center text-sm text-slate-400 mt-4">Drag to compare your transformation</p>
    </div>
)}


                    {/* ACADEMY LINK (Right Panel Fallback) */}
                    <div className="mt-6 text-center">
                        <button onClick={() => setTab('academy')} className="text-[10px] font-bold text-slate-500 hover:text-cyan-400 uppercase tracking-widest transition-colors flex items-center justify-center gap-1">
                            <Icons.Video className="w-3 h-3" /> View Academy
                        </button>
                    </div>

                    <div className="mt-6 flex gap-4 no-print justify-center items-center flex-wrap">
                        <button
    onClick={() => {
        setTab('dashboard');
        runAnalysis();
    }}
    disabled={status.analyzing}
    className={`px-6 py-3 rounded-xl text-sm font-bold flex items-center gap-3 transition-all shadow-lg ${
        audit && audit.date !== new Date().toLocaleDateString()
            ? 'bg-cyan-600 hover:bg-cyan-500 text-white animate-pulse shadow-cyan-900/50'
            : 'bg-slate-800 hover:bg-slate-700 disabled:opacity-50 text-white'
    }`}
>
    <Icons.Scan className="w-5 h-5" />
    {audit && audit.date !== new Date().toLocaleDateString() ? "UPDATE SCAN" : "RESCAN"}
</button>
                        <div className="px-6 py-3 bg-slate-800 text-slate-400 rounded-xl text-sm font-bold flex items-center gap-3 shadow-lg">
                            <Icons.History className="w-5 h-5" /> {history.length} SCANS
                        </div>
                    </div>


                </div>

            </div>

            
            {activeProgram && <ProgramPlayer program={activeProgram} onClose={() => setActiveProgram(null)} onFeedback={handleFeedback} />}
        </div>
    );
};


    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
